{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"KumoMTA Documentation","text":"<p>This the is documentation site for the KumoMTA Message Transfer Agent.</p> <p>The documentation is organized into four sections:</p> <ul> <li>The Tutorial - a beginner's guide for those who are new to setting up, configuring, testing, and deploying email infrastructure.</li> <li>The User Guide - a guide for those who are familiar with email infrastructure but are new to KumoMTA and its unique features and capabilities.</li> <li>The Reference Manual - for those who are familiar with KumoMTA, and need to quickly look up syntax and examples for functions and modules.</li> <li>The Changelog - a collection of all the updates, bug fixes, and changes made to KumoMTA on a per-release basis.</li> </ul>"},{"location":"changelog/","title":"Changelog","text":"<ul> <li>Unreleased Changes in The Mainline</li> <li>Release 2023.12.28-63cde9c7</li> <li>Release 2023.11.28-b5252a41</li> <li>Release 2023.08.22-4d895015 - Automation</li> <li>Release 2023.06.22-51b72a83</li> <li>Release 2023.05.10-e88ad036 - Beta 2</li> <li>Release 2023.03.31-36aa20de - Beta1</li> </ul>"},{"location":"changelog/2023.03.31-36aa20de/","title":"Release 2023.03.31-36aa20de - Beta1","text":"<p>This section will list all of the major changes that happened within this release of KumoMTA. Depending on the install environment, not all of the listed changes may apply.</p>"},{"location":"changelog/2023.05.10-e88ad036/","title":"Release 2023.05.10-e88ad036 - Beta 2","text":"<p>This section will list all of the major changes that happened within this release of KumoMTA. Depending on the install environment, not all of the listed changes may apply.</p> <ul> <li>Expose ready queue size to metrics. #30</li> <li>Fixed IPv6 lookups for domains without MX records</li> <li>kumo.configure_local_logs can now be called   multiple times to configure multiple different logging locations and   configurations.</li> <li>Added HA Proxy client support. #19</li> <li>Added HTTP delivery support. #36</li> <li>Added logging for inject and delivery types.</li> <li>Added option to force fsync per-message. #6</li> <li>Added traffic shaping policy helper. #43</li> <li>Added webhook support. #18</li> </ul>"},{"location":"changelog/2023.06.22-51b72a83/","title":"Release 2023.06.22-51b72a83","text":"<p>This section will list all of the major changes that happened within this release of KumoMTA. Depending on the install environment, not all of the listed changes may apply.</p>"},{"location":"changelog/2023.06.22-51b72a83/#breaking-changes","title":"Breaking Changes","text":"<ul> <li> <p>Handling of egress source/pool has moved from <code>define_egress_source</code> and <code>define_egress_pool</code> to <code>make_egress_source</code> and <code>make_egress_pool</code>, allowing these configurations to be loaded dynamically at runtime, removing the need for a server restart. See make_egress_source.</p> </li> <li> <p>Configuration of relay domains has been moved out of <code>start_esmtp_listener</code> into its own event, allowing these configurations to be loaded dynamically at runtime, removing the need for a server restart. See make_listener_domain.</p> </li> </ul>"},{"location":"changelog/2023.06.22-51b72a83/#enhancements","title":"Enhancements","text":"<ul> <li>spool_message_enumerated   event. #42</li> <li>Rabbit MQ/AMQP Event/Message Publishing. #31</li> <li>SOCKS5 Proxy Support. #45</li> <li>Added helper policy scripts for managing egress source/pool and listeners domains. See make_egress_source and make_listener_domain.</li> </ul>"},{"location":"changelog/2023.06.22-51b72a83/#fixes","title":"Fixes","text":"<ul> <li>Fix issue with log flushing during shutdown. #46</li> </ul>"},{"location":"changelog/2023.08.22-4d895015/","title":"Release 2023.08.22-4d895015 - Automation","text":""},{"location":"changelog/2023.08.22-4d895015/#breaking-changes","title":"Breaking Changes","text":"<ul> <li>kumo.configure_log_hook now requires   a name field to be set to identify which instance of a log hook is being considered   by the should_enqueue_log_record event.   This change is to support distributing logs to the traffic shaping automation   service in addition to feeding them into your own reporting infrastructure.</li> </ul>"},{"location":"changelog/2023.08.22-4d895015/#new-traffic-shaping-automation","title":"New: Traffic Shaping Automation","text":"<ul> <li>The <code>shaping.toml</code> file now supports automation rules. See the UserGuide for information on how to deploy this feature.</li> </ul>"},{"location":"changelog/2023.08.22-4d895015/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>Calling   kumo.configure_redis_throttles   now also enables redis-based shared connection limits. #41</li> <li>kumo.make_egress_path <code>max_deliveries_per_connection</code> now defaults to <code>1024</code> rather than unlimited.   Specifying unlimited deliveries is no longer supported as part of shared   connection limit lease fairness. #41</li> <li>Added   message:remove_all_named_headers.   Thanks to @postmastery! #70</li> <li>Ready queue names now factor in the delivery protocol, making it easier to vary   the protocol by eg: tenant or campaign while keeping the domain the same.   You will notice a suffix like <code>@smtp</code> on the end of queue names in metrics   and in the <code>site_name</code> field of log records as a result of this change.</li> <li>It is now more convenient to do smart hosting using the new smtp protocol <code>mx_list</code>   in kumo.make_queue_config.</li> <li>Introduced new <code>routing_domain</code> meta value (see predefined   values) which allows you to override the recipient   domain for routing/delivery, without blending scheduled queues.</li> <li>New kumo.cidr.make_map function for   building CIDR lookup tables/mappings.</li> <li>The listener_domains policy   helper   now supports <code>relay_from_authz</code> to allow listing out authorization identities   for which relaying from a particular sending domain is permitted.</li> <li>The kumo.digest module for computing SHA   digests of strings and other data.</li> <li>The kumo.encode module for encoding/decoding   base32, base64 and hex strings.</li> <li>kumo.dns.configure_resolver for   adjusting DNS resolver configuration.</li> <li>kumo.dkim.ed25519_signer now also   supports loading signing keys that are in PEM encoded PKCS8 format.</li> </ul>"},{"location":"changelog/2023.08.22-4d895015/#fixes","title":"Fixes","text":"<ul> <li>Loading secrets from HashiCorp Vault failed to parse underlying json data into   a byte array.</li> <li><code>kumo.reject(421, ...)</code> didn't disconnect the incoming session. #79</li> <li><code>kumo.reject</code> in <code>smtp_server_message_received</code> could still produce a <code>250 ok</code>   after the rejection response.</li> </ul>"},{"location":"changelog/2023.11.28-b5252a41/","title":"Release 2023.11.28-b5252a41","text":""},{"location":"changelog/2023.11.28-b5252a41/#breaking-changes","title":"Breaking Changes","text":"<p>None known</p>"},{"location":"changelog/2023.11.28-b5252a41/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>New RFC-conformance options are available to control server behavior   when receiving messages that are non-conformant:<ul> <li>invalid_line_endings #22 #23</li> <li>line_length_hard_limit #25</li> <li>message:check_fix_conformance #17 #24 #26</li> </ul> </li> <li>HTTP injection API will now parse and re-encode the message content to ensure   that it has appropriate transfer encoding applied when <code>content</code> is set to a   string, rather than using the builder variant of the API.</li> <li>Preliminary support for   MTA-STS. It defaults to   enabled. See   make_egress_path for   more details. At this time, we do not support   TLSRPT.</li> <li>Preliminary support for   DANE. It defaults to   disabled because it requires additional configuration to enable DNSSEC. See   make_egress_path for   more details. At this time, we do not support   TLSRPT.</li> <li>The DKIM   helper   now allows setting <code>body_canonicaliation</code> and <code>header_canonicalization</code>.   Thanks to @cai-n! #81</li> <li>msg:dkim_verify() and   msg:add_authentication_results() #82</li> <li>You may now use <code>log_record</code> to refer to the entire log record when using   templated log files. See   kumo.configure_local_logs for   more information.</li> <li>You may now specify an optional <code>segment_header</code> and optional <code>filter_event</code>,   when customizing local logs.   See kumo.configure_local_logs   for more information.</li> <li>Delivery log records now include information about the TLS cipher, protocol   version and peer subject name for SMTP deliveries that used TLS</li> <li>New regex_set_map type for efficiently   matching multiple regular expressions in a single search operation and returning   an associated value.</li> <li>New   smtp_client_rewrite_delivery_status   event to enable rewriting SMTP client status codes.</li> <li>minijinja templates now provide date/time formatting filters and globals   via minijinja_contrib.   Thanks to @cai-n! #91</li> <li>It is no longer necessary to call <code>shaper.get_queue_config</code> when using the shaping   helper together with TSA.  You should change your config from:</li> </ul> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nlocal cfg = shaper.get_queue_config(domain, tenant, campaign)\nif cfg then\nreturn cfg\nend\n-- Do your normal queue config handling here\nend)\n</code></pre> <p>to:</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\n-- Do your normal queue config handling here\nend)\n</code></pre> <ul> <li>It is no longer necessary to register <code>shaper.should_enqueue_log_record</code> when using the shaping   helper together with TSA.  You should remove this line from your config:</li> </ul> <pre><code>-- Remove this next line\nkumo.on('should_enqueue_log_record', shaper.should_enqueue_log_record)\n</code></pre> <ul> <li>New pre_init event to aid in building optional   modular lua helpers.</li> <li>log records now only log meta values which are non-null. Thanks to @cai-n! #94</li> <li>Admin bounces now have the option to suppress generation of <code>AdminBounce</code> log   records. #75</li> </ul>"},{"location":"changelog/2023.11.28-b5252a41/#fixes","title":"Fixes","text":"<ul> <li>HTTP injection API did not expand templating in <code>From</code>, <code>Reply-To</code> or   <code>Subject</code> headers unless they were set in the additional headers object</li> <li>Allow optional spaces after the colon in <code>MAIL FROM:</code> and <code>RCPT TO:</code>. #76</li> <li>Missing 334 response to clients using multi-step SMTP <code>AUTH PLAIN</code></li> <li>Messages that require \"dot stuffing\" could hang an outgoing SMTP session   and tie up a connection until the data and/or data-dot timeout was reached.</li> <li>DKIM Signature headers with a long list of signed headers would wrap on   hyphens instead of colons, which caused problems with some but not all   verifiers.</li> </ul>"},{"location":"changelog/2023.12.28-63cde9c7/","title":"Release 2023.12.28-63cde9c7","text":"<p>Note</p> <p>While the release is dated <code>2023.12.28</code>, that date reflects the date of the last change to the code, rather than the date that the release was cut and published. This release was published <code>2024.01.03</code>.</p>"},{"location":"changelog/2023.12.28-63cde9c7/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelog/2023.12.28-63cde9c7/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":"<ul> <li>You may now use arbitrary bounce classification labels when defining bounce classification rules. #98</li> <li>queue helper: Added <code>setup_with_options</code> method that allows skipping the registration of the   <code>get_queue_config</code> event handler. This helps when building a more complex configuration   policy, such as using the rollup helper. Thanks to @cai-n! #101</li> <li>You may now use simple suffix based wildcards like <code>X-*</code> to match header   names to capture in log records. See   kumo.configure_local_logs. #74</li> </ul>"},{"location":"changelog/2023.12.28-63cde9c7/#fixes","title":"Fixes","text":"<ul> <li>MTA-STS policy may fail to match due to trailing periods in mx host names</li> <li>Assigning <code>nil</code> via <code>msg:set_meta</code> would return a userdata wrapper around the   underlying json <code>null</code> value when <code>msg:get_meta</code> was called for that key.  We   now map that as <code>nil</code>.</li> <li>Various duration options (such as <code>idle_timeout</code>) once again accept bare   integer values to mean that number of seconds as stated in the docs.   Previously, you would have to use a string like <code>\"10 seconds\"</code>. Now you can   simply write <code>10</code>.  This regressed long long ago, but is now resolved. #108</li> <li>ARF parser now accepts historic feedback reports using version <code>0.1</code> and   the deprecated <code>Received-Date</code> header.</li> </ul>"},{"location":"changelog/main/","title":"Unreleased Changes in The Mainline","text":""},{"location":"changelog/main/#breaking-changes","title":"Breaking Changes","text":""},{"location":"changelog/main/#other-changes-and-enhancements","title":"Other Changes and Enhancements","text":""},{"location":"changelog/main/#fixes","title":"Fixes","text":"<ul> <li>The <code>delivered_this_connection</code> counter was incorrectly double-counted for   SMTP sessions, effectively halving the effective value of   <code>max_deliveries_per_connection</code>.</li> <li>Re-run the ready queue maintainer immediately after closing a connection   due to reaching the <code>max_deliveries_per_connection</code>, so that new connection(s)   can be established to replace the one that just closed. Previously, we would   only do this once every minute. #116</li> <li>The <code>smtp_client_rewrite_delivery_status</code> event could trigger with incorrect   scheduled queue name components.</li> </ul>"},{"location":"reference/","title":"Reference","text":"<p>This section contains reference documentation</p>"},{"location":"reference/authenticationresult/","title":"Authentication Result Object","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>This object represents parsed individual Authentication Result as specified by RFC 8601.  Technically speaking, each instance of the object corresponds to the parsed form of the <code>resinfo</code> term specified by the RFC.  It doesn't represent an entire header value, just an individual result for an individual authentication method.</p> <p>Certain verification methods return arrays of authentication results for you to act upon in your policy and/or add to incoming message as headers.</p> <p>The object has the following fields:</p> <ul> <li><code>method</code> - required string; the authentication method</li> <li><code>method_version</code> - optional integer; the version of the authentication method</li> <li><code>result</code> - required string; the result of the authentication method.</li> <li><code>reason</code> - optional string; an explanation of why the method produced that result</li> <li><code>props</code> - a table with string keys and values containing various     method-specific properties that describe additional information about this     result. For example, for DKIM results, this will often contain copies of     some of the DKIM signature fields in order to correlate a given result with     the appropriate DKIM signature header when multiple signatures are present. </li> </ul>"},{"location":"reference/authenticationresult/#example-obtaining-dkim-authentication-results","title":"Example: obtaining DKIM authentication results","text":"<p>This will verify the DKIM signatures that are present in the message and return an array of authentication results:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n-- Verify the dkim signature and return the results.\n-- Note that this example isn't making any policy decisions;\n-- it is only annotating the message with the results and\n-- allowing it to be relayed\nlocal verify = msg:dkim_verify()\nprint('dkim', kumo.json_encode_pretty(verify))\n-- Add the results to the message\nmsg:add_authentication_results(msg:get_meta 'hostname', verify)\nend)\n</code></pre> <p>might print something like this to the diagnostic log:</p> <pre><code>dkim    [\n  {\n    \"props\": {\n      \"header.d\": \"github.com\",\n      \"header.i\": \"@github.com\",\n      \"header.s\": \"pf2023\",\n      \"header.a\": \"rsa-sha256\",\n      \"header.b\": \"jo0EO4dX\"\n    },\n    \"result\": \"pass\",\n    \"method\": \"dkim\",\n    \"reason\": null,\n    \"method_version\": null\n  }\n]\n</code></pre>"},{"location":"reference/authenticationresult/#see-also","title":"See Also:","text":"<ul> <li>msg:add_authentication_results()</li> <li>msg:dkim_verify()</li> </ul>"},{"location":"reference/connectionmeta/","title":"Connection Metadata Object","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>This object represents a collection of metadata keys and values that are associated with an established incoming SMTP connection.</p> <p>KumoMTA populates a small number of predefined fields (see below), and allows your policy scripts the ability to read those values as well as write (and read!) additional values as needed by the local policy. For instance, you may decide to compute a value after EHLO has been processed by smtp_server_ehlo and access that value in a later SMTP event handler.</p> <p>Prior to calling smtp_server_message_received, KumoMTA will copy the values from the connection metadata and use those to populate the message metadata.</p> <p>The <code>get_meta</code> and <code>set_meta</code> methods shown below are used to read and write metadata values.</p>"},{"location":"reference/connectionmeta/#predefined-connection-metadata-values","title":"Predefined Connection Metadata Values","text":"<p>The following values are predefined by KumoMTA:</p> Scope Name Purpose Since Connection <code>reception_protocol</code> indicates the reception protocol, such as <code>ESMTP</code> (Since: Version 2023.08.22-4d895015) Connection <code>received_via</code> indicates the IP:port of the KumoMTA listener that is handling this session (Since: Version 2023.08.22-4d895015) Connection <code>received_from</code> indicates the IP:port of the sending or peer machine in this session (Since: Version 2023.08.22-4d895015) Connection <code>hostname</code> A copy of the effective value of the hostname set by kumo.start_esmtp_listener (Since: Version 2023.11.28-b5252a41) Connection <code>authn_id</code> the authentication id if the message was received via authenticated SMTP Connection <code>authz_id</code> the authorization id if the message was received via authenticated SMTP <p>Note</p> <p>Additional metadata is available at the Message scope, for a full list of all available metadata, see the Predefined Metadata page.</p>"},{"location":"reference/connectionmeta/#available-methods","title":"Available Methods","text":""},{"location":"reference/connectionmeta/#conn_metaget_metaname","title":"<code>conn_meta:get_meta(name)</code>","text":"<p>Returns the value associated with name, or <code>nil</code> if no such value has been defined. Values may be predefined by KumoMTA or may be set by policy scripts using <code>conn_meta:set_meta()</code>.</p>"},{"location":"reference/connectionmeta/#conn_metaset_metaname-value","title":"<code>conn_meta:set_meta(name, value)</code>","text":"<p>Sets the value associated with name to value.  Value must be serializable as JSON; it can be simple strings or numbers, but may also be an array or object value.</p>"},{"location":"reference/keysource/","title":"KeySource Object","text":"<p>KeySource objects are used in several places:</p> <ul> <li>Embedded into DKIM signer objects.</li> <li>The <code>tls_certificate</code> and <code>tls_key</code> fields of listeners.</li> <li>To hold credentials for SMTP AUTH.</li> <li>With the kumo.secrets.load function.</li> </ul>"},{"location":"reference/keysource/#acceptable-values","title":"Acceptable Values","text":"<p>KeySources pattern match from one of the following shapes:</p>"},{"location":"reference/keysource/#local-file","title":"Local File","text":"<p>When the value is a simple string value, it is interpreted as the path to a file from which the key will be loaded when needed:</p> <pre><code>local file_signer = kumo.dkim.rsa_sha256_signer {\nkey = '/path/to/file.pem',\n}\n</code></pre>"},{"location":"reference/keysource/#caller-provided-data","title":"Caller Provided Data","text":"<p>When the value is a table with the field <code>key_data</code>, the value of the <code>key_data</code> field will be used as the key data when needed:</p> <pre><code>local file_signer = kumo.dkim.rsa_sha256_signer {\nkey = {\n-- Doing literally this is probably unwise;\n-- see the example below for a more practical\n-- and manageable way to use this\nkey_data = '-----BEGIN RSA PRIVATE KEY----....',\n},\n}\n</code></pre> <p><code>key_data</code> exists to allow you to manage loading key data via some other lua function, for example, you could load your keys from a sqlite database:</p> <pre><code>function get_key(domain, selector)\nlocal db = sqlite:open '/opt/kumomta/etc/dkim/keys.db'\nlocal result = db:execute(\n'select data from keys where domain=? and selector=?',\ndomain,\nselector\n)\nreturn result[1]\nend\nlocal sqlite_signer = kumo.dkim.rsa_sha256_signer {\nkey = {\nkey_data = get_key(msg:from_header().domain, 'default'),\n},\n}\n</code></pre>"},{"location":"reference/keysource/#hashicorp-vault","title":"HashiCorp Vault","text":"<p>You may store and manage your keys in a HashiCorp Vault:</p> <pre><code>local vault_signer = kumo.dkim.rsa_sha256_signer {\nkey = {\nvault_mount = 'secret',\nvault_path = 'dkim/' .. msg:from_header().domain,\n-- Specify how to reach the vault; if you omit these,\n-- values will be read from $VAULT_ADDR and $VAULT_TOKEN\n-- Note that these environment vars must be accessible\n-- by the kumod user.  If using systemd, edit the systemd\n-- service file. [Look here](docs/tutorial/using_vault/) for more information\n-- vault_address = \"http://127.0.0.1:8200\"\n-- vault_token = \"hvs.TOKENTOKENTOKEN\"\n},\n}\n</code></pre> <p>The key must be stored as <code>key</code> under the <code>path</code> specified. For example, you might populate it like this:</p> <pre><code>$ vault kv put -mount=secret dkim/example.org key=@example-private-dkim-key.pem\n</code></pre>"},{"location":"reference/metadata/","title":"Predefined Metadata","text":"<p>KumoMTA provides the ability to set and retrieve metadata at both the connection and message level.</p> <p>By leveraging metadata, information can be made available to policy running at different phases in the life of a message, where the connection metadata is used for data that is shared in common with all messages injected over a given connection, and the message metadata is for all data related to a given individual message.</p> <p>There are get and set functions available for both connection and message metadata, and when a message is received all connection metadata is also copied into the message metadata, meaning that for retrieving connection metadata the user can opt to only access message metadata for any value that doesn't change over the life of the connection.</p> <p>The following metadata values are predefined by KumoMTA and are available to retrieve:</p> Scope Name Purpose Since Connection <code>reception_protocol</code> indicates the reception protocol, such as <code>ESMTP</code> (Since: Version 2023.08.22-4d895015) Connection <code>received_via</code> indicates the IP:port of the KumoMTA listener that is handling this session (Since: Version 2023.08.22-4d895015) Connection <code>received_from</code> indicates the IP:port of the sending or peer machine in this session (Since: Version 2023.08.22-4d895015) Connection <code>hostname</code> A copy of the effective value of the hostname set by kumo.start_esmtp_listener (Since: Version 2023.11.28-b5252a41) Connection <code>authn_id</code> the authentication id if the message was received via authenticated SMTP Connection <code>authz_id</code> the authorization id if the message was received via authenticated SMTP Message <code>queue</code> specify the name of the queue to which the message will be queued. Must be a string value. Message <code>tenant</code> specify the name/identifier of the tenant, if any. Must be a string value. Message <code>campaign</code> specify the name/identifier of the campaign. Must be a string value. Message <code>routing_domain</code> Overrides the domain of the recipient domain for routing purposes. (Since: Version 2023.08.22-4d895015)"},{"location":"reference/queues/","title":"Queues, Sources, Pools","text":"<p>Messages are assigned to a Scheduled Queue upon reception. The system can support arbitrarily named queues but the convention is to construct the queue name from some metadata associated with the message:</p> <ul> <li><code>tenant</code> - some kind of sender or customer identifier or identity derived   either from the message itself or authentication of the injection session.</li> <li><code>campaign</code> - a sender-provided label that can be used to logically group a set   of related messages, perhaps generated from the same campaign.</li> <li>destination domain - the site where the email will be routed</li> <li><code>routing_domain</code> - (Since: Version 2023.08.22-4d895015) overrides the destination domain   for routing purposes.</li> </ul> <p>These three pieces of information are combined to produce the name of the queue in the form <code>campaign:tenant@domain</code>. You don't need to explicitly assign a campaign or a tenant. The queue name will be formed based on what is set:</p> <code>tenant</code> set? <code>campaign</code> set? <code>routing_domain</code> set? Resulting queue name yes yes no <code>campaign:tenant@domain</code> yes yes yes <code>campaign:tenant@domain!routing_domain</code> yes no no <code>tenant@domain</code> yes no yes <code>tenant@domain!routing_domain</code> no yes no <code>campaign:@domain</code> no yes yes <code>campaign:@domain!routing_domain</code> no no no <code>domain</code> no no yes <code>domain!routing_domain</code> <p>At reception, in your smtp_server_message_received event, you have the opportunity to set <code>tenant</code> and <code>campaign</code> meta values, if desired. By default, the queue associated with the message will be formed from those values as described above.</p> <p>You may also explicitly set the queue meta value directly.</p> <p>This is useful in some special cases. For example, there is a special <code>null</code> queue that simply discards any messages assigned to it, which is useful when implementing a sink for testing purposes:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n-- Accept and discard all messages\nmsg:set_meta('queue', 'null')\nend)\n</code></pre>"},{"location":"reference/queues/#egress-sources-and-pools","title":"Egress Sources and Pools","text":"<p>Once assigned to a Scheduled Queue, the system will attempt to deliver it. The first stage is to resolve the configuration for the queue by triggering the get_queue_config event.</p> <p>One of the queue configuration parameters is the name of the Egress Pool which should be used when delivering messages.</p> <p>A pool is a group of Egress Sources. Each source can be associated with a local IP address or configured to use an alternative destination port (and in the future: use the HAProxy protocol) as the source of the outgoing traffic to the destination domain.</p> <pre><code>local SOURCES = {\n['ip-1'] = {\nsource_address = '10.0.0.1',\n},\n['ip-2'] = {\nsource_address = '10.0.0.2',\n},\n['ip-3'] = {\nsource_address = '10.0.0.3',\n},\n}\nlocal POOLS = {\n['pool1'] = {\n{ name = 'ip-1' },\n},\n['pool2'] = {\n{ name = 'ip-2', weight = 2 },\n-- we're warming up ip-3, so use it less frequently than ip-2\n{ name = 'ip-3', weight = 1 },\n},\n}\nlocal TENANT_TO_POOL = {\n['tenant-1'] = 'pool1',\n['tenant-2'] = 'pool2',\n['tenant-3'] = 'pool1',\n}\nkumo.on('get_egress_pool', function(pool_name)\nlocal pool = {\nname = pool_name,\nentries = POOLS[pool_name],\n}\nreturn kumo.make_egress_pool(pool)\nend)\nkumo.on('get_egress_source', function(source_name)\nlocal params = SOURCES[source_name]\nparams.name = source_name\nreturn kumo.make_egress_source(params)\nend)\nkumo.on(\n'get_queue_config',\nfunction(domain_name, tenant, campaign, routing_domain)\nreturn kumo.make_queue_config {\negress_pool = TENANT_TO_POOL[tenant],\n}\nend\n)\n</code></pre> <p>When a message in a given queue is ready for delivery, it will use the configured pool to set up an Egress Path for the message to reach its destination. It will pick a source using weighted round robin from the entries in the pool, and call your get_egress_path_config event to resolve options to control how it will do that.</p> <p>The parameters to that event are:</p> <ul> <li>domain - the destination domain name</li> <li>egress_source - the selected egress source</li> <li>site_name - a string deterministically derived from the MX record for domain.</li> </ul> <p>The site_name concept allows managing traffic more effectively for domains that have several or even a great many aliases. Rather than treating each domain as a separate destination, the traffic can be grouped together and managed more closely to how the receiving site sees it: as one source.</p> <p>With that in mind, the egress path is internally identified by the combination of the egress_source and the site_name.</p> <pre><code>-- Build a mapping from a domain name to the \"site name\"\n-- You'll likely want this to list the major domains for which there are\n-- several aliases. You only need populate entries for the big aliased\n-- domains; you needn't specify any of the aliases here.\nlocal SITE_OF = {}\nfor _, domain in ipairs { 'gmail.com', 'yahoo.com' } do\nSITE_OF[domain] = kumo.dns.lookup_mx(domain).site_name\nend\n-- SITE_OF is now equivalent to:\n-- local SITE_OF = {\n--   [\"gmail.com\"] = \"(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com\",\n--   [\"yahoo.com\"] = \"(mta5|mta6|mta7).am0.yahoodns.net\"\n-- }\n-- This table is keyed by either site name or domain name.\n-- Site names are looked up first, then domain names.\nlocal SHAPE_BY_DOMAIN = {\n[SITE_OF['gmail.com']] = {\n-- appropriate general configuration when communicating\n-- with any domain that shares gmail.com's MXs\nmax_connection_rate = '1000/hr',\n},\n['example.com'] = {\n-- appropriate general configuration when communicating\n-- specifically with example.com\nmax_connection_rate = '10/hr',\n},\n}\n-- This table is keyed by the tuple of (site_name, source) or (domain, source).\n-- Site names are looked up first, then domain names.\n-- Values override/overlay those in SHAPE_BY_DOMAIN.\nlocal SHAPE_BY_SOURCE = {\n[{ SITE_OF['gmail.com'], 'ip-1' }] = {\n-- appropriate configuration for your source when communicating\n-- with any domain that shares gmail.com's MXs\nmax_message_rate = '1000/hr',\n},\n}\nfunction merge_into(src, dest)\nfor k, v in pairs(src) do\ndest[k] = v\nend\nend\nkumo.on('get_egress_path_config', function(domain, egress_source, site_name)\n-- resolve parameters first based on the site, if any,\n-- then based on the domain, if any,\n-- otherwise use the system defaults\nlocal domain_params = SHAPE_BY_DOMAIN[site_name]\nor SHAPE_BY_DOMAIN[domain]\nor {}\nlocal source_params = SHAPE_BY_SOURCE[{ site_name, egress_source }]\nor SHAPE_BY_SOURCE[{ domain, egress_source }]\nor {}\n-- compose the source params over the domain params\nlocal params = {}\nmerge_into(domain_params, params)\nmerge_into(source_params, params)\nreturn kumo.make_egress_path(params)\nend)\n</code></pre>"},{"location":"reference/queues/#message-flow","title":"Message Flow","text":"<pre><code>graph TD\n   SQ[\"Scheduled Queue: campaign:tenant@domain.com\"]\n   SMTPL[\"ESMTP Listener\"]\n   HTTPI[\"Injection API\"]\n   RQ1[\"Ready Queue: 10.0.0.1-&gt;MX(domain.com)\"]\n   RQ2[\"Ready Queue: 10.0.0.2-&gt;MX(domain.com)\"]\n   POOL[\"egress pool\"]\n   IP1[\"Source: 10.0.0.1\"]\n   IP2[\"Source: 10.0.0.2\"]\n   MAINT[\"Queue Maintainer\"]\n   DESTSITE[\"domain.com\"]\n\n   SMTPL --&gt; SQ\n   HTTPI --&gt; SQ\n   SQ --&gt; MAINT\n   IP1 --&gt; POOL\n   IP2 --&gt; POOL\n   POOL -- per tenant:domain config --&gt; MAINT\n   MAINT -- throttle per tenant:domain config --&gt; RQ1\n   MAINT -- throttle per tenant:domain config --&gt; RQ2\n   RQ1 -- throttle per source:domain config\\nconnect via 10.0.0.1 --&gt; DESTSITE\n   RQ2 -- throttle per source:domain config\\nconnect via 10.0.0.2 --&gt; DESTSITE</code></pre>"},{"location":"reference/rapidoc/","title":"HTTP API Explorer","text":""},{"location":"reference/address/","title":"EnvelopeAddress object","text":"<p>Represents a sender or recipient of a message.</p> <p>Note that you can use <code>tostring(address)</code> to get the address as a string.</p>"},{"location":"reference/address/#available-fields","title":"Available Fields","text":"<ul> <li>domain</li> <li>email</li> <li>user</li> </ul>"},{"location":"reference/address/domain/","title":"<code>address.domain</code>","text":"<p>Returns the domain portion of the address. For example, if the address is <code>\"first.last@example.com\"</code>, <code>address.domain</code> will evaluate as <code>\"example.com\"</code>.</p> <p>See also address.user.</p>"},{"location":"reference/address/email/","title":"<code>address.email</code>","text":"<p>Returns the full user@domain version of the address. For example, if the address is <code>\"first.last@example.com\"</code>, <code>address.email</code> will evaluate as <code>\"first.last@example.com\"</code>.</p> <p>See also address.user.</p>"},{"location":"reference/address/user/","title":"<code>address.user</code>","text":"<p>Returns the mailbox portion of the address. For example, if the address is <code>\"first.last@example.com\"</code>, <code>address.user</code> will evaluate as <code>\"first.last\"</code>.</p> <p>See also address.domain.</p>"},{"location":"reference/addressheader/","title":"AddressHeader object","text":"<p>Represents the parsed form of an email header that holds email addresses, such as <code>\"From\"</code> and <code>\"To\"</code> headers.</p> <p>As these headers can contain lists of addresses and groups of addresses, care needs to be taken when processing them.</p> <p>Convenience accessors for the common case of a single address are provided, but they will raise an error when used on an address that is not a simple single address.</p> <p>The addressheader.list field can be used to safely operate on the parsed out set of addresses, regardless of how many are present.</p> <p>Note that you can use <code>tostring(address)</code> to get a JSON rendition of the parsed address information.</p>"},{"location":"reference/addressheader/#available-fields","title":"Available Fields","text":"<ul> <li>domain</li> <li>email</li> <li>list</li> <li>name</li> <li>user</li> </ul>"},{"location":"reference/addressheader/domain/","title":"<code>addressheader.domain</code>","text":"<p>If the address header consists of a single simple address, returns the domain portion of the address. For example, if the address is <code>\"first.last@example.com\"</code>, <code>addressheader.domain</code> will evaluate as <code>\"example.com\"</code>.</p> <p>If the address header is not a single simple address, raises an error.</p> <p>See also addressheader.user, addressheader.name.</p>"},{"location":"reference/addressheader/email/","title":"<code>addressheader.email</code>","text":"<p>If the address header consists of a single simple address, returns the email address portion of the address. For example, if the address is <code>\"John Smith &lt;first.last@example.com&gt;</code>, <code>addressheader.email</code> will evaluate as <code>first.last@example.com</code>.</p> <p>If the address header is not a single simple address, raises an error.</p> <p>If the address header is a single simple address, but has no email address, returns <code>nil</code>.</p>"},{"location":"reference/addressheader/list/","title":"<code>addressheader.list</code>","text":"<p>Returns a lua table consisting of one entry per address in the header. Each entry is a single simple address object that has <code>domain</code>, <code>user</code>, <code>email</code> and <code>name</code> fields with the same semantics as <code>addressheader</code>.</p> <pre><code>for _, address in ipairs(msg:to_header().list) do\nprint('to entry', address)\n-- prints something like:\n-- to entry      {\"name\":null,\"address\":\"user@example.com\"}\n-- to entry      {\"name\":\"John Smith\",\"address\":\"john.smith@example.com\"}\nend\n</code></pre>"},{"location":"reference/addressheader/name/","title":"<code>addressheader.name</code>","text":"<p>If the address header consists of a single simple address, returns the display name portion of the address. For example, if the address is <code>\"John Smith &lt;first.last@example.com&gt;</code>, <code>addressheader.name</code> will evaluate as <code>\"John Smith\"</code>.</p> <p>If the address header is not a single simple address, raises an error.</p> <p>If the address header is a single simple address, but has no display name, returns <code>nil</code>.</p> <p>See also addressheader.user, addressheader.domain.</p>"},{"location":"reference/addressheader/user/","title":"<code>addressheader.user</code>","text":"<p>If the address header consists of a single simple address, returns the mailbox portion of the address. For example, if the address is <code>\"first.last@example.com\"</code>, <code>addressheader.domain</code> will evaluate as <code>\"first.last\"</code>.</p> <p>If the address header is not a single simple address, raises an error.</p> <p>See also addressheader.domain, addressheader.name.</p>"},{"location":"reference/events/","title":"Events","text":"<p>This section lists the events that are possible to bind to using kumo.on.</p> <ul> <li>get_egress_path_config</li> <li>get_egress_pool</li> <li>get_egress_source</li> <li>get_listener_domain</li> <li>get_queue_config</li> <li>http_message_generated</li> <li>http_server_validate_auth_basic</li> <li>init</li> <li>pre_init</li> <li>should_enqueue_log_record</li> <li>smtp_client_rewrite_delivery_status</li> <li>smtp_server_auth_plain</li> <li>smtp_server_ehlo</li> <li>smtp_server_mail_from</li> <li>smtp_server_message_received</li> <li>smtp_server_rcpt_to</li> <li>spool_message_enumerated</li> <li>tsa_init</li> <li>tsa_load_shaping_data</li> </ul>"},{"location":"reference/events/get_egress_path_config/","title":"<code>kumo.on('get_egress_path_config', function(domain, egress_source, site_name))</code>","text":"<p>Note</p> <p>This event handler is in flux and may change significantly</p> <p>Not the final form of this API, but this is currently how we retrieve configuration used when making outbound connections</p> <p>The <code>routing_domain</code> parameter corresponds to the effective <code>routing_domain</code> of the originating scheduled queue.  This will be the same as the recipient domain unless the message had set the <code>routing_domain</code> meta value.</p> <pre><code>kumo.on(\n'get_egress_path_config',\nfunction(routing_domain, egress_source, site_name)\nreturn kumo.make_egress_path {\nenable_tls = 'OpportunisticInsecure',\n}\nend\n)\n</code></pre> <p>See also kumo.make_egress_path.</p>"},{"location":"reference/events/get_egress_pool/","title":"<code>kumo.on('get_egress_pool', function(pool_name))</code>","text":"<pre><code>kumo.on('get_egress_pool', function(pool_name)\nreturn kumo.make_egress_pool {\nname = pool_name,\nentries = {\n{ name = 'ip-1' },\n},\n}\nend)\n</code></pre> <p>See also kumo.make_egress_source.</p>"},{"location":"reference/events/get_egress_source/","title":"<code>kumo.on('get_egress_source', function(source_name))</code>","text":"<pre><code>kumo.on('get_egress_source', function(source_name)\nreturn kumo.make_egress_source {\nname = source_name,\n-- other fields here\n}\nend)\n</code></pre> <p>See also kumo.make_egress_source.</p>"},{"location":"reference/events/get_listener_domain/","title":"<code>kumo.on('get_listener_domain', function(domain, listener, conn_meta))</code>","text":"<p>This event is triggered by the SMTP server to retrieve information about either a source or destination domain to help determine whether the message should be accepted/logged/relayed.</p> <p>The listener parameter is the listener endpoint on which the message is being delivered.  You can use this to vary behavior depending on the listener address.</p> <p>When the SMTP <code>RCPT TO</code> command is issued by the client, the destination domain is passed as the domain parameter to this event.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The conn_meta parameter represents the connection metadata and can be used to share state between the various SMTP listener event handlers. See Connection Metadata for more information.</p> <p>The event is expected to return a listener-domain object constructed by a call to kumo.make_listener_domain, or a <code>nil</code> value to indicate that there is no explicit configuration.</p> <p>If none of <code>log_relay</code>, <code>log_oob</code> or <code>log_arf</code> are set to true, in the returned listener-domain object, then the <code>RCPT TO</code> command is rejected.</p> <p>Once the <code>DATA</code> stage has transmitted the message content, and after the smtp_server_message_received event has been processed, and the reception logged (which is where OOB and FBL data is parsed and logged), the recipient domain is passed to this event as the domain parmater. If <code>relay_to</code> is <code>false</code> in the returned listener-domain object, then the message will not be spooled and that will be the end of its processing.</p> <p>See kumo.make_listener_domain for some more examples.</p>"},{"location":"reference/events/get_queue_config/","title":"<code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain))</code>","text":"<p>Note</p> <p>This event handler is in flux and may change significantly</p> <p>Not the final form of this API, but this is currently how we retrieve configuration used for managing a queue.</p> <p>The parameters correspond to the <code>domain</code>, <code>tenant</code>, <code>campaign</code> and <code>routing_domain</code> fields from the scheduled queue name, as discussed in Queues.</p> <pre><code>kumo.on(\n'get_queue_config',\nfunction(domain_name, tenant, campaign, routing_domain)\nreturn kumo.make_queue_config {\nmax_retry_interval = '20 minutes',\n}\nend\n)\n</code></pre> <p>See also kumo.make_queue_config.</p> <p>Since: Version 2023.11.28-b5252a41</p> <p>The functionality described in this outlined box requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>It is now possible to use <code>kumo.on</code> to register multiple handlers for this event.  The handlers will be called in the order that they were registered.  If a handler returns <code>nil</code> then the next handler will be called. Conversely, if a handler returns a queue configuration object, no further handlers will be called.</p> <p>This behavior is intended to make it easier to compose multiple helpers or lua modules together.</p>"},{"location":"reference/events/http_message_generated/","title":"<code>kumo.on('http_message_generated', function(message))</code>","text":"<p>Called by the HTTP injection API endpoint after generating a message, but prior to injecting it into the queue.</p> <p>The event handler will be passed a Message object.</p> <p>The HTTP injector does not add a <code>Received</code> header, but it will pre-set the following meta values in the message:</p> <ul> <li><code>\"http_auth\"</code> - will hold either the authenticated username or the peer IP   address that satisfied the authentication check for the endpoint.</li> </ul> <p>This event is the best place to carry out a number of important policy decisions:</p> <ul> <li>DKIM signing via message:dkim_sign.</li> <li>Assigning the <code>\"campaign\"</code>, <code>\"tenant\"</code> and/or <code>\"queue\"</code> meta values via msg:set_meta</li> </ul> <p>You may use kumo.reject to raise an error to prevent this message from being queued for delivery.</p> <pre><code>kumo.on('http_message_generated', function(msg)\nlocal signer = kumo.dkim.rsa_sha256_signer {\ndomain = msg:from_header().domain,\nselector = 'default',\nheaders = { 'From', 'To', 'Subject' },\nkey = 'example-private-dkim-key.pem',\n}\nmsg:dkim_sign(signer)\nend)\n</code></pre>"},{"location":"reference/events/http_server_validate_auth_basic/","title":"<code>kumo.on('http_server_validate_auth_basic', function(USER, PASSWORD))</code>","text":"<p>Called by the HTTP listener to validate HTTP Basic authentication credentials provided by the client.</p> <p>At the time of writing KumoMTA doesn't provide a general authentication solution, but through the use of this callback, you have some flexibility.</p> <p>The event handler receives the username and password provided by the client. Note that the password may be empty or missing if the client provided only a user name.</p> <p>The HTTP server expects the event handler to return a bool value; if it returns <code>true</code> then it considers the credentials to be valid and will allow the client to access the endpoint. If it returns <code>false</code> then it will consider the credentials to be invalid and return a authorization error. Other return values, or raising an error, will return an error status to the client.</p> <p>This example shows how to implement a very simple inline password database using a lua table:</p> <pre><code>-- Use this to lookup and confirm a user/password credential\n-- used with the http endpoint\nkumo.on('http_server_validate_auth_basic', function(user, password)\nlocal password_database = {\n['scott'] = 'tiger',\n}\nif password == '' then\nreturn false\nend\nreturn password_database[user] == password\nend)\n</code></pre>"},{"location":"reference/events/http_server_validate_auth_basic/#reasoning-about-the-authorized-identity","title":"Reasoning about the authorized identity","text":"<p>When using auth to grant access to the HTTP injection API, the authorization identity will be made available in the generated message by setting the <code>http_auth</code> meta key.  It can have one of the following values:</p> <ul> <li>When HTTP Basic auth is used (and validated via the   <code>http_server_validate_auth_basic</code> event), it will be set to the provided   username</li> <li>When no HTTP auth is used, access is granted based on the   trusted_hosts. In this case,   <code>http_auth</code> will be set to the peer address that matched the <code>trusted_hosts</code></li> </ul> <p>If you wish to enforce or restrict some capability based on identity, you might use logic along the lines of:</p> <pre><code>kumo.on('http_message_generated', function(msg)\nlocal auth = msg:get_meta 'http_auth'\nif auth ~= 'some.one' then\nerror 'only some.one is allowed to inject'\nend\nend)\n</code></pre>"},{"location":"reference/events/init/","title":"<code>kumo.on('init', FUNCTION)</code>","text":"<p>The <code>init</code> event is triggered once when the <code>kumod</code> process initializes. The intent is that you use this event to define the spool storage and listeners for your environment.</p> <p>The event handler is not passed any parameters, and does not expect any particular return value.</p> <pre><code>-- Called on startup to initialize the system\nkumo.on('init', function()\n-- Define a listener.\n-- Can be used multiple times with different parameters to\n-- define multiple listeners!\nkumo.start_esmtp_listener {\nlisten = '0.0.0.0:2025',\n}\nkumo.configure_local_logs {\nlog_dir = '/var/tmp/kumo-logs',\n}\nkumo.start_http_listener {\nlisten = '0.0.0.0:8000',\n-- allowed to access any http endpoint without additional auth\ntrusted_hosts = { '127.0.0.1', '::1' },\n}\nkumo.define_spool {\nname = 'data',\npath = '/var/tmp/kumo-spool/data',\n}\nkumo.define_spool {\nname = 'meta',\npath = '/var/tmp/kumo-spool/meta',\n}\nend)\n</code></pre>"},{"location":"reference/events/pre_init/","title":"<code>kumo.on('pre_init', FUNCTION)</code>","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>The <code>pre_init</code> event is triggered once when the <code>kumod</code> process initializes, prior to triggering the init event.</p> <p><code>pre_init</code> can be registered multiple times.</p> <p>The intended purpose of this event is to be used by lua helper modules to aid in building up optional modular functionality.</p>"},{"location":"reference/events/should_enqueue_log_record/","title":"<code>kumo.on('should_enqueue_log_record', function(message, hook_name))</code>","text":"<p>This event is triggered when kumo.configure_log_hook has been used to enable it.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The hook_name parameter was added. It corresponds to the name field that was passed to <code>kumo.configure_log_hook</code> and is present to allow you to decide whether a given message should get queued for a given hook instance.</p> <p>When enabled, each log record will generate a new Message object with the following attributes:</p> <ul> <li>Sender will be set to the sender of the originating message</li> <li>Recipient will be set to the recipient of the originating message</li> <li>the <code>log_record</code> meta value will be set to the   Log Record that is being logged</li> <li>The message body/data will be set to the textual representation of the log   record. By default this will be the JSON serialization of the log record, but   if you have enabled templating using the <code>per_record</code> parameter to   kumo.configure_log_hook then it will be   whatever your template evaluated to for that record.</li> <li>The <code>reception_protocol</code> meta value will be set to <code>\"LogRecord\"</code></li> </ul> <p>That log message is passed to the <code>should_enqueue_log_record</code> hook, which must return a boolean value that indicates whether the log message should be queued and acted upon (return true), or whether the log message should be discarded.</p> <pre><code>kumo.on('should_enqueue_log_record', function(msg, hook_name)\nlocal log_record = msg:get_meta 'log_record'\n-- avoid an infinite loop caused by logging that we logged that we logged...\n-- Check the log record: if the record was destined for the webhook queue\n-- then it was a record of the webhook delivery attempt and we must not\n-- log its outcome via the webhook.\nif log_record.queue ~= 'webhook' then\n-- was some other event that we want to log via the webhook\nmsg:set_meta('queue', 'webhook')\nreturn true\nend\nreturn false\nend)\n-- This is a user-defined event that matches up to the custom_lua\n-- constructor used in `get_queue_config` below.\n-- It returns a lua connection object that can be used to \"send\"\n-- messages to their destination.\nkumo.on('make.webhook', function(domain, tenant, campaign)\nlocal connection = {}\nlocal client = kumo.http.build_client {}\nfunction connection:send(message)\nlocal response = client\n:post(string.format('http://127.0.0.1:%d/log', WEBHOOK_PORT))\n:header('Content-Type', 'application/json')\n:body(message:get_data())\n:send()\nlocal disposition = string.format(\n'%d %s: %s',\nresponse:status_code(),\nresponse:status_reason(),\nresponse:text()\n)\nif response:status_is_success() then\nreturn disposition\nend\n-- Signal that the webhook request failed.\n-- In this case the 500 status prevents us from retrying\n-- the webhook call again, but you could be more sophisticated\n-- and analyze the disposition to determine if retrying it\n-- would be useful and generate a 400 status instead.\n-- In that case, the message we be retryed later, until\n-- it reached it expiration.\nkumo.reject(500, disposition)\nend\nreturn connection\nend)\nkumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nif domain == 'webhook' then\n-- Use the `make.webhook` event to handle delivery\n-- of webhook log records\nreturn kumo.make_queue_config {\nprotocol = {\ncustom_lua = {\nconstructor = 'make.webhook',\n},\n},\n}\nend\nreturn kumo.make_queue_config {}\nend)\n</code></pre> <p>Since: Version 2023.11.28-b5252a41</p> <p>The functionality described in this outlined box requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>It is now possible to use <code>kumo.on</code> to register multiple handlers for this event.  The handlers will be called in the order that they were registered.  If a handler returns <code>nil</code> then the next handler will be called. Conversely, if a handler returns either <code>true</code> or <code>false</code>, its return value is taken as the definitive outcome and no further handlers will be called.</p> <p>This behavior is intended to make it easier to compose multiple helpers or lua modules together.</p>"},{"location":"reference/events/smtp_client_rewrite_delivery_status/","title":"<code>kumo.on('smtp_client_rewrite_delivery_status', function(response, domain, tenant, campaign, routing_domain))</code>","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>This event is triggered by the SMTP client if a message is rejected by a destination SMTP server.</p> <p>Rejected means one of:</p> <ul> <li><code>MAIL FROM</code> or <code>RCPT TO</code> got a non-2xx response</li> <li><code>DATA</code> got a non-354 response</li> <li>The final <code>CRLF.CRLF</code> got a non-250 response</li> </ul> <p>In that circumstance, the SMTP response is formatted into a single line (replacing CRLF with the literal <code>\\r\\n</code> sequence) and the queue name parameters are extracted in order to call the <code>smtp_client_rewrite_delivery_status</code> event.</p> <p>The purpose of the event is to enable you to make a policy decision to optionally rewrite the status code.  For example, you may wish to treat a full mailbox as a permanent failure if the nature of the message is some kind of bulk notification that won't be missed.</p> <p>The event can return the its own version of the SMTP status code which will be used when considering what to do with the message.</p> <p>For instance, if the event returns a 500 code when the original code was a 400 code, the message will be logged as a <code>Bounce</code> and then removed from the spool.</p> <p>If the event returns <code>null</code>, or the same value as the original response, then the message is processed as normal.</p> <p>Otherwise, the response string will have <code>(kumomta: status was rewritten from 400 -&gt; 500)</code> appended to it, so that it is clear from the logs that a rewrite occurred.</p> <p>This example shows how to build up a mapping table from a json file with contents like this:</p> <pre><code>{\n\"4\\\\.2\\\\.1 &lt;.+&gt;: Recipient address rejected: this mailbox is inactive and has been disabled\": 500,\n\"4\\\\.2\\\\.2 The email account that you tried to reach is over quota\\\\.\": 500\n}\n</code></pre> <pre><code>-- Compile a classifier from the json file; refresh it it every 5 minutes\nlocal get_dsn_classifier = kumo.memoize(function()\nlocal data = kumo.json_load '/tmp/dsn_rewrite.json'\nreturn kumo.regex_set_map.new(data)\nend, {\nname = 'dsn_rewrite',\nttl = '5 minutes',\ncapacity = 1,\n})\n-- This example ignores the queue name parameters, but you could get more\n-- sophisticated and use those to define rules on a per-domain/tenant/campaign basis\n-- if required\nkumo.on(\n'smtp_client_rewrite_delivery_status',\nfunction(response, domain, tenant, campaign, routing_domain)\nlocal map = get_dsn_classifier()\n-- Match the classifier against the response.\n-- This will return the rewritten code if any, or null otherwise.\n-- We can simply return the result of the lookup directly.\nreturn map[response]\nend\n)\n</code></pre> <p>See also:</p> <ul> <li>kumo.memoize</li> <li>kumo.regex_set_map.new</li> </ul>"},{"location":"reference/events/smtp_server_auth_plain/","title":"<code>kumo.on('smtp_server_auth_plain', function(authz, authc, password, conn_meta))</code>","text":"<p>Called by the ESMTP server in response to the client issuing an <code>\"AUTH PLAIN\"</code> authentication attempt.</p> <p>KumoMTA will only allow <code>AUTH PLAIN</code> once STARTTLS has been successfully enabled for the session.</p> <p>At the time of writing KumoMTA doesn't provide a general authentication solution, but through the use of this callback, you have some flexibility.</p> <p>The event handler receives the following parameters:</p> <ul> <li>authz - the authorization identity which the client wishes to act as</li> <li>authc - the authentication identity which identifies the client for the   purposes of validating who the client claims to be.  authc is paired   with the password parameter.</li> <li>password - the password which belongs to the claimed authc</li> <li>conn_meta - represents the connection metadata and     can be used to share state between the various SMTP listener     event handlers. See Connection Metadata     for more information.</li> </ul> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The conn_metadata parameter is new as of this release.</p> <p>Note that PLAIN SASL allows for authz to be empty.  KumoMTA will assume the same value as authc in that case, so this event will always be triggered with that value.</p> <p>The SMTP server expects the event handler to return a bool value; if it returns true then it considers the credentials to be valid and will associated the claimed identities with the session, and yield an SMTP <code>235</code> successful authentication response to the client.  The authz and authc parameters will be set in the message meta object as <code>\"authz_id\"</code> and <code>\"authn_id\"</code> respectively.</p> <p>If it returns false then the authentication attempt is considered to have failed and will yield an SMTP <code>535</code> failed authentication response to the client.</p> <p>This example shows how to implement a very simple inline password database using a lua table:</p> <pre><code>-- Use this to lookup and confirm a user/password credential\nkumo.on('smtp_server_auth_plain', function(authz, authc, password, conn_meta)\nlocal password_database = {\n['scott'] = 'tiger',\n}\nif password == '' then\nreturn false\nend\nreturn password_database[authc] == password\nend)\n</code></pre>"},{"location":"reference/events/smtp_server_ehlo/","title":"<code>kumo.on('smtp_server_ehlo', function(domain, conn_meta))</code>","text":"<p>Called by the ESMTP server in response to the client issuing either a <code>\"HELO\"</code> or <code>\"EHLO\"</code> command.  The event handler is passed the domain parameter from the <code>HELO/EHLO</code> command.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The conn_meta parameter represents the connection metadata and can be used to share state between the various SMTP listener event handlers. See Connection Metadata for more information.</p> <p>You may choose to reject the connection via kumo.reject.</p> <pre><code>-- Called to validate the helo and/or ehlo domain\nkumo.on('smtp_server_ehlo', function(domain)\n-- Use kumo.reject to return an error to the EHLO command\nif domain == 'bad.actor' then\nkumo.reject(420, 'go away')\nend\nend)\n</code></pre>"},{"location":"reference/events/smtp_server_mail_from/","title":"<code>kumo.on('smtp_server_mail_from', function(sender, conn_meta))</code>","text":"<p>Called by the ESMTP server in response to the client issuing a <code>\"MAIL FROM\"</code> command.  The event handler is passed the sender address parameter from the <code>MAIL FROM</code> command.</p> <p>The sender address is an EnvelopeAddress object.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The conn_meta parameter represents the connection metadata and can be used to share state between the various SMTP listener event handlers. See Connection Metadata for more information.</p> <p>You may choose to reject the connection via kumo.reject.</p> <pre><code>kumo.on('smtp_server_mail_from', function(sender)\nif sender.domain == 'bad.domain' then\nkumo.reject(420, 'not thanks')\nend\nend)\n</code></pre>"},{"location":"reference/events/smtp_server_message_received/","title":"<code>kumo.on('smtp_server_message_received', function(message, conn_meta))</code>","text":"<p>Called by the ESMTP server after receiving the message data.</p> <p>If the client issued multiple <code>\"RCPT TO\"</code> commands in the same transaction, each one will result in a separate message being created, and this event will be triggered for each of them.</p> <p>The event handler will be passed a Message object. The Message will always have a <code>Received</code> header prepended that captures trace information about the sender.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The conn_meta parameter represents the connection metadata and can be used to share state between the various SMTP listener event handlers. See Connection Metadata for more information.</p> <p>This event is the best place to carry out a number of important policy decisions:</p> <ul> <li>DKIM signing via message:dkim_sign.</li> <li>Assigning the <code>\"campaign\"</code>, <code>\"tenant\"</code> and/or <code>\"queue\"</code> meta values via msg:set_meta</li> </ul> <pre><code>-- Called once the body has been received.\n-- For multi-recipient mail, this is called for each recipient.\nkumo.on('smtp_server_message_received', function(msg)\nlocal signer = kumo.dkim.rsa_sha256_signer {\ndomain = msg:from_header().domain,\nselector = 'default',\nheaders = { 'From', 'To', 'Subject' },\nkey = 'example-private-dkim-key.pem',\n}\nmsg:dkim_sign(signer)\nend)\n</code></pre>"},{"location":"reference/events/smtp_server_rcpt_to/","title":"<code>kumo.on('smtp_server_rcpt_to', function(recipient, conn_meta))</code>","text":"<p>Called by the ESMTP server in response to the client issuing a <code>\"RCPT TO\"</code> command.  The event handler is passed the recipient address parameter from the <code>RCPT TO</code> command.</p> <p>The recipient address is an EnvelopeAddress object.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The conn_meta parameter represents the connection metadata and can be used to share state between the various SMTP listener event handlers. See Connection Metadata for more information.</p> <p>You may choose to reject the connection via kumo.reject.</p> <pre><code>kumo.on('smtp_server_rcpt_to', function(recipient)\nif recipient.domain == 'bad.domain' then\nkumo.reject(420, 'not thanks')\nend\nend)\n</code></pre>"},{"location":"reference/events/spool_message_enumerated/","title":"<code>kumo.on('spool_message_enumerated', function(message))</code>","text":"<p>Called by the spool layer during spool enumeration during server startup.</p> <p>When kumod starts, after the <code>init</code> event has triggered, the spool subsystem begins enumeration of messages to build up the queues.</p> <p>For each message discovered in the spool, the <code>spool_message_enumerated</code> event will fire prior to inserting the message into a queue.</p> <p>This event gives the operator the ability to handle situations such as the removal of a queues/paths/sources by allowing you to re-assign the queue meta value to place the message into a different queue from that the one that was selected during the original reception of the message.</p> <p>Errors raised during the evaluation of this hook will prevent the server from completing startup.</p>"},{"location":"reference/events/tsa_init/","title":"<code>kumo.on('tsa_init', FUNCTION)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The <code>tsa_init</code> event is triggered once when the <code>tsa-daemon</code> process initializes. The intent is that you use this event to define the database storage location and listeners for your environment.</p> <p>The event handler is not passed any parameters, and does not expect any particular return value.</p> <pre><code>local tsa = require 'tsa'\nlocal kumo = require 'kumo'\n-- Called on startup to initialize the system\nkumo.on('tsa_init', function()\n-- This is the default, so you needn't specify this.\n-- But if you wanted to change the path, you must do it\n-- before you start the listener\ntsa.configure_tsa_db_path '/var/spool/kumomta/tsa.db'\ntsa.start_http_listener {\nlisten = '0.0.0.0:8008',\n-- allowed to access any http endpoint without additional auth\n-- You will likely want to include your LAN CIDR here if\n-- you are running multiple nodes\ntrusted_hosts = { '127.0.0.1', '::1' },\n}\nend)\n</code></pre>"},{"location":"reference/events/tsa_load_shaping_data/","title":"<code>kumo.on('tsa_load_shaping_data', FUNCTION)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Called by the <code>tsa-daemon</code> whenever it is going to evaluate a newly received log record.</p> <p>The event must return a <code>Shaping</code> object, as can be obtained via kumo.shaping.load.</p> <p>It is recommended that you use the same list of filenames that you would use with the shaping helper so that the two services have a consensus on the shaping configuration.</p> <p><code>tsa-daemon</code> is only really concerned with automation rules defined by the shaping configuration.</p> <pre><code>local tsa = require 'tsa'\nlocal kumo = require 'kumo'\nkumo.on('tsa_init', function()\ntsa.start_http_listener {\nlisten = '0.0.0.0:8008',\ntrusted_hosts = { '127.0.0.1', '::1' },\n}\nend)\nlocal cached_load_shaping_data = kumo.memoize(kumo.shaping.load, {\nname = 'tsa_load_shaping_data',\nttl = '5 minutes',\ncapacity = 4,\n})\nkumo.on('tsa_load_shaping_data', function()\nlocal shaping = cached_load_shaping_data {\n-- This is the default file used by the shaping helper\n-- in KumoMTA, which references the community shaping rules\n'/opt/kumomta/share/policy-extras/shaping.toml',\n-- and maybe you have your own rules\n'/opt/kumomta/policy/shaping.toml',\n}\nreturn shaping\nend)\n</code></pre>"},{"location":"reference/http/","title":"HTTP API","text":"<p>HTTP service is configured via kumo.start_http_listener.</p>"},{"location":"reference/http/#authentication","title":"Authentication","text":"<p>All HTTP endpoints require that the client satisfy one of the follow conditions:</p> <ul> <li>Trusted IP - Connecting from a host covered by the   trusted_hosts defined for the   HTTP listener</li> <li>Authenticated - Provide HTTP Basic authentication credentials that are   validated successfully by the   http_server_validate_auth_basic   event handler</li> </ul>"},{"location":"reference/http/#endpoints","title":"Endpoints","text":"<p>The following endpoints are available:</p> <ul> <li><code>DELETE /api/admin/bounce/v1</code></li> <li><code>GET /api/admin/bounce/v1</code></li> <li><code>POST /api/admin/bounce/v1</code></li> <li><code>POST /api/admin/set_diagnostic_log_filter/v1</code></li> <li><code>POST /api/inject/v1</code></li> <li><code>GET /metrics.json</code></li> <li><code>GET /metrics</code></li> </ul>"},{"location":"reference/http/api_admin_bounce_cancel_v1/","title":"<code>DELETE /api/admin/bounce/v1</code>","text":"<p>Making a DELETE request to this endpoint allows the system operator to delete an administrative bounce entry by its id.</p> <p>The body of the request must have the following form:</p> <pre><code>{\n\"id\": \"169c3dc0-6518-41ef-bfbb-1f0ae426cb32\"\n}\n</code></pre> <p>If the id is invalid (or not longer active), then a <code>404</code> status will be returned.</p>"},{"location":"reference/http/api_admin_bounce_cancel_v1/#kumo-cli","title":"Kumo CLI","text":"<p>In addition to making raw API requests, you may use the kumo CLI:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 bounce-cancel --id 169c3dc0-6518-41ef-bfbb-1f0ae426cb32\nremoved 0234c7c9-afd3-49f9-9a4c-a1cc37fcc53b\n</code></pre> <p>Run <code>kcli bounce-cancel --help</code> for more informtion.</p>"},{"location":"reference/http/api_admin_bounce_list_v1/","title":"<code>GET /api/admin/bounce/v1</code>","text":"<p>Making a GET request to this endpoint allows the system operator to list all currently active administrative bounces that have been configured.</p> <p>The response is a json structure with the following format:</p> <pre><code>[\n{\n\"id\": \"169c3dc0-6518-41ef-bfbb-1f0ae426cb32\",\n\"campaign\": null,\n\"tenant\": null,\n\"domain\": null,\n\"reason\": \"purge\",\n\"duration\": \"4m 50s 207ms 320us 231ns\",\n\"bounced\": {\n\"wezfurlong.org\": 1\n},\n\"total_bounced\": 1\n}\n]\n</code></pre> <p>Each entry of the array shows the bounce entry and its matching criteria, along with an <code>id</code> that can be used to cancel the entry, the map of queue name to the number of bounced messages and the overall number of bounced messages.</p> <p>The remaining duration of the entry is also included.</p>"},{"location":"reference/http/api_admin_bounce_list_v1/#kumo-cli","title":"Kumo CLI","text":"<p>In addition to making raw API requests, you may use the kumo CLI:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 bounce-list\n[\n  {\n    \"id\": \"169c3dc0-6518-41ef-bfbb-1f0ae426cb32\",\n    \"campaign\": null,\n    \"tenant\": null,\n    \"domain\": null,\n    \"reason\": \"purge\",\n    \"duration\": \"4m 50s 207ms 320us 231ns\",\n    \"bounced\": {\n      \"wezfurlong.org\": 1\n    },\n    \"total_bounced\": 1\n  }\n]\n</code></pre> <p>Run <code>kcli bounce-list --help</code> for more informtion.</p>"},{"location":"reference/http/api_admin_bounce_v1/","title":"<code>POST /api/admin/bounce/v1</code>","text":"<p>Making a POST request to this endpoint allows the system operator to administratively bounce messages that match certain criteria, or if no criteria are provided, ALL messages.</p> <p>Danger</p> <p>There is no way to undo the actions carried out by this request!</p> <p>The body of the post request must be a JSON object; here's an example:</p> <pre><code>{\n\"domain\": \"gmail.com\",\n\"reason\": \"no time to explain!11!\"\n}\n</code></pre> <p>and the response will look something like this, with an entry for each matching queue name and the count of matching messages that were bounced:</p> <pre><code>{\"bounced\":{\"gmail.com\":42}, \"total_bounced\":42}\n</code></pre> <p>The following fields are possible in the request:</p>"},{"location":"reference/http/api_admin_bounce_v1/#domain","title":"domain","text":"<p>Optional string. The domain name to match. If omitted, any domain will match.</p>"},{"location":"reference/http/api_admin_bounce_v1/#routing_domain","title":"routing_domain","text":"<p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Optional string. The routing_domain name to match. If omitted, any routing_domain will match.</p>"},{"location":"reference/http/api_admin_bounce_v1/#campaign","title":"campaign","text":"<p>Optional string. The campaign name to match. If omitted, any campaign will match.</p>"},{"location":"reference/http/api_admin_bounce_v1/#tenant","title":"tenant","text":"<p>Optional string. The tenant to match. If omitted, any tenant will match.</p> <p>Danger</p> <p>If you specify none of <code>domain</code>, <code>campaign</code> or <code>tenant</code>, then ALL queues will be bounced.</p> <p>With great power, comes great responsibility!</p>"},{"location":"reference/http/api_admin_bounce_v1/#reason","title":"reason","text":"<p>Required. Reason to log in the delivery log.</p>"},{"location":"reference/http/api_admin_bounce_v1/#duration","title":"duration","text":"<p>Optional duration string. Defaults to <code>\"5m\"</code>. Specifies how long this bounce directive remains active.</p> <p>While active, newly injected messages that match the bounce criteria will also be bounced.</p>"},{"location":"reference/http/api_admin_bounce_v1/#kumo-cli","title":"Kumo CLI","text":"<p>In addition to making raw API requests, you may use the kumo CLI:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 bounce --everything --reason purge\n{\n  \"id\": \"0234c7c9-afd3-49f9-9a4c-a1cc37fcc53b\",\n  \"bounced\": {},\n  \"total_bounced\": 0\n}\n</code></pre> <p>Run <code>kcli bounce --help</code> for more informtion.</p>"},{"location":"reference/http/api_admin_set_diagnostic_log_filter_v1/","title":"<code>POST /api/admin/set_diagnostic_log_filter/v1</code>","text":"<p>Changes the diagnostic log filter dynamically.</p> <pre><code>$ curl -i 'http://localhost:8000/api/admin/set_diagnostic_log_filter/v1' \\\n-H 'Content-Type: application/json' \\\n-d '{\"filter\":\"kumod=trace\"}'\n</code></pre> <p>The above is equivalent to:</p> <pre><code>kumo.set_diagnostic_log_filter 'kumod=trace'\n</code></pre> <p>except that an administrator can execute this ad-hoc to dynamically adjust the log filtering.</p> <p>See kumo.set_diagnostic_log_filter for more information about diagnostic log filters.</p> <p>The body of the post request must be a JSON object with a <code>filter</code> field:</p> <pre><code>{\n\"filter\": \"kumod=trace\"\n}\n</code></pre>"},{"location":"reference/http/api_admin_set_diagnostic_log_filter_v1/#kumo-cli","title":"Kumo CLI","text":"<p>In addition to making raw API requests, you may use the kumo CLI:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 set-log-filter 'kumod=trace'\nOK\n</code></pre> <p>Run <code>kcli set-log-filter --help</code> for more informtion.</p>"},{"location":"reference/http/api_inject_v1/","title":"<code>POST /api/inject/v1</code>","text":"<p>Making a POST request to this endpoint allows injecting 1 or more messages.</p> <p>Both message assembly and templating are supported, and multiple recipients and template substitutions can be passed in a single request.</p> <p>The body of the post request must be a JSON object; here's a very basic example:</p> <pre><code>{\n\"envelope_sender\": \"noreply@example.com\",\n\"content\": \"Subject: hello\\n\\nHello there\",\n\"recipients\": [\n{\n\"email\": \"recipient@example.com\",\n}\n]\n}\n</code></pre> <p>The response will look something like:</p> <pre><code>{\n\"success_count\": 1,\n\"fail_count\": 0,\n\"failed_recipients\": [],\n\"errors\": []\n}\n</code></pre> <p>The following fields are defined for the inject request:</p>"},{"location":"reference/http/api_inject_v1/#content","title":"content","text":"<p>Specifies the message content. It can either be a string value or a JSON object describing how to build a the message.</p> <p>If a simple string is provided, it must be an RFC822 compliant message.  If template substitutions are used in the request, then the entire RFC822 message string is used as-is for the template; no message parsing or decoding is performed as part of template expansion.</p> <p>Alternatively the content can be specified as a JSON object as demonstrated below.</p> <p>Note</p> <p>Comments are used inline in the JSON objects on this page for the purposes of exposition in these docs, but comments are not valid in the actual request.</p> <pre><code>{\n\"envelope_sender\": \"noreply@example.com\",\n\"content\": {\n\"text_body\": \"This is the plain text part\",\n\"html_body\": \"&lt;p&gt;This is the &lt;b&gt;HTML&lt;/b&gt; part&lt;/p&gt;\",\n\"attachments\": [\n{\n// The attachment data.\n// If the base64 field is true, this data must be encoded\n// using base64. Otherwise, it will be interpreted as UTF-8.\n\"data\": \"R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7\",\n\"base64\": true,\n\"content_type\": \"image/gif\",\n// optional Content-ID. If specified, this attachment will\n// be added as an inline attachment and a multipart/related\n// MIME container will be generated in the message to hold\n// it and the textual content.\n\"content_id\": \"my-image\",\n// optional file name. If specified, will be added to the\n// MIME headers for the attachment.\n\"file_name\": \"pixel.gif\"\n}\n],\n// Controls the From: header\n\"from\": {\n\"email\": \"someone@example.com\",\n\"name\": \"Someone\"\n},\n// Controls the Subject: header\n\"subject\": \"This is the subject\",\n// Controls the Reply-To: header\n\"reply_to\": {\n\"email\": \"help@example.com\",\n\"name\": \"Help\"\n},\n// Specify arbitrary additional headers\n\"headers\": {\n\"X-Something\": \"Something!\"\n}\n},\n\"recipients\": [\n{\n\"email\": \"recipient@example.com\"\n}\n]\n}\n</code></pre> <p>When building a message, template substitutions are applied to the text_body, html_body and headers fields.  Attachments are not subject to template substitution.</p>"},{"location":"reference/http/api_inject_v1/#envelope_sender","title":"envelope_sender","text":"<p>The address to use as the envelope sender address when generating the message.</p> <p>It must be a string of the form user@domain.</p>"},{"location":"reference/http/api_inject_v1/#recipients","title":"recipients","text":"<p>Specifies the list of recipients to which message(s) will be sent. Each recipient is a JSON object:</p> <pre><code>{\n\"recipients\": [\n{\n// The recipient's email address. Required.\n\"email\": \"recipient@example.com\",\n// Optional recipient name. Will be used to populate\n// template substitutions.\n\"name\": \"Mr. Recipient\",\n// Optional additional template substitutions\n\"substitutions\": {\n\"key\": \"value\",\n}\n}\n]\n}\n</code></pre>"},{"location":"reference/http/api_inject_v1/#substitutions","title":"substitutions","text":"<p>Specifies a set of global substitutions to for template expansion:</p> <pre><code>{\n\"substitutions\": {\n\"campaign\": \"Summer Sale 2023\",\n}\n}\n</code></pre>"},{"location":"reference/http/api_inject_v1/#template-substitution","title":"Template Substitution","text":"<p>The injection API embeds the Mini Jinja templating engine.  The full supported syntax is documented here.</p> <p>For each recipient, the set of variables pre-defined in the template are:</p> <ul> <li> <p>The set of global substitutions defined by <code>request.substitutions</code></p> </li> <li> <p>The set of per-recipient substitutions, if any are defined in   <code>request.recipients[].substitutions</code>, are overlaid and take precedence over   any global substitutions</p> </li> <li> <p>The recipient <code>name</code> and <code>email</code> fields are assigned to the <code>\"name\"</code> and   <code>\"email\"</code> variables respectively.</p> </li> </ul> <p>Note</p> <p>Both sets of substitutions can use any JSON value for the values of the variables; they don't have to be strings.</p> <p>A very basic example of using templating:</p> <pre><code>{\n\"envelope_sender\": \"noreply@example.com\",\n\"content\": \"To: \\\"{{ name }}\\\" &lt;{{ email }}&gt;\\nSubject: hello\\n\\nHello {{ name }}!\",\n\"recipients\": [\n{\n\"email\": \"recipient@example.com\",\n\"name\": \"John Smith\"\n}\n]\n}\n</code></pre> <p>would result in an message with the following content:</p> <pre><code>To: \"John Smith\" &lt;recipient@example.com&gt;\nSubject: hello\n\nHello John Smith!\n</code></pre>"},{"location":"reference/http/metrics.json/","title":"<code>GET /metrics.json</code>","text":"<p>Exports various counters, gauges and other metrics in a JSON format loosely derived from the Prometheus Text Exposition Format.</p> <p>Access to this endpoint requires Trusted IP authentication. HTTP authentication is not permitted.</p> <p>See also metrics.</p>"},{"location":"reference/http/metrics.json/#example-data","title":"Example data","text":"<p>Here's an example of the shape of the data. The precise set of counters will vary as we continue to enhance KumoMTA.</p> <pre><code>{\n\"connection_count\": {\n\"help\": \"number of active connections\",\n\"type\": \"gauge\",\n\"value\": {\n\"service\": {\n\"esmtp_listener\": 0.0,\n\"smtp_client\": 0.0,\n\"smtp_client:source2-&gt;\": 0.0\n}\n}\n},\n\"scheduled_count\": {\n\"help\": \"number of messages in the scheduled queue\",\n\"type\": \"gauge\",\n\"value\": {\n\"queue\": {\n\"example.com\": 0.0\n}\n}\n},\n\"lua_count\": {\n\"help\": \"the number of lua contexts currently alive\",\n\"type\": \"gauge\",\n\"value\": 1.0\n},\n\"lua_load_count\": {\n\"help\": \"how many times the policy lua script has been loaded into a new context\",\n\"type\": \"counter\",\n\"value\": 1.0\n},\n\"lua_spare_count\": {\n\"help\": \"the number of lua contexts available for reuse in the pool\",\n\"type\": \"gauge\",\n\"value\": 1.0\n},\n\"memory_limit\": {\n\"help\": \"soft memory limit measured in bytes\",\n\"type\": \"gauge\",\n\"value\": 101234377728.0\n},\n\"memory_usage\": {\n\"help\": \"number of bytes of used memory\",\n\"type\": \"gauge\",\n\"value\": 185683968.0\n},\n\"message_count\": {\n\"help\": \"total number of Message objects\",\n\"type\": \"gauge\",\n\"value\": 1.0\n},\n\"message_data_resident_count\": {\n\"help\": \"total number of Message objects with body data loaded\",\n\"type\": \"gauge\",\n\"value\": 1.0\n},\n\"message_meta_resident_count\": {\n\"help\": \"total number of Message objects with metadata loaded\",\n\"type\": \"gauge\",\n\"value\": 1.0\n},\n\"ready_count\": {\n\"help\": \"number of messages in the ready queue\",\n\"type\": \"gauge\",\n\"value\": {\n\"service\": {\n\"smtp_client:source1-&gt;loopback.dummy-mx.example.com\": 46.0,\n\"smtp_client:source2-&gt;loopback.dummy-mx.example.com\": 152.0,\n}\n}\n},\n\"total_connection_count\": {\n\"help\": \"total number of active connections ever made\",\n\"type\": \"counter\",\n\"value\": {\n\"service\": {\n\"smtp_client\": 0.0,\n\"smtp_client:source2-&gt;\": 0.0\n}\n}\n},\n\"total_messages_delivered\": {\n\"help\": \"total number of messages ever delivered\",\n\"type\": \"counter\",\n\"value\": {\n\"service\": {\n\"smtp_client\": 0.0,\n\"smtp_client:source2-&gt;\": 0.0\n}\n}\n},\n\"total_messages_fail\": {\n\"help\": \"total number of message delivery attempts that permanently failed\",\n\"type\": \"counter\",\n\"value\": {\n\"service\": {\n\"smtp_client\": 0.0,\n\"smtp_client:source2-&gt;\": 0.0\n}\n}\n},\n\"total_messages_transfail\": {\n\"help\": \"total number of message delivery attempts that transiently failed\",\n\"type\": \"counter\",\n\"value\": {\n\"service\": {\n\"smtp_client\": 0.0,\n\"smtp_client:source2-&gt;\": 0.0\n}\n}\n}\n}\n</code></pre>"},{"location":"reference/http/metrics/","title":"<code>GET /metrics</code>","text":"<p>Exports various counters, gauges and other metrics using the Prometheus Text Exposition Format.</p> <p>Access to this endpoint requires Trusted IP authentication. HTTP authentication is not permitted.</p> <p>See also metrics.json.</p>"},{"location":"reference/http/metrics/#example-data","title":"Example data","text":"<p>Here's an example of the shape of the data. The precise set of counters will vary as we continue to enhance KumoMTA.</p> <pre><code># HELP connection_count number of active connections\n# TYPE connection_count gauge\nconnection_count{service=\"esmtp_listener\"} 0\nconnection_count{service=\"smtp_client\"} 0\nconnection_count{service=\"smtp_client:source2-&gt;\"} 0\n# HELP scheduled_count number of messages in the scheduled queue\n# TYPE scheduled_count gauge\nscheduled_count{queue=\"example.com\"} 0\n# HELP lua_count the number of lua contexts currently alive\n# TYPE lua_count gauge\nlua_count 1\n# HELP lua_load_count how many times the policy lua script has been loaded into a new context\n# TYPE lua_load_count counter\nlua_load_count 1\n# HELP lua_spare_count the number of lua contexts available for reuse in the pool\n# TYPE lua_spare_count gauge\nlua_spare_count 1\n# HELP memory_limit soft memory limit measured in bytes\n# TYPE memory_limit gauge\nmemory_limit 101234377728\n# HELP memory_usage number of bytes of used memory\n# TYPE memory_usage gauge\nmemory_usage 185647104\n# HELP message_count total number of Message objects\n# TYPE message_count gauge\nmessage_count 1\n# HELP message_data_resident_count total number of Message objects with body data loaded\n# TYPE message_data_resident_count gauge\nmessage_data_resident_count 1\n# HELP message_meta_resident_count total number of Message objects with metadata loaded\n# TYPE message_meta_resident_count gauge\nmessage_meta_resident_count 1\n# HELP ready_count number of messages in the ready queue\n# TYPE ready_count gauge\nready_count{service=\"smtp_client:source1-&gt;loopback.dummy-mx.example.com\"} 0\nready_count{service=\"smtp_client:source2-&gt;loopback.dummy-mx.example.com\"} 0\n# HELP total_connection_count total number of active connections ever made\n# TYPE total_connection_count counter\ntotal_connection_count{service=\"smtp_client\"} 0\ntotal_connection_count{service=\"smtp_client:source2-&gt;\"} 0\n# HELP total_messages_delivered total number of messages ever delivered\n# TYPE total_messages_delivered counter\ntotal_messages_delivered{service=\"smtp_client\"} 0\ntotal_messages_delivered{service=\"smtp_client:source2-&gt;\"} 0\n# HELP total_messages_fail total number of message delivery attempts that permanently failed\n# TYPE total_messages_fail counter\ntotal_messages_fail{service=\"smtp_client\"} 0\ntotal_messages_fail{service=\"smtp_client:source2-&gt;\"} 0\n# HELP total_messages_transfail total number of message delivery attempts that transiently failed\n# TYPE total_messages_transfail counter\ntotal_messages_transfail{service=\"smtp_client\"} 0\ntotal_messages_transfail{service=\"smtp_client:source2-&gt;\"} 0\n</code></pre>"},{"location":"reference/kumo/","title":"<code>require 'kumo'</code>","text":"<p>The <code>kumo</code> module provides access to the core KumoMTA functions used to express your configuration and policy.</p>"},{"location":"reference/kumo/#available-functions","title":"Available Functions","text":"<ul> <li>configure_accounting_db_path</li> <li>configure_bounce_classifier</li> <li>configure_local_logs</li> <li>configure_log_hook</li> <li>configure_redis_throttles</li> <li>define_spool</li> <li>json_encode</li> <li>json_encode_pretty</li> <li>json_load</li> <li>json_parse</li> <li>make_egress_path</li> <li>make_egress_pool</li> <li>make_egress_source</li> <li>make_listener_domain</li> <li>make_queue_config</li> <li>memoize</li> <li>on</li> <li>reject</li> <li>set_diagnostic_log_filter</li> <li>set_max_lua_context_age</li> <li>set_max_lua_context_use_count</li> <li>set_max_spare_lua_contexts</li> <li>start_esmtp_listener</li> <li>start_http_listener</li> <li>toml_encode</li> <li>toml_encode_pretty</li> <li>toml_load</li> <li>toml_parse</li> </ul>"},{"location":"reference/kumo/configure_accounting_db_path/","title":"<code>kumo.configure_accounting_db_path(\"PATH\")</code>","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>Configures the path that will be used for the accounting database.</p> <p>The accounting database records the total volume of message receptions and deliveries performed by the MTA.</p> <p>This function should be called only from inside your init event handler.</p> <p>The default path is <code>\"/var/spool/kumomta/accounting.db\"</code>.</p>"},{"location":"reference/kumo/configure_bounce_classifier/","title":"<code>kumo.configure_bounce_classifier {PARAMS}</code>","text":"<p>Configures the bounce classifier. The purpose of the classifier is to attempt to digest complex and wide-ranging responses into a smaller set of categories to help inform the sender how best to respond and react to a delivery failure.</p> <p>This function should be called only from inside your init event handler.</p> <p>The following classifications are pre-defined:</p> Label Meaning InvalidRecipient The recipient is invalid DNSFailure The message bounced due to a DNS failure. SpamBlock The message was blocked by the receiver as coming from a known spam source. SpamContent The message was blocked by the receiver as spam ProhibitedAttachment The message was blocked by the receiver because it contained an attachment RelayDenied The message was blocked by the receiver because relaying is not allowed. AutoReply The message is an auto-reply/vacation mail. TransientFailure Message transmission has been temporarily delayed. Subscribe The message is a subscribe request. Unsubscribe The message is an unsubscribe request. ChallengeResponse The message is a challenge-response probe. BadConfiguration messages rejected due to configuration issues with remote host BadConnection messages bounced due to bad connection issues with remote host BadDomain messages bounced due to invalid or non-existing domains ContentRelated messages refused or blocked due to content related reasons InactiveMailbox messages rejected due to expired InvalidSender messages bounced due to invalid DNS or MX entry for sending domain MessageExpired messages bounced due to not being delivered before the bounce-after NoAnswerFromHost messages bounces due to receiving no response from remote host after connecting PolicyRelated messages refused or blocked due to general policy reasons ProtocolErrors messages rejected due to SMTP protocol syntax or sequence errors QuotaIssues messages rejected or blocked due to mailbox quota issues RelayingIssues messages refused or blocked due to remote mail server relaying issues RoutingErrors messages bounced due to mail routing issues for recipient domain SpamRelated messages refused or blocked due to spam related reasons VirusRelated messages refused or blocked due to virus related reasons AuthenticationFailed authentication policy was not met Uncategorized messages rejected due to other reasons <p>Since: Version 2023.12.28-63cde9c7</p> <p>The functionality described in this outlined box requires version 2023.12.28-63cde9c7 of KumoMTA, or a more recent version.</p> <p>It is now possible to define your own classification labels. You can do so simply by using whatever label you like.  It is more efficient (uses less memory) to use one of the predefined codes.</p> <p>The classifier must be configured with a set of rules files that provide mappings from a set of regular expressions to the available classification codes.</p> <p><code>kumo.configure_bounce_classifier</code> will compile the merged set of files and rules into an efficient regex set that can quickly match the rule to the classification code.</p> <p>Once the classifier has been configured via this function, the logging functions will automatically call into it to populate the <code>bounce_classification</code> field.</p> <pre><code>kumo.on('init', function()\nkumo.configure_local_logs {\nlog_dir = '/var/log/kumomta',\n}\nkumo.configure_bounce_classifier {\nfiles = {\n'/opt/kumomta/share/bounce_classifier/iana.toml',\n},\n}\nend)\n</code></pre> <p>The <code>iana.toml</code> file is provided with rules that map from IANA defined status codes to an appropriate bounce class.</p> <p>You may create and maintain your own classifications and add them to the list of files.</p> <p>Here's an excerpt of the <code>iana.toml</code>:</p> <pre><code># This file contains rules that match SMTP ENHANCEDSTATUSCODES\n# codes as defined in the IANA registry:\n# https://www.iana.org/assignments/smtp-enhanced-status-codes/smtp-enhanced-status-codes.xhtml\n# to bounce classifications.\n[rules]\nInvalidRecipient = [\n\"^(451|550) [45]\\\\.1\\\\.[1234] \",\n\"^45[02] [45]\\\\.2\\\\.4 \", # Mailing list expansion\n\"^5\\\\d{2} [45]\\\\.7\\\\.17 \", # RRVS: Mailbox owner has changed\n]\nBadDomain = [\n\"^(451|550) [45]\\\\.1\\\\.10 \", # NULL MX\n\"^5\\\\d{2} [45]\\\\.7\\\\.18 \", # RRVS: domain owner has changed\n]\nInactiveMailbox = [\n\"^(451|550) [45]\\\\.1\\\\.[6] \",\n\"^[45]\\\\d{2} [45]\\\\.2\\\\.1 \",\n\"^525 [45]\\\\.7\\\\.13 \", # User account disabled\n]\nInvalidSender = [\n\"^(451|550) [45]\\\\.1\\\\.[78] \",\n\"^\\\\d{3} [45]\\\\.7\\\\.27 \", # Send address has NULL MX\n]\nQuotaIssues = [\n\"^552 [45]\\\\.2\\\\.2 \",\n\"^552 [45]\\\\.2\\\\.3 \",\n\"^452 [45]\\\\.3\\\\.1 \", # Mail System Full\n\"^55[24] [45]\\\\.3\\\\.4 \", # Message too large for system\n]\n</code></pre>"},{"location":"reference/kumo/configure_local_logs/","title":"<code>kumo.configure_local_logs {PARAMS}</code>","text":"<p>Enables local logging of reception and delivery events to the specified <code>log_dir</code> directory.</p> <p>Logs are written as zstd-compressed log file segments under the specified directory.  Each line of the file is a JSON object holding information about a reception or delivery related event.</p> <p>This function should be called only from inside your init event handler.</p> <pre><code>kumo.on('init', function()\nkumo.configure_local_logs {\nlog_dir = '/var/log/kumo-logs',\n}\nend)\n</code></pre> <p>PARAMS is a lua table that can accept the keys listed below:</p>"},{"location":"reference/kumo/configure_local_logs/#back_pressure","title":"back_pressure","text":"<p>Maximum number of outstanding items to be logged before the submission will block; helps to avoid runaway issues spiralling out of control.</p> <pre><code>kumo.configure_local_logs {\n-- ..\nback_pressure = 128000,\n}\n</code></pre>"},{"location":"reference/kumo/configure_local_logs/#compression_level","title":"compression_level","text":"<p>Specifies the level of zstd compression that should be used.  Compression cannot be disabled.</p> <p>Specifying <code>0</code> uses the zstd default compression level, which is <code>3</code> at the time of writing.</p> <p>Possible values are <code>1</code> (cheapest, lightest) through to <code>21</code>.</p> <pre><code>kumo.configure_local_logs {\n-- ..\ncompression_level = 3,\n}\n</code></pre>"},{"location":"reference/kumo/configure_local_logs/#filter_event","title":"filter_event","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>Optional string. If provided, specifies the name of an event that should be triggered to decide whether logs for a given message should be included in this instance of local file logging.</p> <p>The event will be passed the message that is being considered for logging purposes.  The goal of the event is to return <code>true</code> if logging should proceed or <code>false</code> otherwise.</p> <p>You may access the message metadata to make that decision.</p> <pre><code>kumo.on('init', function()\n-- We only want logs for messages accepted via SMTP to land here\nkumo.configure_local_logs {\nlog_dir = '/var/log/kumo-logs-smtp',\nfilter_event = 'should_log_to_smtp_logs',\n}\n-- We want all other logs to land here\nkumo.configure_local_logs {\nlog_dir = '/var/log/kumo-logs-other',\nfilter_event = 'should_log_to_other',\n}\nend)\nkumo.on('should_log_to_smtp_logs', function(msg)\nreturn msg:get_meta 'reception_protocol' == 'ESMTP'\nend)\nkumo.on('should_log_to_other', function(msg)\nreturn msg:get_meta 'reception_protocol' ~= 'ESMTP'\nend)\n</code></pre>"},{"location":"reference/kumo/configure_local_logs/#headers","title":"headers","text":"<p>Specify a list of message headers to include in the logs. The default is empty.</p> <pre><code>kumo.configure_local_logs {\n-- ..\nheaders = { 'Subject' },\n}\n</code></pre> <p>Since: Version 2023.12.28-63cde9c7</p> <p>The functionality described in this outlined box requires version 2023.12.28-63cde9c7 of KumoMTA, or a more recent version.</p> <p>Header names can now use simple wildcard suffixes; if the last character of the header name is <code>*</code> then it will match any string with that prefix. For example <code>\"X-*\"</code> will match any header names that start with <code>\"X-\"</code>.</p>"},{"location":"reference/kumo/configure_local_logs/#log_dir","title":"log_dir","text":"<p>Specifies the directory into which log file segments will be written. This is a required key; there is no default value.</p> <pre><code>kumo.configure_local_logs {\n-- ..\nlog_dir = '/var/log/kumo-logs',\n}\n</code></pre>"},{"location":"reference/kumo/configure_local_logs/#max_file_size","title":"max_file_size","text":"<p>Specify how many uncompressed bytes to allow per file segment. When this number is exceeded, the current segment is finished and a new segment is created.</p> <p>Segments are created using the current time in the form <code>YYYYMMDD-HHMMSS</code> so that it is easy to sort the segments in chronological order.</p> <p>The default value is ~1GB of uncompressed data, which compresses down to around 50MB of data per segment with the default compression settings.</p> <pre><code>kumo.configure_local_logs {\n-- ..\nmax_file_size = 1000000000,\n}\n</code></pre>"},{"location":"reference/kumo/configure_local_logs/#max_segment_duration","title":"max_segment_duration","text":"<p>Specify the maximum time period for a file segment.  The default is unlimited.</p> <p>If you set this to <code>\"1min\"</code>, you indicate that any given file should cover a time period of 1 minute in duration; when that time period elapses, the current file segment, if any, will be flushed and closed and any subsequent events will cause a new file segment to be created.</p> <pre><code>kumo.configure_local_logs {\n-- ..\nmax_segment_duration = '5 minutes',\n}\n</code></pre>"},{"location":"reference/kumo/configure_local_logs/#meta","title":"meta","text":"<p>Specify a list of message meta fields to include in the logs. The default is empty.</p> <pre><code>kumo.configure_local_logs {\n-- ..\nmeta = { 'my-meta-1' },\n}\n</code></pre>"},{"location":"reference/kumo/configure_local_logs/#per_record","title":"per_record","text":"<p>Allows configuring per-record type logging.</p> <pre><code>kumo.configure_local_logs {\nper_record = {\nReception = {\n-- use names like \"20230306-022811_recv\" for reception logs\nsuffix = '_recv',\n},\nDelivery = {\n-- put delivery logs in a different directory\nlog_dir = '/var/log/kumo/delivery',\n},\nTransientFailure = {\n-- Don't log transient failures\nenable = false,\n},\nBounce = {\n-- Instead of logging the json record, evaluate this\n-- template string and log the result.\ntemplate = [[Bounce! id={{ id }}, from={{ sender }} code={{ code }} age={{ timestamp - created }}]],\n},\n-- For any record type not explicitly listed, apply these settings.\n-- This effectively turns off all other log records\nAny = {\nenable = false,\n},\n},\n}\n</code></pre> <p>The keys of the <code>per_record</code> table must correspond to one of the record types listed below, or the special <code>Any</code> key which can be used to match any record type that was not explicitly listed.  The values of the <code>per_record</code> table are <code>LogRecordParams</code> have the following fields and values:</p> <ul> <li><code>suffix</code> - a string to append to the generated segment file name.   For example, <code>suffix = '.csv'</code> will generate names like <code>20230306-022811.csv</code>.</li> <li><code>log_dir</code> - specify an alternative log directory for this type</li> <li><code>enable</code> - defaults to <code>true</code>. If you set it to <code>false</code>, records of this   type will not be logged</li> <li><code>segment_header</code> - ((Since: Version 2023.11.28-b5252a41)) text that will be written   out to each newly opened segment file. Useful for emitting eg: a CSV header   line.</li> <li><code>template</code> - the template to use to format the log line. Continue reading   below for more information.</li> </ul> <p>The Mini Jinja templating engine is used to evalute logging templates.  The full supported syntax is documented here.</p> <p>The JSON log record fields shown in the section below are assigned as template variables, so using <code>{{ id }}</code> in your log template will be substituted with the <code>id</code> field from the log record section below.</p> <p>Since: Version 2023.11.28-b5252a41</p> <p>The functionality described in this outlined box requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>You may now use <code>log_record</code> to reference the entire log record, which is useful if you want to replicate the default json representation of the log record for an individual record type.</p> <p>You might wish to use something like the following:</p> <pre><code>per_record = {\nFeedback = {\ntemplate = [[{{ log_record | tojson }}]]\n}\n}\n</code></pre>"},{"location":"reference/kumo/configure_local_logs/#log-record","title":"Log Record","text":"<p>The log record is a JSON object with the following shape:</p> <pre><code>{\n// The record type; can be one of \"Reception\", \"Delivery\",\n// \"Bounce\", \"TransientFailure\", \"Expiration\", \"AdminBounce\",\n// \"OOB\" or \"Feedback\"\n\"type\": \"Delivery\",\n// The message spool id; corresponds to the value returned by\n// message:id()\n\"id\": \"1d98076abbbc11ed940250ebf67f93bd\",\n// The envelope sender\n\"sender\": \"user@sender.example.com\",\n// The envelope recipient\n\"recipient\": \"user@recipient.example.com\",\n// Which named queue the message was associaed with\n\"queue\": \"campaign:tenant@domain\",\n// Which MX site the message was being delivered to.\n// Empty string for Reception records.\n\"site\": \"source2-&gt;(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com.\",\n// The size of the message payload, in bytes\n\"size\": 1047,\n// The response from the peer, if applicable\n\"response\": {\n// the SMTP status code\n\"code\": 250,\n// The ENHANCEDSTATUSCODE portion of the response parsed\n// out into individual fields.\n// This one is from a \"2.0.0\" status code\n\"enhanced_code\": {\n\"class\": 2,\n\"subject\": 0,\n\"detail\": 0,\n},\n// the remainder of the response content\n\"content\": \"OK ids=8a5475ccbbc611eda12250ebf67f93bd\",\n// the SMTP command verb to which the response was made.\n// eg: \"MAIL FROM\", \"RCPT TO\" etc. \".\" isn't really a command\n// but is used to represent the response to the final \".:\n// we send to indicate the end of the message payload.\n\"command\": \".\"\n},\n// Information about the peer in the communication. This is either\n// the submitter or the receiver, depending on the record type\n\"peer_address\": {\n// When delivering, this is the name from the MX record.\n// When receiving, this is the EHLO/HELO string sent by\n// the sender\n\"name\": \"gmail-smtp-in.l.google.com.\",\n\"addr\": \"142.251.2.27\"\n},\n// The time at which this record was generated, expressed\n// as a unix timestamp: seconds since the unix epoch\n\"timestamp\": 1678069691,\n// The time at which the message was received, expressed\n// as a unix timestamp: seconds since the unix epoch\n\"created\": 1678069691,\n// The number of delivery attempts.\n\"num_attempts\": 0,\n// the classification assigned by the bounce classifier,\n// or Uncategorized if unknown or the classifier is not configured.\n\"bounce_classification\": \"Uncategorized\",\n// The name of the egress pool used as the source for the delivery\n\"egress_pool\": \"pool0\",\n// The name of the selected egress source (a member of the egress pool)\n// used for the delivery\n\"egress_source\": \"source2\",\n// when \"type\" == \"Feedback\", holds the parsed feedback report\n\"feedback_report\": null,\n// holds the values of the list of meta fields from the logger\n// configuration\n\"meta\": {},\n// holds the values of the list of message headers from the logger\n// configuration\n\"headers\": {},\n// The protocol used to deliver, or attempt to deliver, this message.\n// May be null or unset for expirations or administrative bounces\n// or other similar situations.\n// \"ESMTP\" for SMTP, \"Maildir\" for maildir and \"Lua\" for a lua delivery\n// mechanism.\n\"delivery_protocol\": \"ESMTP\",\n// The protocol used to receive the message\n// \"ESMTP\" for SMTP, \"HTTP\" for the HTTP injection API, \"LogRecord\"\n// for messages captured via `configure_log_hook`.\n// This information is also stored in the message meta key named\n// \"reception_protocol\".\n\"reception_protocol\": \"ESMTP\",\n// The node uuid. This identifies the node independently from its\n// IP address or other characteristics present in this log record.\n\"nodeid\": \"557f3ad4-2c8c-11ee-976e-782d7e12e173\",\n// Information about TLS used for outgoing SMTP, if applicable.\n// These fields are present in dev builds only:\n\"tls_cipher\": \"TLS_AES_256_GCM_SHA384\",\n\"tls_protocol_version\": \"TLSv1.3\",\n\"tls_peer_subject_name\": [\"C=US\",\"ST=CA\",\"L=SanFrancisco\",\"O=Fort-Funston\",\n\"OU=MyOrganizationalUnit\",\"CN=do.havedane.net\",\n\"name=EasyRSA\",\"emailAddress=me@myhost.mydomain\"]}\n}\n</code></pre>"},{"location":"reference/kumo/configure_local_logs/#record-types","title":"Record Types","text":"<p>The following record types are defined:</p> <ul> <li><code>\"Reception\"</code> - logging the reception of a message via SMTP or via   the HTTP injection API</li> <li><code>\"Delivery\"</code> - logging the successful delivery of a message via SMTP</li> <li><code>\"Bounce\"</code> - logging a permanent failure response and end of delivery   attempts for the message.</li> <li><code>\"TransientFailure\"</code> - logging a transient failure when attempting delivery</li> <li><code>\"Expiration\"</code> - logged when the message exceeds the configured maximum   lifetime in the queue.</li> <li><code>\"AdminBounce\"</code> - logged when an administrator uses the <code>/api/admin/bounce</code>   API to fail message(s).</li> <li><code>\"OOB\"</code> - when receiving an out of band bounce with an attached RFC3464   delivery status report, the parsed report is used to synthesize an OOB   record for each recipient in the report.</li> <li><code>\"Feedback\"</code> - when receiving an ARF feedback report, instead of logging   a <code>\"Reception\"</code>, a <code>\"Feedback\"</code> record is logged instead with the report   contents parsed out and made available in the <code>feedback_report</code> field.</li> </ul>"},{"location":"reference/kumo/configure_local_logs/#feedback-report","title":"Feedback Report","text":"<p>ARF feedback reports are parsed into a JSON object that has the following structure.  The fields of the <code>feedback_report</code> correspond to those defined by RFC 5965.</p> <p>See also trace_headers for information about the <code>supplemental_trace</code> field.</p> <pre><code>{\n\"type\": \"Feedback\",\n\"feedback_report\": {\n\"feedback_type\": \"abuse\",\n\"user_agent\": \"SomeGenerator/1.0\",\n\"version\": 1,\n\"arrival_date\": \"2005-03-08T18:00:00Z\",\n\"incidents\": nil,\n\"original_envelope_id\": nil,\n\"original_mail_from\": \"&lt;somesender@example.net&gt;\",\n\"reporting_mta\": {\n\"mta_type\": \"dns\",\n\"name\": \"mail.example.com\",\n},\n\"source_ip\": \"192.0.2.1\",\n\"authentication_results\": [\n\"mail.example.com; spf=fail smtp.mail=somesender@example.com\",\n],\n\"original_rcpto_to\": [\n\"&lt;user@example.com&gt;\",\n],\n\"reported_domain\": [\n\"example.net\",\n],\n\"reported_uri\": [\n\"http://example.net/earn_money.html\",\n\"mailto:user@example.com\",\n],\n// any fields found in the report that do not correspond to\n// those defined by RFC 5965 are collected into this\n// extensions field\n\"extensions\": {\n\"removal-recipient\": [\n\"user@example.com\",\n],\n},\n// The original message or message headers, if provided in\n// the report\n\"original_message\": \"From: &lt;somesender@example.net&gt;\nReceived: from mailserver.example.net (mailserver.example.net\n    [192.0.2.1]) by example.com with ESMTP id M63d4137594e46;\n    Tue, 08 Mar 2005 14:00:00 -0400\nX-KumoRef: eyJfQF8iOiJcXF8vIiwicmVjaXBpZW50IjoidGVzdEBleGFtcGxlLmNvbSJ9\nTo: &lt;Undisclosed Recipients&gt;\nSubject: Earn money\nMIME-Version: 1.0\nContent-type: text/plain\nMessage-ID: 8787KJKJ3K4J3K4J3K4J3.mail@example.net\nDate: Thu, 02 Sep 2004 12:31:03 -0500\nSpam Spam Spam\nSpam Spam Spam\nSpam Spam Spam\nSpam Spam Spam\n\",\n// if original_message is present, and a kumo-style trace\n// header was decoded from it, then this holds the decoded\n// trace information\n\"supplemental_trace\": {\n\"recipient\": \"test@example.com\",\n},\n}\n}\n</code></pre>"},{"location":"reference/kumo/configure_log_hook/","title":"<code>kumo.configure_log_hook {PARAMS}</code>","text":"<p>Configures the lua logging hook. When enabled, each matching log event will cause cause new a Message to be generated and have its body assigned to the log record (or to its template expansion if you have configured that), and passed to the should_enqueue_log_record event.</p> <pre><code>kumo.on('init', function()\nkumo.configure_log_hook {\n-- name will be passed to should_enqueue_log_record as the hook_name\n-- parameter so that you can reason about different instances of the\n-- log hook in the case where you are sending data to multiple\n-- different places.\nname = 'webhook',\nheaders = { 'Subject', 'X-Customer-ID' },\n}\nend)\n</code></pre> <p>This allows you to utilize KumoMTA's internal queueing to dispatch log events to external systems such as webhooks or some external queuing system for processing elsewhere in your deployment architecture.</p> <p>See should_enqueue_log_record for an example.</p> <p>The following options are configurable for the logging hook and work the same way as their counterparts in local log file logging. Rather than duplicate the information here, this section links to those options:</p> <ul> <li>back_pressure</li> <li>meta</li> <li>headers</li> <li>per_record</li> </ul> <p>In addition, the following options are supported:</p>"},{"location":"reference/kumo/configure_log_hook/#name","title":"name","text":"<p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Required string naming the hook.</p> <p>The name will be passed as the hook_name parameter to the should_enqueue_log_record event.</p>"},{"location":"reference/kumo/configure_log_hook/#deferred_spool","title":"deferred_spool","text":"<p>If set to <code>true</code>, the generated message will not be immediately saved to the spool in the case that your should_enqueue_log_record indicates that the message should be queued.</p>"},{"location":"reference/kumo/configure_redis_throttles/","title":"<code>kumo.configure_redis_throttles { PARAMS }</code>","text":"<p>Configure the throttle layer to use a Redis data store to manage throttling across multiple MTA nodes.</p> <p>The redis server must have redis-cell installed for throttles to work in this way.</p> <p>PARAMS behaves exactly as described in redis.open.</p> <p>This function should be called only from inside your init event handler.</p> <pre><code>kumo.on('init', function()\n-- Use shared throttles and connection limits rather than in-process throttles\nkumo.configure_redis_throttles { node = 'redis://my-redis-host/' }\nend)\n</code></pre> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Enabling redis throttles now also enables redis-based shared connection limits.</p>"},{"location":"reference/kumo/define_spool/","title":"<code>kumo.define_spool {PARAMS}</code>","text":"<p>Defines a named spool storage backend.</p> <p>KumoMTA uses separate storage areas for metadata and message contents, named <code>\"meta\"</code> and <code>\"data\"</code> respectively.</p> <p>This function should be called only from inside your init event handler.</p> <pre><code>kumo.on('init', function()\nkumo.define_spool {\nname = 'data',\npath = '/var/spool/kumo/data',\n}\nkumo.define_spool {\nname = 'meta',\npath = '/var/spool/kumo/meta',\n}\nend)\n</code></pre> <p>PARAMS is a lua table that can accept the keys listed below:</p>"},{"location":"reference/kumo/define_spool/#flush","title":"flush","text":"<p>Whether to flush data to storage after each write. The default is <code>false</code>. When set to <code>true</code>, a backend specific means of flushing OS buffers to storage will be used after each write to encourage maximum durability of writes.</p> <p>Setting <code>flush=true</code> can be incredibly harmful to throughput, and, depending on your local storage device and filesystem selection, may not meaningfully increase durability.</p> <pre><code>kumo.on('init', function()\nkumo.define_spool {\n-- ..\nflush = false,\n}\nend)\n</code></pre>"},{"location":"reference/kumo/define_spool/#kind","title":"kind","text":"<p>Specifies the spool storage backend type. There are two possible options:</p> <ul> <li><code>\"LocalDisk\"</code> - the default. Stores data in individual files on the filesystem.</li> <li><code>\"RocksDB\"</code> - uses RocksDB to achieve higher throughput.</li> </ul> <p><code>\"LocalDisk\"</code>'s performance characteristics are strongly coupled with your local storage device and filesystem performance.</p> <p><code>\"RocksDB\"</code> makes heavy use of memory buffers and intelligent layout of storage to reduce the I/O cost. To a certain degree, the buffering has similar characteristics to deferred spooling, but the risk of corruption is attenuated because RocksDB uses a write-ahead-log and a background sync thread.</p>"},{"location":"reference/kumo/define_spool/#name","title":"name","text":"<p>Specify the name of this spool. You are free to define as many spools as you wish, but at the time of writing KumoMTA only uses spools with the following names:</p> <ul> <li><code>\"data\"</code> - holds the message bodies</li> <li><code>\"meta\"</code> - holds message metadata, such as the envelope and per message metadata</li> </ul>"},{"location":"reference/kumo/define_spool/#path","title":"path","text":"<p>Specifies the path to the directory into which the spool will be stored.</p> <pre><code>kumo.on('init', function()\nkumo.define_spool {\nname = 'data',\npath = '/var/spool/kumo-spool/data',\n}\nend)\n</code></pre>"},{"location":"reference/kumo/json_encode/","title":"<code>kumo.json_encode(VALUE)</code>","text":"<p>Attempts to encode VALUE as its JSON equivalent, and returns that value serialized as a string.</p> <p>This is logically the opposite of kumo.json_parse.</p> <p>See also kumo.json_load, kumo.json_parse and kumo.json_encode_pretty</p>"},{"location":"reference/kumo/json_encode_pretty/","title":"<code>kumo.json_encode_pretty(VALUE)</code>","text":"<p>Attempts to encode VALUE as its JSON equivalent, and returns that value serialized as a string, using pretty, more human readable representation.</p> <p>This is logically the opposite of kumo.json_parse.</p> <p>See also kumo.json_load, kumo.json_parse and kumo.json_encode</p>"},{"location":"reference/kumo/json_load/","title":"<code>kumo.json_load(FILENAME)</code>","text":"<p>Reads the content of the file name <code>FILENAME</code> and parses it as JSON, returning a lua representation of the parsed JSON.</p> <p>This json loading implementation will accept C style block comments, C++ style single line comments and shell style single line comments.  Comments will be treated as though they were spaces prior to being parsed by the underlying json parser.</p> <p>See also kumo.json_parse, kumo.json_encode and kumo.json_encode_pretty</p>"},{"location":"reference/kumo/json_parse/","title":"<code>kumo.json_parse(STRING)</code>","text":"<p>Parses STRING as JSON, returning a lua representation of the parsed JSON.</p> <p>This json parsing implementation will accept C style block comments, C++ style single line comments and shell style single line comments.  Comments will be treated as though they were spaces prior to being parsed by the underlying json parser.</p> <p>This is logically the opposite of kumo.json_encode.</p> <p>See also kumo.json_load, kumo.json_encode and kumo.json_encode_pretty</p>"},{"location":"reference/kumo/make_egress_path/","title":"<code>kumo.make_egress_path { PARAMS }</code>","text":"<p>Constructs a configuration object that specifies how traffic travelling the path from a source to a site will behave.</p> <p>This function should be called from the get_egress_path_config event handler to provide the configuration for the requested site.</p> <p>The following keys are possible:</p>"},{"location":"reference/kumo/make_egress_path/#connection_limit","title":"connection_limit","text":"<p>Specifies the maximum number of concurrent connections that will be made from the current MTA machine to the destination site.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\nreturn kumo.make_egress_path {\nconnection_limit = 32,\n}\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/#consecutive_connection_failures_before_delay","title":"consecutive_connection_failures_before_delay","text":"<p>Each time KumoMTA exhausts the full list of hosts for the destination it increments a <code>consecutive_connection_failures</code> counter. When that counter exceeds the <code>consecutive_connection_failures_before_delay</code> configuration value, KumoMTA will then delay all of the messages currently in the ready queue, generating a transient failure log record with code <code>451 4.4.1 No answer from any hosts listed in MX</code>.</p> <p>The default value for this setting is 100.</p>"},{"location":"reference/kumo/make_egress_path/#ehlo_domain","title":"ehlo_domain","text":"<p>Optional string. Specifies the EHLO domain when initiating a connection to the destination. The default value is the <code>ehlo_domain</code> specified by make_egress_source, if any, otherwise, the local machine hostname.</p>"},{"location":"reference/kumo/make_egress_path/#enable_tls","title":"enable_tls","text":"<p>Controls whether and how TLS will be used when connecting to the destination. Possible values are:</p> <ul> <li> <p><code>\"Opportunistic\"</code> - use TLS if advertised by the <code>EHLO</code> response. If the peer   has invalid or self-signed certificates, then the delivery will fail. KumoMTA   will NOT fallback to not using TLS on that same host.</p> </li> <li> <p><code>\"OpportunisticInsecure\"</code> - use TLS if advertised by the <code>EHLO</code> response.   Validation of the certificate will be skipped. Not recommended for sending to   the public internet; this is intended for local or lab testing scenarios.</p> </li> <li> <p><code>\"Required\"</code> - Require that TLS be advertised in the <code>EHLO</code> response. The   remote host must have valid certificates in order to deliver to the site.</p> </li> <li> <p><code>\"RequiredInsecure\"</code> - Require that TLS be advertised in the <code>EHLO</code> response.   Validation of the certificate will be skipped.  Not recommended for sending   to the public internet; this is intended for local or lab testing scenarios.</p> </li> <li> <p><code>\"Disabled\"</code> - do not try to use TLS.</p> </li> </ul> <p>The default value is <code>\"Opportunistic\"</code>.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\nreturn kumo.make_egress_path {\nenable_tls = 'Opportunistic',\n}\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/#enable_mta_sts","title":"enable_mta_sts","text":"<p>Since: Version 2023.11.28-b5252a41</p> <p>The functionality described in this outlined box requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>When set to <code>true</code> (which is the default), the MTA-STS policy for the destination domain will be used to adjust the effective value of <code>enable_tls</code>.</p> <p>If the policy is set to <code>\"enforce\"</code>, then, assuming that the candidate MX host name matches the policy, the connection will be made with <code>enable_tls=\"Required\"</code>.  If the host name does not match, the candidate MX host will be not be used.</p> <p>If the policy is set to <code>\"testing\"</code>, then the connection will be made with <code>enable_tls=\"OpportunisticInsecure\"</code>.</p> <p>If the policy is set to <code>\"none\"</code>, then your configured value for <code>enable_tls</code> will be used.</p> <p>If <code>enable_dane=true</code> and <code>TLSA</code> records are present, then any MTA-STS policy will be ignored.</p>"},{"location":"reference/kumo/make_egress_path/#enable_dane","title":"enable_dane","text":"<p>Since: Version 2023.11.28-b5252a41</p> <p>The functionality described in this outlined box requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>When set to <code>true</code> (the default is <code>false</code>), then <code>TLSA</code> records will be resolved securely to determine the destination site policy for TLS according to DANE.</p> <p>If TLSA records are available, then the effective value of <code>enable_tls</code> will be treated as though it were set to <code>\"Required\"</code> and the OpenSSL DANE implementation will be used to verify the server certificate against the TLSA records found in DNS.</p> <p>Use of DANE also requires functioning DNSSEC in your DNS resolver; you will need to configure the <code>libunbound</code> resolver to successfully use DANE:</p> <pre><code>kumo.on('init', function()\nkumo.dns.configure_unbound_resolver {\noptions = {\n-- Enable DNSSEC\nvalidate = true,\n},\n-- By default, if you omit `name_servers`, unbound will\n-- resolve via the root resolvers.\n-- We strongly recommend deploying local caching nameservers\n-- and referencing them here:\n-- name_servers = { '1.1.1.1:53' },\n}\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/#connect_timeout","title":"connect_timeout","text":""},{"location":"reference/kumo/make_egress_path/#starttls_timeout","title":"starttls_timeout","text":""},{"location":"reference/kumo/make_egress_path/#ehlo_timeout","title":"ehlo_timeout","text":""},{"location":"reference/kumo/make_egress_path/#mail_from_timeout","title":"mail_from_timeout","text":""},{"location":"reference/kumo/make_egress_path/#rcpt_to_timeout","title":"rcpt_to_timeout","text":""},{"location":"reference/kumo/make_egress_path/#data_timeout","title":"data_timeout","text":""},{"location":"reference/kumo/make_egress_path/#data_dot_timeout","title":"data_dot_timeout","text":""},{"location":"reference/kumo/make_egress_path/#rset_timeout","title":"rset_timeout","text":"<p>Controls the timeouts waiting for responses to various SMTP commands.</p> <p>The value is specified as a integer in seconds, or as a string using syntax like <code>\"2min\"</code> for a two minute duration.</p>"},{"location":"reference/kumo/make_egress_path/#idle_timeout","title":"idle_timeout","text":"<p>how long a connection will remain open and idle, waiting to be reused for another delivery attempt, before being closed.</p> <p>The value is specified as a integer in seconds, or as a string using syntax like <code>\"2min\"</code> for a two minute duration.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\nreturn kumo.make_egress_path {\nidle_timeout = 60,\n}\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/#max_connection_rate","title":"max_connection_rate","text":"<p>Optional string.</p> <p>Specifies the maximum permitted rate at which connections can be established from this source to the corresponding destination site.</p> <p>The value is of the form <code>quantity/period</code> where quantity is a number and period can be a measure of time.</p> <p>Examples of throttles:</p> <pre><code>\"10/s\" -- 10 per second\n\"10/sec\" -- 10 per second\n\"10/second\" -- 10 per second\n\n\"50/m\" -- 50 per minute\n\"50/min\" -- 50 per minute\n\"50/minute\" -- 50 per minute\n\n\"1,000/hr\" -- 1000 per hour\n\"1_000/h\" -- 1000 per hour\n\"1000/hour\" -- 1000 per hour\n\n\"10_000/d\" -- 10,000 per day\n\"10,000/day\" -- 10,000 per day\n</code></pre> <p>Throttles are implemented using a Generic Cell Rate Algorithm.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, source_name, site_name)\nreturn kumo.make_egress_path {\nmax_connection_rate = '100/min',\n}\nend)\n</code></pre> <p>If the throttle is exceeded and the delay before a connection be established is longer than the <code>idle_timeout</code>, then the messages in the ready queue will be delayed until the throttle would permit them to be delievered again.</p>"},{"location":"reference/kumo/make_egress_path/#max_deliveries_per_connection","title":"max_deliveries_per_connection","text":"<p>Optional number.</p> <p>If set, no more than this number of messages will be attempted on any given connection.</p> Version Default (Since: Version 2023.08.22-4d895015) The default is 1024 Prior versions The default is unlimited"},{"location":"reference/kumo/make_egress_path/#max_message_rate","title":"max_message_rate","text":"<p>Optional string.</p> <p>Specifies the maximum permitted rate at which messages can be delivered from this source to the corresponding destination site.</p> <p>The throttle is specified the same was as for <code>max_connection_rate</code> above.</p> <p>If the throttle is exceeded and the delay before the current message can be sent is longer than the <code>idle_timeout</code>, then the messages in the ready queue will be delayed until the throttle would permit them to be delievered again.</p>"},{"location":"reference/kumo/make_egress_path/#max_ready","title":"max_ready","text":"<p>Specifies the maximum number of messages that can be in the ready queue. The ready queue is the set of messages that are immediately eligible for delivery.</p> <p>If a message is promoted from its delayed queue to the ready queue and it would take the size of the ready queue above max_ready, the message will be delayed by a randomized interval of up to 60 seconds and placed back into the scheduled queue before being considered again.</p> <p>Moving a message from ready to scheduled as a result of hitting this limit may trigger disk IO to save the content of the message if the message was received with deferred spooling enabled.  In addition, other in-memory state is discarded to reduce memory utilization, and it will need to be re-loaded from the spool when the message is tried again later.</p> <p>The default for <code>max_ready</code> is 1024 messages.</p> <p>Raising the limit will increase RAM utilization in exchange for decreasing the IO load to your spool storage.</p>"},{"location":"reference/kumo/make_egress_path/#prohibited_hosts","title":"prohibited_hosts","text":"<p>A CIDR list of hosts that should be considered \"poisonous\", for example, because they might cause a mail loop.</p> <p>When resolving the hosts for the destination MX, if any of the hosts are present in the <code>prohibited_hosts</code> list then the ready queue will be immediately failed with a <code>550 5.4.4</code> status.</p>"},{"location":"reference/kumo/make_egress_path/#skip_hosts","title":"skip_hosts","text":"<p>A CIDR list of hosts that should be removed from the list of hosts returned when resolving the MX for the destination domain.</p> <p>This can be used for example to skip a host that is experiencing issues.</p> <p>If all of the hosts returned for an MX are filtered out by <code>skip_hosts</code> then the ready queue will be immediately failed with a <code>550 5.4.4</code> status.</p>"},{"location":"reference/kumo/make_egress_path/#smtp_port","title":"smtp_port","text":"<p>Specifies the port to connect to when making an SMTP connection to a destination MX host.</p> <p>The default is port 25.</p> <p>See also kumo.make_egress_source().remote_port</p>"},{"location":"reference/kumo/make_egress_path/#smtp_auth_plain_username","title":"smtp_auth_plain_username","text":"<p>When set, connecting to the destination requires a successful AUTH PLAIN using the specified username.</p> <p>AUTH PLAIN will only be attempted if TLS is also enabled, unless <code>allow_smtp_auth_plain_without_tls = true</code>. This is to prevent leaking of the credential over an unencrypted link.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, site_name)\nreturn kumo.make_egress_path {\nenable_tls = 'Required',\nsmtp_auth_plain_username = 'scott',\n-- The password can be any keysource value\nsmtp_auth_plain_password = {\nkey_data = 'tiger',\n},\n}\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/#smtp_auth_plain_password","title":"smtp_auth_plain_password","text":"<p>Specifies the password that should be used together with <code>smtp_auth_plain_username</code> when an authenticated SMTP connection is desired.</p> <p>The value is any keysource, which allows for specifying the password inline in the configuration file, or managing it via a credential manager such as HashiCorp Vault.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, site_name)\nreturn kumo.make_egress_path {\nenable_tls = 'Required',\nsmtp_auth_plain_username = 'scott',\n-- The password can be any keysource value.\n-- Here we are loading the credential for the domain\n-- from HashiCorp vault\nsmtp_auth_plain_password = {\nvault_mount = 'secret',\nvault_path = 'smtp-auth/' .. domain,\n},\n}\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_path/#allow_smtp_auth_plain_without_tls","title":"allow_smtp_auth_plain_without_tls","text":"<p>Optional boolean. Defaults to <code>false</code>.</p> <p>When <code>false</code>, and the connection is not using TLS, SMTP AUTH PLAIN will be premptively failed in order to prevent the credential from being passed over the network in clear text.</p> <p>You can set this to <code>true</code> to allow sending the credential in clear text.</p> <p>Danger</p> <p>Do not enable this option on an untrusted network, as the credential will then be passed in clear text and visible to anyone else on the network</p>"},{"location":"reference/kumo/make_egress_path/#suspended","title":"suspended","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Optional boolean. Defaults to <code>false</code>.</p> <p>When set to <code>true</code>, this pathway will not be used to send mail.</p> <p>This option is present primarily to facilitate traffic shaping automation.</p>"},{"location":"reference/kumo/make_egress_pool/","title":"<code>kumo.make_egress_pool { PARAMS }</code>","text":"<p>Defines an egress pool, which is a collection of weighted egress sources associated with the source of outbound traffic from the MTA.</p> <p>This function is intended to be used inside your get_egress_pool event handler.</p> <p><code>PARAMS</code> is a lua table which may have the following keys:</p>"},{"location":"reference/kumo/make_egress_pool/#name","title":"name","text":"<p>Required string.</p> <p>The name of the pool. This name can be referenced via make_queue_config().egress_pool.</p>"},{"location":"reference/kumo/make_egress_pool/#entries","title":"entries","text":"<p>Required list of entries.</p> <p>Each entry has a name, which must refer to a source that will be resolved via your get_egress_source event, and an optional weight:</p> <pre><code>local SOURCE_TO_IP = {\n['ip-1'] = '10.0.0.1',\n['ip-2'] = '10.0.0.2',\n['ip-3'] = '10.0.0.3',\n}\nfunction setup_pools()\nreturn {\n['BestReputation'] = kumo.make_egress_pool {\nname = 'BestReputation',\nentries = {\n{ name = 'ip-1' },\n},\n},\n['MediumReputation'] = kumo.make_egress_pool {\nname = 'MediumReputation',\nentries = {\n{ name = 'ip-2', weight = 2 },\n-- we're warming up ip-3, so use it less frequently than ip-2\n{ name = 'ip-3', weight = 1 },\n},\n},\n}\nend\nlocal POOLS = setup_pools()\nkumo.on('get_egress_source', function(source_name)\nreturn kumo.make_egress_source {\nname = source_name,\nsource_address = SOURCE_TO_IP[source_name],\n}\nend)\nkumo.on('get_egress_pool', function(pool_name)\nreturn POOLS[pool_name]\nend)\n</code></pre> <p>The weight is used as part of Weighted Round-Robin selection for the source from the pool.</p> <p>If the weights are all equal, or are all left unspecified, then simple round-robin selection of sources will occur.</p> <p>Otherwise, the weight influences how often a given source will be used for traffic originating from this pool.</p> <p>A weight of <code>0</code> is permitted: it is equivalent to not including the associated sources in the list of entries.</p> <p>If weight is left unspecified, it defaults to <code>1</code>.</p>"},{"location":"reference/kumo/make_egress_pool/#ttl","title":"ttl","text":"<p>Optional time-to-live specifying how long the pool definition should be cached.  The cache has two purposes:</p> <ul> <li>To limit the number of configurations kept in memory at any one time</li> <li>To enable data to be refreshed from external storage, such as a json data   file, or a database</li> </ul> <p>The default TTL is 60 seconds, but you can specify any duration using a string like <code>\"5 mins\"</code> to specify 5 minutes.</p>"},{"location":"reference/kumo/make_egress_source/","title":"<code>kumo.make_egress_source {PARAMS}</code>","text":"<p>Defines an egress source, which is an entity associated with the source of outbound traffic from the MTA.  A source must be referenced by a pool to be useful.</p> <p>This function is intended to be used inside your get_egress_source event handler.</p> <p>A source must have at a minimum a name, which will be used in logging/reporting.</p> <p><code>PARAMS</code> is a lua table which may have the following keys:</p>"},{"location":"reference/kumo/make_egress_source/#name","title":"name","text":"<p>Required string.</p> <p>The name of the source.</p> <pre><code>kumo.on('get_egress_source', function(source_name)\n-- Make a source that just has the requested name, but otherwise doesn't\n-- specify any particular source configuration\nreturn kumo.make_egress_source {\nname = source_name,\n}\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_source/#source_address","title":"source_address","text":"<p>Optional string.</p> <p>If set, specifies the local IP address that should be used as the source of any connection that will be made from this source.</p> <p>If not specified, the kernel will select the IP address automatically.</p> <pre><code>kumo.on('get_egress_source', function(source_name)\nif source_name == 'ip-1' then\n-- Make a source that will emit from 10.0.0.1\nreturn kumo.make_egress_source {\nname = 'ip-1',\nsource_address = '10.0.0.1',\n}\nend\nerror 'you need to do something for other source names'\nend)\n</code></pre> <p>Note</p> <p>When using HA Proxy, the <code>source_address</code> will be used when connecting to the proxy. You should use <code>ha_proxy_source_address</code> to specify the actual address to use from the HA Proxy instance to the destination.</p>"},{"location":"reference/kumo/make_egress_source/#ehlo_domain","title":"ehlo_domain","text":"<p>Optional string.</p> <p>If set, specifies the hostname to be passed with the EHLO command when the server connects to a remote host.</p> <p>If not specified, the kernel will use the server's hostname.</p> <p>Note that the <code>ehlo_domain</code> set by make_egress_path, if any, takes precedence over this value.</p> <pre><code>kumo.on('get_egress_source', function(source_name)\nif source_name == 'ip-1' then\n-- Make a source that will emit from 10.0.0.1\nkumo.make_egress_source {\nname = 'ip-1',\nsource_address = '10.0.0.1',\nehlo_domain = 'mta1.examplecorp.com',\n}\nend\nerror 'you need to do something for other source names'\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_source/#remote_port","title":"remote_port","text":"<p>Optional integer.</p> <p>If set, will override the remote SMTP port number. This is useful in scenarios where your network is set to manage the egress address based on port mapping.</p> <p>This option takes precedence over kumo.make_egress_path().smtp_port.</p>"},{"location":"reference/kumo/make_egress_source/#ha_proxy_server","title":"ha_proxy_server","text":"<p>Optional string.</p> <p>If both <code>ha_proxy_server</code> and <code>ha_proxy_source_address</code> are specified, then SMTP connections will be made via an HA Proxy server.</p> <p><code>ha_proxy_server</code> specifies the address and port of the proxy server.</p> <pre><code>kumo.on('get_egress_source', function(source_name)\nif source_name == 'ip-1' then\n-- Make a source that will emit from 10.0.0.1, via a proxy server\nkumo.make_egress_source {\nname = 'ip-1',\nha_proxy_source_address = '10.0.0.1',\nha_proxy_server = '10.0.0.1:5000',\nehlo_domain = 'mta1.examplecorp.com',\n}\nend\nerror 'you need to do something for other source names'\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_source/#ha_proxy_source_address","title":"ha_proxy_source_address","text":"<p>Optional string.</p> <p>Specifies the source address that the HA Proxy server should use when initiating a connection.</p> <p>Note</p> <p>The HA Proxy protocol doesn't provide a mechanism for reporting    whether binding to this address was successful.  From the perspective    of KumoMTA, invalid proxy configuration will appear as a timeout    with no additional context.  We recommend using SOCKS5 instead    of HA proxy, as the SOCKS5 protocol is better suited for outbound    connections.</p>"},{"location":"reference/kumo/make_egress_source/#socks5_proxy_server","title":"socks5_proxy_server","text":"Since: Version 2023.06.22-51b72a83 <p>The functionality described in this section requires version 2023.06.22-51b72a83 of KumoMTA, or a more recent version.</p> <p>Optional string.</p> <p>If both <code>socks5_proxy_server</code> and <code>socks5_proxy_source_address</code> are specified, then SMTP connections will be made via a SOCKS5 Proxy server.</p> <p><code>socks5_proxy_server</code> specifies the address and port of the proxy server.</p> <pre><code>kumo.on('get_egress_source', function(source_name)\nif source_name == 'ip-1' then\n-- Make a source that will emit from 10.0.0.1, via a proxy server\nkumo.make_egress_source {\nname = 'ip-1',\nsocks5_proxy_source_address = '10.0.0.1',\nsocks5_proxy_server = '10.0.0.1:5000',\nehlo_domain = 'mta1.examplecorp.com',\n}\nend\nerror 'you need to do something for other source names'\nend)\n</code></pre>"},{"location":"reference/kumo/make_egress_source/#socks5_proxy_source_address","title":"socks5_proxy_source_address","text":"Since: Version 2023.06.22-51b72a83 <p>The functionality described in this section requires version 2023.06.22-51b72a83 of KumoMTA, or a more recent version.</p> <p>Optional string.</p> <p>Specifies the source address that the SOCKS5 Proxy server should use when initiating a connection.</p>"},{"location":"reference/kumo/make_egress_source/#ttl","title":"ttl","text":"<p>Optional time-to-live specifying how long the source definition should be cached.  The cache has two purposes:</p> <ul> <li>To limit the number of configurations kept in memory at any one time</li> <li>To enable data to be refreshed from external storage, such as a json data   file, or a database</li> </ul> <p>The default TTL is 60 seconds, but you can specify any duration using a string like <code>\"5 mins\"</code> to specify 5 minutes.</p>"},{"location":"reference/kumo/make_listener_domain/","title":"<code>kumo.make_listener_domain {PARAMS}</code>","text":"<p>Make a listener-domain configuration object.</p> <p>The get_listener_domain event expects one of these to be returned to it (or a <code>nil</code> value).</p> <p>A listener-domain contains information that affects whether an incoming SMTP message will be accepted and/or relayed.</p> <p>By default, unless the client is connecting from one of the <code>relay_hosts</code>, relaying is denied.</p> <p><code>PARAMS</code> is a lua table that can accept the keys listed below.</p>"},{"location":"reference/kumo/make_listener_domain/#relay_to","title":"relay_to","text":"<p>Optional boolean. Defaults to <code>false</code>. When set to <code>true</code>, allows relaying mail from anyone, so long as it is addressed to the requested domain.</p> <pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta)\nif domain == 'example.com' then\nreturn kumo.make_listener_domain {\nrelay_to = true,\n}\nend\nend)\n</code></pre>"},{"location":"reference/kumo/make_listener_domain/#enable-relaying-based-on-smtp-authentication","title":"Enable relaying based on SMTP authentication","text":"<p>This example shows how to use the connection metadata information to determine if the current session is authenticated, and use that to govern whether relaying is allowed.</p> <p>In this example, any user is permitted to relay to anywhere:</p> <pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta)\nif conn_meta:get_meta 'authz_id' then\n-- We're authenticated as someone.\n-- Allow relaying\nreturn kumo.make_listener_domain {\nrelay_to = true,\n}\nend\nend)\n</code></pre> <p>A more sophisticated configuration might use a mapping to control which domains are allowed relaying based on the authorization id:</p> <pre><code>local RELAY_BY_DOMAIN = {\n['example.com'] = {\n-- The user scott is permitted to relay to example.com\n['scott'] = true,\n},\n}\nkumo.on('get_listener_domain', function(domain, listener, conn_meta)\nlocal dom_map = RELAY_BY_DOMAIN[domain]\nif dom_map then\nlocal authz_id = conn_meta:get_meta 'authz_id'\nif dom_map[authz_id] then\nreturn kumo.make_listener_domain {\nrelay_to = true,\n}\nend\nend\nend)\n</code></pre>"},{"location":"reference/kumo/make_listener_domain/#log_oob","title":"log_oob","text":"<p>Optional boolean. Defaults to <code>false</code>. When set to <code>true</code>, if the incoming mail is an out-of-band (OOB) bounce report formatted according to RFC 3464, and is addressed to the requested domain, the message will be accepted and logged to the delivery logs.</p> <pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta)\nif domain == 'bounce.example.com' then\nreturn kumo.make_listener_domain {\nlog_oob = true,\n}\nend\nend)\n</code></pre>"},{"location":"reference/kumo/make_listener_domain/#log_arf","title":"log_arf","text":"<p>Optional boolean. Defaults to <code>false</code>. When set to <code>true</code>, if the incoming mail is an ARF feedback report formatted according to RFC 5965, and is addressed to the requested domain, the message will be accepted and logged to the delivery logs.</p> <pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta)\nif domain == 'fbl.example.com' then\nreturn kumo.make_listener_domain {\nlog_arf = true,\n}\nend\nend)\n</code></pre>"},{"location":"reference/kumo/make_listener_domain/#relay_from","title":"relay_from","text":"<p>Optional CIDR list. Defaults to an empty list. If the connected client is from an IP address that matches the CIDR list, and the sending domain matches the requested domain, then relaying will be allowed.</p> <pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta)\nif domain == 'send.example.com' then\nreturn kumo.make_listener_domain {\nrelay_from = { '10.0.0.0/24' },\n}\nend\nend)\n</code></pre>"},{"location":"reference/kumo/make_queue_config/","title":"<code>kumo.make_queue_config { PARAMS }</code>","text":"<p>Constructs a configuration object that specifies how a queue will behave.</p> <p>This function should be called from the get_queue_config event handler to provide the configuration for the requested queue.</p> <p>The following keys are possible:</p>"},{"location":"reference/kumo/make_queue_config/#egress_pool","title":"egress_pool","text":"<p>The name of the egress pool which should be used as the source of this traffic.</p> <p>If you do not specify an egress pool, a default pool named <code>unspecified</code> will be used. That pool contains a single source named <code>unspecified</code> that has no specific source settings: it will just make a connection using whichever IP the kernel chooses.</p> <p>See kumo.make_egress_pool().</p>"},{"location":"reference/kumo/make_queue_config/#max_age","title":"max_age","text":"<p>Limits how long a message can remain in the queue. The default value is <code>\"7 days\"</code>.</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nreturn kumo.make_queue_config {\n-- Age out messages after being in the queue for 20 minutes\nmax_age = '20 minutes',\n}\nend)\n</code></pre>"},{"location":"reference/kumo/make_queue_config/#max_retry_interval","title":"max_retry_interval","text":"<p>Messages are retried using an exponential backoff as described under retry_interval below. max_retry_interval sets an upper bound on the amount of time between delivery attempts.</p> <p>The default is that there is no upper limit.</p> <p>The value is expressed in seconds.</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nreturn kumo.make_queue_config {\n-- Retry at most every hour\nmax_retry_interval = '1 hour',\n}\nend)\n</code></pre>"},{"location":"reference/kumo/make_queue_config/#protocol","title":"protocol","text":"<p>Configure the delivery protocol. The default is to use SMTP to the domain associated with the queue, but you can also configure delivering to a local maildir, or using custom lua code to process a message</p>"},{"location":"reference/kumo/make_queue_config/#example-of-smart-hosting-with-the-smtp-protocol","title":"Example of smart-hosting with the SMTP protocol","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Rather than relying on MX resolution, you can provide an explicit list of MX host names or IP addresses to which the queue should deliver. The addresses will be tried in the order specified.</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nif domain == 'smarthost.example.com' then\n-- Relay via some other internal infrastructure.\n-- Enclose IP (or IPv6) addresses in `[]`.\n-- Otherwise the name will be resolved for A and AAAA records\nreturn kumo.make_queue_config {\nprotocol = {\nsmtp = {\nmx_list = {\n'smart.host.local',\n{ name = 'mx.example.com', addr = '10.0.0.1' },\n},\n},\n},\n}\nend\n-- Otherwise, just use the defaults\nreturn kumo.make_queue_config {}\nend)\n</code></pre>"},{"location":"reference/kumo/make_queue_config/#example-of-using-the-maildir-protocol","title":"Example of using the Maildir protocol","text":"<pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nif domain == 'maildir.example.com' then\n-- Store this domain into a maildir, rather than attempting\n-- to deliver via SMTP\nreturn kumo.make_queue_config {\nprotocol = {\nmaildir_path = '/var/tmp/kumo-maildir',\n},\n}\nend\n-- Otherwise, just use the defaults\nreturn kumo.make_queue_config {}\nend)\n</code></pre> <p>Note</p> <p>Maildir support is present primarily for functional validation rather than being present as a first class delivery mechanism.</p> <p>Failures to write to the maildir will cause the message to be delayed and retried approximately 1 minute later.  The normal message retry schedule does not apply.</p>"},{"location":"reference/kumo/make_queue_config/#using-lua-as-a-delivery-protocol","title":"Using Lua as a delivery protocol","text":"<pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nif domain == 'webhook' then\n-- Use the `make.webhook` event to handle delivery\n-- of webhook log records\nreturn kumo.make_queue_config {\nprotocol = {\ncustom_lua = {\n-- this will cause an event called `make.webhook` to trigger.\n-- You can pick any name for this event, so long as it doesn't\n-- collide with a pre-defined event, and so long as you bind\n-- to it with a kumo.on call\nconstructor = 'make.webhook',\n},\n},\n}\nend\nreturn kumo.make_queue_config {}\nend)\n-- This event will be called each time we need to make a connection.\n-- It needs to return a lua object with a `send` method\nkumo.on('make.webhook', function(domain, tenant, campaign)\n-- Create the connection object\nlocal connection = {}\n-- define a send method on the connection object.\n-- The return value is the disposition string for a successful\n-- delivery; that string will get logged in the resulting log record.\n-- If the delivery failed, you can use `kumo.reject` to raise the\n-- error with an appropriate 400 or 500 code.\n-- 400 codes will be retried later. 500 codes will log a permanent\n-- failure and no further delivery attempts will be made for the message.\nfunction connection:send(message)\nprint(message:get_data())\nif failed then\nkumo.reject(400, 'failed for some reason')\nend\nreturn 'OK'\nend\nreturn connection\nend)\n</code></pre> <p>See should_enqueue_log_record for a more complete example.</p>"},{"location":"reference/kumo/make_queue_config/#retry_interval","title":"retry_interval","text":"<p>Messages are retried using an exponential backoff.  retry_interval sets the base interval; if a message cannot be immediately delivered and encounters a transient failure, then a (jittered) delay of retry_interval seconds will be applied before trying again. If it transiently fails a second time, retry_interval will be doubled and so on, doubling on each attempt.</p> <p>The default is <code>\"20 minutes\"</code>.</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nreturn kumo.make_queue_config {\nretry_interval = '20 minutes',\n}\nend)\n</code></pre>"},{"location":"reference/kumo/memoize/","title":"<code>kumo.memoize(FUNCTION, {PARAMS})</code>","text":"<p>This function allows you to create functions that cache the result of a computation.  This technique is known as Memoization.</p> <p>Here's a simple example; we have a sqlite lookup database that we intend to use for authentication, and we have already defined a helper function for that:</p> <pre><code>local sqlite = require 'sqlite'\n-- Consult a hypothetical sqlite database that has an auth table\n-- with user and pass fields\nfunction sqlite_auth_check(user, password)\nlocal db = sqlite.open '/path/to/auth.db'\nlocal result = db:execute(\n'select user from auth where user=? and pass=?',\nuser,\npassword\n)\n-- if we return the username, it is because the password matched\nreturn result[1] == user\nend\nkumo.on('smtp_server_auth_plain', function(authz, authc, password)\nreturn sqlite_auth_check(authc, password)\nend)\n</code></pre> <p>Let's say, for the sake of example, that the query is very expensive: perhaps the IO cost is high and the query rate is also high and we want to save the iops for other work in the system.</p> <p>It would be nice if we could cache the lookup for some period of time. We can use <code>kumo.memoize</code> for this:</p> <pre><code>local sqlite = require 'sqlite'\nfunction sqlite_auth_check(user, password)\nlocal db = sqlite.open '/tmp/auth.db'\nlocal result = db:execute(\n'select user from auth where user=? and pass=?',\nuser,\npassword\n)\n-- if we return the username, it is because the password matched\nreturn result[1] == user\nend\n-- This creates a new function called `cached_sqlite_auth_check`\n-- that remembers the results for a given set of parameters for up\n-- to 5 minutes or up to 100 different sets of parameters\ncached_sqlite_auth_check = kumo.memoize(sqlite_auth_check, {\nname = 'sqlite_auth',\nttl = '5 minutes',\ncapacity = 100,\n})\nkumo.on('smtp_server_auth_plain', function(authz, authc, password)\nreturn cached_sqlite_auth_check(authc, password)\nend)\n</code></pre> <p><code>kumo.memoize</code> takes a function or a lambda and wraps it up with some logic that will internally cache the result for the same set of parameters, and returns a new function that encodes that caching logic.  The return value is the memoized function.</p> <p>The parameters it accepts are:</p> <ul> <li>FUNCTION - the function or lambda which will be called when there is a cache miss.   When it is called, it will be passed the parameters that were passed to the memoized function.</li> <li>PARAMS is a required lua table with the following fields, all of which are required:<ul> <li><code>name</code> - the name for the cache. You should create one name per function/purpose.</li> <li><code>ttl</code> - the Time To Live for cache entries; how long a previously computed    value should remain valid.  The duration is expressed as a string like <code>5    minutes</code> or <code>10 seconds</code>.</li> <li><code>capacity</code> - the total number of results to retain in the cache. When a new    entry needs to be inserted, if the cache is at capacity, the eldest entry    will be evicted to make space.</li> </ul> </li> </ul> <p>In the example above calling:</p> <pre><code>cached_sqlite_auth_check('scott', 'tiger')\n</code></pre> <p>the first time would be a cache miss, because no calls have yet been made with <code>{'scott', 'tiger'}</code> as parameters, so the memoized function would internally call:</p> <pre><code>sqlite_auth_check('scott', 'tiger')\n</code></pre> <p>The next time that <code>cached_sqlite_auth_check('scott', 'tiger')</code> is called there is a cache hit and the previously computed result would be returned, provided that 5 minutes have not expired since the first call.</p> <p>When the value expires, another call to <code>sqlite_auth_check('scott', 'tiger')</code> will be made to determine the value.</p>"},{"location":"reference/kumo/on/","title":"<code>kumo.on(EVENT, FUNCTION)</code>","text":"<p>Register a handler for a named event.</p> <p><code>EVENT</code> can be any string, and <code>FUNCTION</code> can be any lua function or closure.</p> <p>Only the most recently registered function for a given event will be used.</p> <p>The possible events are listed in the events reference.</p>"},{"location":"reference/kumo/reject/","title":"<code>kumo.reject(CODE, MESSAGE)</code>","text":"<p>Calling <code>kumo.reject</code> will raise a lua error that will cause the current ESMTP event to respond with the SMTP error code and message that you specify.</p> <pre><code>kumo.on('smtp_server_mail_from', function(sender)\nkumo.reject(420, 'rejecting all mail, just because')\n-- this line is not reached\nend)\n</code></pre>"},{"location":"reference/kumo/set_diagnostic_log_filter/","title":"<code>kumo.set_diagnostic_log_filter(FILTER)</code>","text":"<p>Changes the filtering configuration for the diagnostic log.</p> <p>KumoMTA uses the tracing-subscriber Rust crate to provide diagnostic logging.  This can be configured via the <code>KUMOD_LOG</code> environment to set the logging for the process when it first starts up, but can also be adjusted via your policy file by calling <code>kumo.set_diagnostic_log_filter</code> if you wish.</p> <p>The default log filter that is set at startup is <code>kumod=info</code> which causes all informational logging from the <code>kumod</code> crate (the main KumoMTA server process) to be logged.</p> <p>If you want more verbose diagnostics, you might consider changing it from inside your <code>init</code> event handler:</p> <pre><code>kumo.on('init', function()\nkumo.set_diagnostic_log_filter 'kumod=debug'\nend)\n</code></pre> <p>The filter syntax is quite powerful, allowing you set different levels for different crates.  The full set of filter directives are explained here.</p>"},{"location":"reference/kumo/set_max_lua_context_age/","title":"<code>kumo.set_max_lua_context_age(seconds)</code>","text":"<p>KumoMTA maintains a pool of lua contexts so that the overhead of evaluating lua for any given event handler is reduced.</p> <p>This function allows you to change the maximum age of any given context, measured in seconds, before discarding it.</p> <p>The default value is <code>300</code> (5 minutes).</p> <p>Making it larger increases the potential for cache hits (and thus lower latency), but increases the potential for increased memory usage.</p> <p>See also set_max_lua_context_use_count, set_max_spare_lua_contexts</p>"},{"location":"reference/kumo/set_max_lua_context_use_count/","title":"<code>kumo.set_max_lua_context_use_count(limit)</code>","text":"<p>KumoMTA maintains a pool of lua contexts so that the overhead of evaluating lua for any given event handler is reduced.</p> <p>This function allows you to change the maximum number of times that any given context will be used before discarding it.</p> <p>The default value is <code>1024</code>.</p> <p>Making it larger increases the potential for cache hits (and thus lower latency), but increases the potential for increased memory usage.</p> <p>See also set_max_lua_context_age, set_max_spare_lua_contexts</p>"},{"location":"reference/kumo/set_max_spare_lua_contexts/","title":"<code>kumo.set_max_spare_lua_contexts(limit)</code>","text":"<p>KumoMTA maintains a pool of lua contexts so that the overhead of evaluating lua for any given event handler is reduced.</p> <p>This function allows you to change the maximum capacity of that pool.</p> <p>The default value is <code>8192</code>.</p> <p>Make it smaller reduces the amount of memory used while idle, at the cost of increased latency when the server becomes busy.</p> <p>See also set_max_lua_context_use_count, set_max_lua_context_age.</p>"},{"location":"reference/kumo/start_esmtp_listener/","title":"<code>kumo.start_esmtp_listener {PARAMS}</code>","text":"<p>Configure and start ESMTP service.</p> <p>This function should be called only from inside your init event handler.</p> <p><code>PARAMS</code> is a lua table that can accept the keys listed below.</p> <p>To listen on multiple IP/port combinations, simply call <code>kump.start_esmtp_listener</code> multiple times with the appropriate parameters.</p> <pre><code>kumo.on('init', function()\n-- use the same settings for ports 25 and 2026, without repeating them all\nfor _, port in ipairs { 25, 2026 } do\nkumo.start_esmtp_listener {\nlisten = '0:' .. tostring(port),\nrelay_hosts = { '0.0.0.0/0' },\n}\nend\nend)\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/#banner","title":"banner","text":"<p>Customize the banner that is returned to clients when they first connect. The configured hostname will be automatically prepended to this text, so you should not include a hostname.</p> <pre><code>kumo.start_esmtp_listener {\n-- ..\nbanner = 'Welcome to KumoMTA!',\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/#client_timeout","title":"client_timeout","text":"<p>Controls the timeout used when reading data from the client. If no data arrives within the specified timeout, the server will close the connection to the client.</p> <pre><code>kumo.start_esmtp_listener {\n-- The default is 1 minute\nclient_timeout = '1 minute',\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/#data_buffer_size","title":"data_buffer_size","text":"<p>Specified the size of the buffer used to read chunks of the message payload during the <code>DATA</code> phase of the SMTP transaction.  Making this larger will improve the throughput in terms of bytes-per-syscall at the expense of using more RAM.</p> <p>The default size is 128KB (<code>128 * 1024</code>).  If your average message size is significantly larger than the default, then you may wish to increase this value.</p>"},{"location":"reference/kumo/start_esmtp_listener/#deferred_spool","title":"deferred_spool","text":"<p>Danger</p> <p>Enabling this option may result in loss of accountability for messages. You should satisfy yourself that your system is able to recognize and deal with that scenario if/when it arises.</p> <p>When set to <code>true</code>, incoming messages are retained in memory until after their first transient delivery failure.</p> <p>This can have a dramatic impact on throughput by removing local storage I/O as a bottleneck, but introduces a risk of forgetting about those messages if the machine loses power or if the kumod process exits unexpectedly.</p> <pre><code>kumo.start_esmtp_listener {\n-- ..\ndeferred_spool = false,\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/#hostname","title":"hostname","text":"<p>Specifies the hostname to report in the banner and other SMTP responses. The default, if unspecified, is to use the hostname of the local machine.</p> <pre><code>kumo.start_esmtp_listener {\n-- ..\nhostname = 'mail.example.com',\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/#invalid_line_endings","title":"invalid_line_endings","text":"<p>Since: Version 2023.11.28-b5252a41</p> <p>The functionality described in this outlined box requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>Specifies the behavior when the received DATA contains invalid line endings.  The SMTP protocol requires that each line of the DATA be separated by canonical CRLF sequences. Immediately after receiving the DATA payload, but before any other policy events are triggered, if the received DATA is non-conforming the value of this parameter is checked to determine what to do. It has three possible values:</p> <ul> <li><code>\"Deny\"</code> - this is the default. The incoming message will be   rejected.</li> <li><code>\"Allow\"</code> - The incoming message will be accepted. Depending   on the configured policy, some later policy actions may fail   to parse the message, and DKIM signatures may be created that   are not possible to validate correctly.  There is no guarantee   that any resulting message will be routable to its intended   destination.</li> <li><code>\"Fix\"</code> - the line endings will be normalized to CRLF and the   message will be accepted.  It's possible for this to invalidate   any signatures that may have already been present in the message.</li> </ul>"},{"location":"reference/kumo/start_esmtp_listener/#line_length_hard_limit","title":"line_length_hard_limit","text":"<p>Since: Version 2023.11.28-b5252a41</p> <p>The functionality described in this outlined box requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>The SMTP protocol specification defines the maximum length of a line in the protocol.  The limit exists because there are SMTP implementations that are simply not capable of reading longer lines.</p> <p>This option sets the limit on line length that is enforced by KumoMTA. The default matches the RFC specified limit of <code>998</code>.  When the line length limit is exceeded, KumoMTA will return a \"line too long\" error to the client.</p> <p>You can raise this limit, but doing so may allow messages to be accepted that will be unable to be relayed to other SMTP implementations.</p>"},{"location":"reference/kumo/start_esmtp_listener/#listen","title":"listen","text":"<p>Specifies the local IP and port number to which the ESMTP service should bind and listen.</p> <p>Use <code>0.0.0.0</code> to bind to all IPv4 addresses.</p> <pre><code>kumo.start_esmtp_listener {\nlisten = '0.0.0.0:25',\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/#max_messages_per_connection","title":"max_messages_per_connection","text":"<p>Specifies the maximum number of consecutive <code>MAIL FROM</code> commands that can be issued for a given SMTP connection.  When the limit is reached, transient failures will be returned to those additional <code>MAIL FROM</code> commands.</p> <pre><code>kumo.start_esmtp_listener {\nmax_messages_per_connection = 10000,\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/#max_message_size","title":"max_message_size","text":"<p>Specifies the maximum size of a message that can be relayed through this listener, in bytes.</p> <p>The default is <code>20 MB</code> (<code>20 * 1024 * 1024</code>).</p> <p>Messages exceeding this size will be rejected.</p>"},{"location":"reference/kumo/start_esmtp_listener/#max_recipients_per_message","title":"max_recipients_per_message","text":"<p>Specifies the maximum number of consecutive <code>RCPT TO</code> commands that can be issued for a given SMTP transaction.  When the limit is reached, transient failures will be returned to those additional <code>RCPT TO</code> commands.</p> <pre><code>kumo.start_esmtp_listener {\nmax_recipients_per_message = 1024,\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/#relay_hosts","title":"relay_hosts","text":"<p>Specify the hosts which are allowed to relay email via this ESMTP service. Each item can be an IP literal or a CIDR mask. Note that the CIDR notation  is strict, so that 192.168.1.0/24 is valid but 192.168.1.1/24 is not because  that final octet isn\u2019t valid in a /24.</p> <p>The defaults are to allow relaying only from the local host:</p> <pre><code>kumo.start_esmtp_listener {\n-- ..\nrelay_hosts = { '127.0.0.1', '::1' },\n}\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/#tls_certificate","title":"tls_certificate","text":"<p>Specify the path to a TLS certificate file to use for the server identity when the client issues <code>STARTTLS</code>.</p> <p>The default, if unspecified, is to dynamically allocate a self-signed certificate.</p> <pre><code>kumo.start_esmtp_listener {\n-- ..\ntls_certificate = '/path/to/cert.pem',\n}\n</code></pre> <p>You may specify that the certificate be loaded from a HashiCorp Vault:</p> <pre><code>kumo.start_esmtp_listener {\n-- ..\ntls_certificate = {\nvault_mount = 'secret',\nvault_path = 'tls/mail.example.com.cert',\n-- Specify how to reach the vault; if you omit these,\n-- values will be read from $VAULT_ADDR and $VAULT_TOKEN\n-- vault_address = \"http://127.0.0.1:8200\"\n-- vault_token = \"hvs.TOKENTOKENTOKEN\"\n},\n}\n</code></pre> <p>The key must be stored as <code>key</code> (even though this is a certificate!) under the <code>path</code> specified.  For example, you might populate it like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com.cert key=@mail.example.com.cert\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/#tls_private_key","title":"tls_private_key","text":"<p>Specify the path to the TLS private key file that corresponds to the <code>tls_certificate</code>.</p> <p>The default, if unspecified, is to dynamically allocate a self-signed certificate.</p> <pre><code>kumo.start_esmtp_listener {\n-- ..\ntls_private_key = '/path/to/key.pem',\n}\n</code></pre> <p>You may specify that the key be loaded from a HashiCorp Vault:</p> <pre><code>kumo.start_esmtp_listener {\n-- ..\ntls_private_key = {\nvault_mount = 'secret',\nvault_path = 'tls/mail.example.com.key',\n-- Specify how to reach the vault; if you omit these,\n-- values will be read from $VAULT_ADDR and $VAULT_TOKEN\n-- vault_address = \"http://127.0.0.1:8200\"\n-- vault_token = \"hvs.TOKENTOKENTOKEN\"\n},\n}\n</code></pre> <p>The key must be stored as <code>key</code> under the <code>path</code> specified. For example, you might populate it like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com key=@mail.example.com.key\n</code></pre>"},{"location":"reference/kumo/start_esmtp_listener/#trace_headers","title":"trace_headers","text":"<p>Controls the addition of tracing headers to received messages.</p> <p>KumoMTA can add two different headers to aid in later tracing:</p> <ul> <li>The standard <code>\"Received\"</code> header which captures SMTP relay hops on their path to the inbox</li> <li>A supplemental header which can be used to match feedback reports back to the   originating mailing</li> </ul> <p>Prior to triggering the smtp_server_message_received event the standard <code>\"Received\"</code> header will be added to the message.  Then, once the event completes and your policy has had the opportunity to alter the meta data associated with the message, the supplemental header will be added.</p> <pre><code>kumo.start_esmtp_listener {\n-- ..\ntrace_headers = {\n-- this is the default: add the Received: header\nreceived_header = true,\n-- this is the default: add the supplemental header\nsupplemental_header = true,\n-- this is the default: the name of the supplemental header\nheader_name = 'X-KumoRef',\n-- names of additional meta data fields\n-- to include in the header. TAKE CARE! The header will be\n-- base64 encoded to prevent casual introspection, but the\n-- header is NOT encrypted and the values of the meta data\n-- fields included here should be considered to be public.\n-- The default is not to add any meta data fields, but you\n-- might consider setting something like:\n-- include_meta_names = { 'tenant', 'campaign' },\ninclude_meta_names = {},\n},\n}\n</code></pre> <p>Here's an example of a supplemental header from a message:</p> <pre><code>X-KumoRef: eyJfQF8iOiJcXF8vIiwicmVjaXBpZW50IjoidGVzdEBleGFtcGxlLmNvbSJ9\n</code></pre> <p>the decoded payload contains a magic marker key as well as the recipient of the original message:</p> <pre><code>{\"_@_\":\"\\\\_/\",\"recipient\":\"test@example.com\"}\n</code></pre> <p>Any meta data fields that were listed in <code>include_meta_names</code>, if the corresponding meta data was set in the message, would also be captured in the decoded payload.</p> <p>KumoMTA will automatically extract this supplemental trace header information from any <code>X-</code> header that is successfully parsed and has the magic marker key when processing the original message payload of an incoming ARF report.</p>"},{"location":"reference/kumo/start_http_listener/","title":"<code>kumo.start_http_listener { PARAMS }</code>","text":"<p>Configure and start HTTP service.</p> <p>This function should be called only from inside your init event handler.</p> <p><code>PARAMS</code> is a lua table that can accept the keys listed below.</p>"},{"location":"reference/kumo/start_http_listener/#hostname","title":"hostname","text":"<p>Specifies the hostname to use when configuring TLS. The default, if unspecified, is to use the hostname of the local machine.</p> <pre><code>kumo.start_http_listener {\n-- ..\nhostname = 'mail.example.com',\n}\n</code></pre>"},{"location":"reference/kumo/start_http_listener/#listen","title":"listen","text":"<p>Specifies the local IP and port number to which the HTTP service should bind and listen.</p> <p>Use <code>0.0.0.0</code> to bind to all IPv4 addresses.</p> <pre><code>kumo.start_http_listener {\nlisten = '0.0.0.0:80',\n}\n</code></pre>"},{"location":"reference/kumo/start_http_listener/#tls_certificate","title":"tls_certificate","text":"<p>Specify the path to a TLS certificate file to use for the server identity when use_tls is set to <code>true</code>.</p> <p>The default, if unspecified, is to dynamically allocate a self-signed certificate.</p> <pre><code>kumo.start_http_listener {\n-- ..\ntls_certificate = '/path/to/cert.pem',\n}\n</code></pre> <p>You may specify that the certificate be loaded from a HashiCorp Vault:</p> <pre><code>kumo.start_http_listener {\n-- ..\ntls_certificate = {\nvault_mount = 'secret',\nvault_path = 'tls/mail.example.com.cert',\n-- Specify how to reach the vault; if you omit these,\n-- values will be read from $VAULT_ADDR and $VAULT_TOKEN\n-- vault_address = \"http://127.0.0.1:8200\"\n-- vault_token = \"hvs.TOKENTOKENTOKEN\"\n},\n}\n</code></pre> <p>The key must be stored as <code>key</code> (even though this is a certificate!) under the <code>path</code> specified.  For example, you might populate it like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com.cert key=@mail.example.com.cert\n</code></pre>"},{"location":"reference/kumo/start_http_listener/#tls_private_key","title":"tls_private_key","text":"<p>Specify the path to the TLS private key file that corresponds to the <code>tls_certificate</code>.</p> <p>The default, if unspecified, is to dynamically allocate a self-signed certificate.</p> <pre><code>kumo.start_http_listener {\n-- ..\ntls_private_key = '/path/to/key.pem',\n}\n</code></pre> <p>You may specify that the key be loaded from a HashiCorp Vault:</p> <pre><code>kumo.start_http_listener {\n-- ..\ntls_private_key = {\nvault_mount = 'secret',\nvault_path = 'tls/mail.example.com.key',\n-- Specify how to reach the vault; if you omit these,\n-- values will be read from $VAULT_ADDR and $VAULT_TOKEN\n-- vault_address = \"http://127.0.0.1:8200\"\n-- vault_token = \"hvs.TOKENTOKENTOKEN\"\n},\n}\n</code></pre> <p>The key must be stored as <code>key</code> under the <code>path</code> specified. For example, you might populate it like this:</p> <pre><code>$ vault kv put -mount=secret tls/mail.example.com key=@mail.example.com.key\n</code></pre>"},{"location":"reference/kumo/start_http_listener/#trusted_hosts","title":"trusted_hosts","text":"<p>Specify the hosts which are trusted to access the HTTP service. Each item can be an IP literal or a CIDR mask.</p> <p>The defaults are to allow the local host.</p> <pre><code>kumo.start_http_listener {\n-- ..\ntrusted_hosts = { '127.0.0.1', '::1' },\n}\n</code></pre>"},{"location":"reference/kumo/start_http_listener/#use_tls","title":"use_tls","text":"<p>If true, the listener will start with TLS enabled and require clients to use <code>https</code>.</p>"},{"location":"reference/kumo/toml_encode/","title":"<code>kumo.toml_encode(VALUE)</code>","text":"<p>Attempts to encode VALUE as its TOML equivalent, and returns that value serialized as a string.</p> <p>This is logically the opposite of kumo.toml_parse.</p> <p>See also kumo.toml_load, kumo.toml_parse and kumo.toml_encode_pretty</p>"},{"location":"reference/kumo/toml_encode_pretty/","title":"<code>kumo.toml_encode_pretty(VALUE)</code>","text":"<p>Attempts to encode VALUE as its TOML equivalent, and returns that value serialized as a string, using pretty, more human readable representation.</p> <p>This is logically the opposite of kumo.toml_parse.</p> <p>See also kumo.toml_load, kumo.toml_parse and kumo.toml_encode</p>"},{"location":"reference/kumo/toml_load/","title":"<code>kumo.toml_load(FILENAME)</code>","text":"<p>Reads the content of the file name <code>FILENAME</code> and parses it as TOML, returning a lua representation of the parsed TOML.</p> <p>See also kumo.toml_parse, kumo.toml_encode and kumo.toml_encode_pretty</p>"},{"location":"reference/kumo/toml_parse/","title":"<code>kumo.toml_parse(STRING)</code>","text":"<p>Parses STRING as TOML, returning a lua representation of the parsed TOML.</p> <p>This is logically the opposite of kumo.toml_encode.</p> <p>See also kumo.toml_load, kumo.toml_encode and kumo.toml_encode_pretty</p>"},{"location":"reference/kumo.amqp/","title":"Module <code>kumo.amqp</code>","text":"<p>This module provides AMQP/RabbitMQ client functionality.</p>"},{"location":"reference/kumo.amqp/#available-functions","title":"Available Functions","text":"<ul> <li>build_client</li> </ul>"},{"location":"reference/kumo.amqp/build_client/","title":"<code>kumo.amqp.build_client(URI)</code>","text":"<p>Constructs an AMQP client object.</p> <p><code>URI</code> is the URI that references the AMQP server to which you want to connect.</p> <pre><code>local client = kumo.amqp.build_client 'amqp://localhost'\nlocal confirm = client:publish {\nrouting_key = 'hello',\npayload = 'w00t!',\n}\nlocal result = confirm:wait()\nassert(result.status == 'NotRequested')\n</code></pre>"},{"location":"reference/kumo.amqp/build_client/#client-methods","title":"Client Methods","text":"<p>The returned client object has the following methods:</p>"},{"location":"reference/kumo.amqp/build_client/#clientpublishparams","title":"client:publish({PARAMS})","text":"<p>Publishes a message. <code>PARAMS</code> is an object style table with the following keys:</p> <ul> <li><code>routing_key</code> - required string; the name of the queue to which to send the message</li> <li><code>payload</code> - required string; the message to send</li> <li><code>exchange</code> - optional string; the exchange through which to send the message.   If unspecified, the empty string is used, which corresponds to a default   exchange.</li> </ul> <p>Returns a confirmation object that can be used to await the final disposition of the send.  That confirmation object has a single <code>wait</code> method which returns a confirmation object with the following fields:</p> <ul> <li><code>status</code> - one of <code>\"NotRequested\"</code>, <code>\"Ack\"</code>, or <code>\"Nack\"</code> depending on the   disposition of the message delivery attempt.</li> <li><code>reply_code</code> - may be nil, but is otherwise a status code from the ack   returned from the queue machinery.</li> <li><code>reply_text</code> - may be nil, but is otherwise status text from the ack   returned from the queue machinery.</li> </ul> <pre><code>local client = kumo.amqp.build_client 'amqp://localhost'\nlocal confirm = client:publish {\nrouting_key = 'hello',\npayload = 'w00t!',\n}\nlocal result = confirm:wait()\nassert(result.status == 'NotRequested')\n</code></pre>"},{"location":"reference/kumo.cidr/","title":"Module <code>kumo.cidr</code>","text":"<p>This module provides functions that help working with CIDR blocks and maps</p>"},{"location":"reference/kumo.cidr/#available-functions","title":"Available Functions","text":"<ul> <li>make_map</li> </ul>"},{"location":"reference/kumo.cidr/make_map/","title":"<code>kumo.cidr.make_map([{MAP}])</code>","text":"<p>Create a new CIDR map, optionally seeded with an initial set of key/value pairs.</p> <p>A CIDR map is a dictionary type that allows resolving the value associated with an IP address key, supporting matches based on CIDR blocks in the mapping.</p> <p>For simple inputs, the mapping behaves as you might expect for a dictionary type:</p> <pre><code>local cmap = kumo.cidr.make_map()\ncmap['127.0.0.1'] = 'bar'\nassert(cmap['127.0.0.1'] == 'bar')\nassert(cmap['not.set'] == nil)\n</code></pre> <p>you can define keys based on net blocks using CIDR notation:</p> <pre><code>local cmap = kumo.cidr.make_map()\ncmap['10.0.0.0/24'] = '10. block'\n-- any address in that /24 will return the mapped value\nassert(cmap['10.0.0.1'] == '10. block')\nassert(cmap['10.0.0.42'] == '10. block')\n-- other addresses won't\nassert(cmap['100.0.0.100'] == nil)\n</code></pre> <p>You may seed an initial value from a pre-existing lua table:</p> <pre><code>local cmap = kumo.cidr.make_map {\n['127.0.0.0/24'] = 'loopback',\n['10.0.0.0/24'] = 'lan',\n}\n-- and mutate the table after is has been constructed:\ncmap['4.2.4.2'] = 4242\n</code></pre> <p>Keys to the map are IPv4 or IPv6 addresses, but for convenience, domain literals and IP and port number combinations such as <code>\"127.0.0.1:25\"</code>, <code>\"[127.0.0.1]\"</code> <code>\"[::1]:25\"</code> are understood to facilitate more ergonomic use in policy:</p> <pre><code>local SOURCE_CLASSIFICATION = kumo.cidr.make_map {\n['127.0.0.0/24'] = 'loopback',\n['10.0.0.0/24'] = 'lan',\n}\nkumo.on('smtp_server_message_received', function(msg)\nlocal source_type = SOURCE_CLASSIFICATION[msg:get_meta 'received_from']\nend)\n</code></pre>"},{"location":"reference/kumo.digest/","title":"Module <code>kumo.digest</code>","text":"<p>This module provides functions for hashing/digesting data.</p>"},{"location":"reference/kumo.digest/#the-digest-object","title":"The Digest Object","text":"<p>The functions in this module return a <code>Digest</code> object.</p> <p>Printing or otherwise explicitly converting a <code>Digest</code> object as a string will produce the digest bytes encoded in hex.</p> <p>The following fields are available to return the bytes encoded in various ways.</p> <ul> <li><code>bytes</code> - returns the data as a binary byte string. This is the most compact representation, but is difficult to pass into other systems without encoding in some way. Case sensitive.</li> <li><code>hex</code> - returns the data encoded as lowercase hexadecimal. This is the largest representation. Case insensitive.</li> <li><code>base32</code> - returns the data encoded as base32. Case insensitive.</li> <li><code>base32_nopad</code> - same as <code>base32</code>, but does not include padding characters.</li> <li><code>base32hex</code> - returns the data encoded as base32hex. This is similar to <code>base32</code>, but the encoded version preserve the sort order of the input data. Case insensitive.</li> <li><code>base32hex_nopad</code> - same as <code>base32hex</code>, but does not include padding characters.</li> <li><code>base64</code> - returns the data encoded as base64. Case sensitive.</li> <li><code>base64_nopad</code> - same as <code>base64</code>, but does not include padding characters.</li> <li><code>base64url</code> - returns the data encoded as base64, with a URL-safe alphabet. Case sensitive.</li> <li><code>base64url_nopad</code> - same as <code>base64url</code>, but does not include padding characters.</li> </ul> <pre><code>-- Compute the digest of 'hello'\nlocal d = kumo.digest.sha1 'hello'\n-- Demonstrate the various output properties of the digest object\nassert(tostring(d) == d.hex)\nassert(d.hex == 'aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d')\nassert(\nd.bytes\n== '\\xaa\\xf4\\xc6\\x1d\\xdc\\xc5\\xe8\\xa2\\xda\\xbe\\xde\\x0f\\x3b\\x48\\x2c\\xd9\\xae\\xa9\\x43\\x4d'\n)\nassert(d.base32 == 'VL2MMHO4YXUKFWV63YHTWSBM3GXKSQ2N')\nassert(d.base32_nopad == 'VL2MMHO4YXUKFWV63YHTWSBM3GXKSQ2N')\nassert(d.base32hex == 'LBQCC7ESONKA5MLURO7JMI1CR6NAIGQD')\nassert(d.base64 == 'qvTGHdzF6KLavt4PO0gs2a6pQ00=')\nassert(d.base64_nopad == 'qvTGHdzF6KLavt4PO0gs2a6pQ00')\nassert(d.base64url == 'qvTGHdzF6KLavt4PO0gs2a6pQ00=')\nassert(d.base64url_nopad == 'qvTGHdzF6KLavt4PO0gs2a6pQ00')\n</code></pre>"},{"location":"reference/kumo.digest/#available-functions","title":"Available Functions","text":"<ul> <li>sha1</li> <li>sha256</li> <li>sha384</li> <li>sha512</li> <li>sha512_256</li> </ul>"},{"location":"reference/kumo.digest/sha1/","title":"<code>kumo.digest.sha1(ARGS)</code>","text":"<p>Computes a SHA1 digest over each of the arguments in ARGS.</p> <p>Note</p> <p>SHA1 is a deprecated algorithm that is no longer recommended for cryptographic usage.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/sha256/","title":"<code>kumo.digest.sha256(ARGS)</code>","text":"<p>Computes a SHA256 digest over each of the arguments in ARGS.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/sha384/","title":"<code>kumo.digest.sha384(ARGS)</code>","text":"<p>Computes a SHA384 digest over each of the arguments in ARGS.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/sha512/","title":"<code>kumo.digest.sha512(ARGS)</code>","text":"<p>Computes a SHA512 digest over each of the arguments in ARGS.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.digest/sha512_256/","title":"<code>kumo.digest.sha512_256(ARGS)</code>","text":"<p>Computes a <code>SHA512_256</code> digest over each of the arguments in ARGS.</p> <p>You may pass multiple arguments.</p> <p>String arguments are intepreted as bytes and fed into the digest algorithm.</p> <p>Other types are first encoded as a JSON string and that string is then fed into the digest algorithm.</p> <p>The returned value is a Digest object representing the digest bytes. It has properties that can return the digest bytes or encoded in a number of common and useful encodings.</p>"},{"location":"reference/kumo.dkim/","title":"Module <code>kumo.dkim</code>","text":"<p>This module provides functions that are useful when working with DomainKeys Identified Mail.</p>"},{"location":"reference/kumo.dkim/#available-functions","title":"Available Functions","text":"<ul> <li>ed25519_signer</li> <li>rsa_sha256_signer</li> </ul>"},{"location":"reference/kumo.dkim/ed25519_signer/","title":"<code>kumo.dkim.ed25519_signer {PARAMS}</code>","text":"<p>Create a DKIM signer that uses ED25519 keys.</p> <p>The key data must be PKCS8 DER encoded data.</p> <p>This function will attempt to load V2 data first, which must contain the matching public and private key pair.</p> <p>If the data cannot be loaded as V2, then it will fall back to try to load V1 data, which contains just the private key.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>We now support loading either DER or PEM encoded PKCS8 private keys.</p> <pre><code>-- Called once the body has been received.\n-- For multi-recipient mail, this is called for each recipient.\nkumo.on('smtp_server_message_received', function(msg)\nlocal signer = kumo.dkim.ed25519_signer {\ndomain = msg:from_header().domain,\nselector = 'default',\nheaders = { 'From', 'To', 'Subject' },\nkey = 'example-private-dkim-key.der',\n}\nmsg:dkim_sign(signer)\nend)\n</code></pre> <p><code>PARAMS</code> is a lua table that can have the following keys:</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#domain","title":"domain","text":"<p>Required. The domain for which the mail is being signed.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#selector","title":"selector","text":"<p>Required. The selector used for signing</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#headers","title":"headers","text":"<p>Required. The list of headers which should be signed.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#atps","title":"atps","text":"<p>Optional string. Allows setting the Authorized Third-Party signature.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#atpsh","title":"atpsh","text":"<p>Optional string. Set the Authorized Third-Party Signature hashing algorithm.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#agent_user_identifier","title":"agent_user_identifier","text":"<p>Optional string. Sets the Agent of User Identifier (AUID) to use for signing.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#expiration","title":"expiration","text":"<p>Optional number. Sets the number of seconds from now to use for the signature expiration.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#body_length","title":"body_length","text":"<p>Optional boolean. If <code>true</code>, the body length will be included in the signature.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#reporting","title":"reporting","text":"<p>Optional boolean. If <code>true</code>, the signature will be marked as requesting reports from the receiver/verifier.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#header_canonicalization","title":"header_canonicalization","text":"<p>Specify the canonicalization method to be used when hashing message headers.  Can be one of:</p> <ul> <li><code>\"Relaxed\"</code> - this is the default</li> <li><code>\"Simple\"</code></li> </ul>"},{"location":"reference/kumo.dkim/ed25519_signer/#body_canonicalization","title":"body_canonicalization","text":"<p>Specify the canonicalization method to be used when hashing message body.  Can be one of:</p> <ul> <li><code>\"Relaxed\"</code> - this is the default</li> <li><code>\"Simple\"</code></li> </ul>"},{"location":"reference/kumo.dkim/ed25519_signer/#key","title":"key","text":"<p>Required. Specify the signing key.</p> <p>The value is a KeySource.</p> <p>The key data must be PKCS8 DER encoded data.</p> <pre><code>local file_signer = kumo.dkim.ed25519_signer {\ndomain = msg:from_header().domain,\nselector = 'default',\nheaders = { 'From', 'To', 'Subject' },\nkey = '/path/to/example-private-dkim-key.pem',\n}\n</code></pre> <p>Tip</p> <p>The KeySource page explains how to read from HashiCorp Vault or from an arbitrary source of data.</p>"},{"location":"reference/kumo.dkim/ed25519_signer/#ttl","title":"ttl","text":"<p>Optional number. Specifies the time-to-live (TTL) in KumoMTA's DKIM signer cache.  The default is <code>300</code> seconds.</p> <p>Each call to this function with the same parameters is cached for up to the specified TTL in order to avoid the overhead of repeatedly load the key from disk.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/","title":"<code>kumo.dkim.rsa_sha256_signer {PARAMS}</code>","text":"<p>Create a DKIM signer that uses RSA SHA256.</p> <pre><code>-- Called once the body has been received.\n-- For multi-recipient mail, this is called for each recipient.\nkumo.on('smtp_server_message_received', function(msg)\nlocal signer = kumo.dkim.rsa_sha256_signer {\ndomain = msg:from_header().domain,\nselector = 'default',\nheaders = { 'From', 'To', 'Subject' },\nkey = 'example-private-dkim-key.pem',\n}\nmsg:dkim_sign(signer)\nend)\n</code></pre> <p><code>PARAMS</code> is a lua table that can have the following keys:</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#domain","title":"domain","text":"<p>Required. The domain for which the mail is being signed.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#selector","title":"selector","text":"<p>Required. The selector used for signing</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#headers","title":"headers","text":"<p>Required. The list of headers which should be signed.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#atps","title":"atps","text":"<p>Optional string. Allows setting the Authorized Third-Party signature.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#atpsh","title":"atpsh","text":"<p>Optional string. Set the Authorized Third-Party Signature hashing algorithm.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#agent_user_identifier","title":"agent_user_identifier","text":"<p>Optional string. Sets the Agent of User Identifier (AUID) to use for signing.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#expiration","title":"expiration","text":"<p>Optional number. Sets the number of seconds from now to use for the signature expiration.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#body_length","title":"body_length","text":"<p>Optional boolean. If <code>true</code>, the body length will be included in the signature.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#reporting","title":"reporting","text":"<p>Optional boolean. If <code>true</code>, the signature will be marked as requesting reports from the receiver/verifier.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#header_canonicalization","title":"header_canonicalization","text":"<p>Specify the canonicalization method to be used when hashing message headers.  Can be one of:</p> <ul> <li><code>\"Relaxed\"</code> - this is the default</li> <li><code>\"Simple\"</code></li> </ul>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#body_canonicalization","title":"body_canonicalization","text":"<p>Specify the canonicalization method to be used when hashing message body.  Can be one of:</p> <ul> <li><code>\"Relaxed\"</code> - this is the default</li> <li><code>\"Simple\"</code></li> </ul>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#key","title":"key","text":"<p>Required. Specify the signing key data.</p> <p>The value is a KeySource.</p> <p>The key data must be either RSA PEM or a PKCS8 PEM encoded.</p> <pre><code>local file_signer = kumo.dkim.rsa_sha256_signer {\ndomain = msg:from_header().domain,\nselector = 'default',\nheaders = { 'From', 'To', 'Subject' },\nkey = '/path/to/example-private-dkim-key.pem',\n}\n</code></pre> <p>Tip</p> <p>The KeySource page explains how to read from HashiCorp Vault or from an arbitrary source of data.</p>"},{"location":"reference/kumo.dkim/rsa_sha256_signer/#ttl","title":"ttl","text":"<p>Optional number. Specifies the time-to-live (TTL) in KumoMTA's DKIM signer cache.  The default is <code>300</code> seconds.</p> <p>Each call to this function with the same parameters is cached for up to the specified TTL in order to avoid the overhead of repeatedly load the key from disk.</p>"},{"location":"reference/kumo.dns/","title":"Module <code>kumo.dns</code>","text":"<p>This module provides functions that work with querying DNS.</p>"},{"location":"reference/kumo.dns/#available-functions","title":"Available Functions","text":"<ul> <li>configure_resolver</li> <li>lookup_addr</li> <li>lookup_mx</li> </ul>"},{"location":"reference/kumo.dns/configure_resolver/","title":"<code>kumo.dns.configure_resolver{PARAMS}</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>By default, KumoMTA will parse the system resolver configuration and use that to drive its internal caching DNS resolver.</p> <p>This function allows you to configure DNS resolving differently from your system configuration.</p> <p>Note</p> <p>This function should be called only from inside your init event handler.</p> <p><code>PARAMS</code> is a lua table with the following fields:</p> <ul> <li><code>name_servers</code> - required; a list of name servers. Each entry can be either a   simple string of the form <code>\"IP:PORT\"</code> or can be a lua table that allows   specifying the protocol that should be used.</li> <li><code>domain</code> - optional; the local dns domain name to append to names.   Note that MX resolution in KumoMTA always appends a trailing <code>.</code> to   the names from the envelope addresses so this setting should be   irrelevant for MX resolution.</li> <li><code>search</code> - optional; list of additional search domains.   Note that MX resolution in KumoMTA always appends a trailing <code>.</code> to   the names from the envelope addresses so this setting should be   irrelevant for MX resolution.</li> <li><code>options</code> - a lua table listing out additional resolver options.   The possible names, values and meanings are documented in   the trust DNS resolver ResolverOpts   documentation</li> </ul> <pre><code>kumo.on('init', function()\nkumo.dns.configure_resolver {\nname_servers = {\n-- Simple UDP based entry\n'10.0.0.1:53',\n-- Use tcp with a controlled local address\n{\nsocket_addr = '10.0.0.20:53',\nprotocol = 'tcp',\n-- an NXDOMAIN entry will be treated as truth and\n-- we won't query other nameservers to see if they\n-- can resolve a given query\ntrust_negative_responses = true,\nbind_addr = '10.0.0.2:0',\n},\n},\noptions = {\nedns = true,\nuse_hosts_file = true,\n},\n}\nend)\n</code></pre>"},{"location":"reference/kumo.dns/lookup_addr/","title":"<code>kumo.dns.lookup_addr(NAME)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Resolve the <code>A</code> and <code>AAAA</code> records for the requested <code>NAME</code>.</p> <p>Raises an error if the name doesn't exist in DNS.</p> <p>Returns an array style table listing the IPv4 and IPv6 addresses as strings.</p> <p>DNS results are cached according to the TTL specified by the DNS record itself.</p> <pre><code>print(kumo.json_encode(kumo.dns.lookup_addr 'localhost'))\n-- prints out:\n-- [\"127.0.0.1\",\"::1\"]\n</code></pre>"},{"location":"reference/kumo.dns/lookup_mx/","title":"<code>kumo.dns.lookup_mx(DOMAIN)</code>","text":"<p>Resolve the MX information for the requested <code>DOMAIN</code>.</p> <p>Raises an error if the domain doesn't exist.</p> <p>Returns a lua table with the structure shown in the example below.</p> <p>DNS results are cached according to the TTL specified by the DNS record itself.</p> <p>This example shows the <code>gmail.com</code> MX information.  At the time of writing, the DNS information looks like this:</p> <pre><code>$ dig +nocomments mx gmail.com.\n\n; &lt;&lt;&gt;&gt; DiG 9.18.12 &lt;&lt;&gt;&gt; +nocomments mx gmail.com.\n;; global options: +cmd\n;gmail.com.                     IN      MX\ngmail.com.              1620    IN      MX      30 alt3.gmail-smtp-in.l.google.com.\ngmail.com.              1620    IN      MX      40 alt4.gmail-smtp-in.l.google.com.\ngmail.com.              1620    IN      MX      5 gmail-smtp-in.l.google.com.\ngmail.com.              1620    IN      MX      10 alt1.gmail-smtp-in.l.google.com.\ngmail.com.              1620    IN      MX      20 alt2.gmail-smtp-in.l.google.com.\n;; Query time: 0 msec\n;; SERVER: 127.0.0.53#53(127.0.0.53) (UDP)\n;; WHEN: Wed Mar 15 09:24:03 MST 2023\n;; MSG SIZE  rcvd: 161\n</code></pre> <pre><code>-- Query the gmail mx\nlocal gmail_mx = kumo.dns.lookup_mx 'gmail.com'\n-- This is what we expect it to look like\nlocal example = {\nby_pref = {\n-- Each preference level has a sorted list of hosts\n-- at that level\n[5] = {\n'gmail-smtp-in.l.google.com.',\n},\n[10] = {\n'alt1.gmail-smtp-in.l.google.com.',\n},\n[20] = {\n'alt2.gmail-smtp-in.l.google.com.',\n},\n[30] = {\n'alt3.gmail-smtp-in.l.google.com.',\n},\n[40] = {\n'alt4.gmail-smtp-in.l.google.com.',\n},\n},\n-- The site name is deterministically derived from the by_pref information\nsite_name = '(alt1|alt2|alt3|alt4)?.gmail-smtp-in.l.google.com',\n-- The FQDN that was resolved\ndomain_name = 'gmail.com.',\n-- The flattened set of hosts in preference order\nhosts = {\n'gmail-smtp-in.l.google.com.',\n'alt1.gmail-smtp-in.l.google.com.',\n'alt2.gmail-smtp-in.l.google.com.',\n'alt3.gmail-smtp-in.l.google.com.',\n'alt4.gmail-smtp-in.l.google.com.',\n},\n-- true if the domain is a literal IPv4 or IPv6 address such as\n-- `[10.0.0.1]` or `[IPv6:::1]`\nis_domain_literal = false,\n}\nassert(gmail_mx == example)\n</code></pre>"},{"location":"reference/kumo.domain_map/","title":"Module <code>kumo.domain_map</code>","text":"<p>This module provides functions that help with making wildcard domain name -&gt; value maps.</p>"},{"location":"reference/kumo.domain_map/#available-functions","title":"Available Functions","text":"<ul> <li>new</li> </ul>"},{"location":"reference/kumo.domain_map/new/","title":"<code>kumo.domain_map.new([{MAP}])</code>","text":"<p>Create a new domain map, optionally seeded with an initial set of key/value pairs.</p> <p>A domain map is a dictionary type that allows resolving the value associated with a domain name key, supporting wildcard domain keys in the mapping.</p> <p>For simple inputs, the mapping behaves as you might expect for a dictionary type:</p> <pre><code>local dmap = kumo.domain_map.new()\ndmap['foo'] = 'bar'\nassert(dmap['foo'] == 'bar')\nassert(dmap['not.set'] == nil)\n</code></pre> <p>you can define wildcard keys:</p> <pre><code>local dmap = kumo.domain_map.new()\ndmap['*.example.com'] = 'wildcard'\n-- An exact lookup for example.com won't match the wildcard\nassert(dmap['example.com'] == nil)\n-- but any nodes \"below\" that will match the wildcard entry:\nassert(dmap['foo.example.com'] == 'wildcard')\n-- Any explicitly added entries will take precedence\n-- over the wildcard:\ndmap['explicit.example.com'] = 'explicit'\nassert(dmap['explicit.example.com'] == 'explicit')\n</code></pre> <p>You may seed an initial value from a pre-existing lua table:</p> <pre><code>local dmap = kumo.domain_map.new {\n['*.woot.com'] = 123,\n['example.com'] = 24,\n}\n-- and mutate the table after is has been constructed:\ndmap['*.example.com'] = 42\nassert(dmap['lemon.example.com'] == 42)\nassert(dmap['example.com'] == 24)\nassert(dmap['woot.com'] == nil)\nassert(dmap['aa.woot.com'] == 123)\n</code></pre>"},{"location":"reference/kumo.encode/","title":"Module <code>kumo.encode</code>","text":"<p>This module provides functions for encoding data in standard representations such as base64 or hex.</p>"},{"location":"reference/kumo.encode/#available-functions","title":"Available Functions","text":"<ul> <li>base32_decode</li> <li>base32_encode</li> <li>base32_nopad_decode</li> <li>base32_nopad_encode</li> <li>base32hex_decode</li> <li>base32hex_encode</li> <li>base32hex_nopad_decode</li> <li>base32hex_nopad_encode</li> <li>base64_decode</li> <li>base64_encode</li> <li>base64_nopad_decode</li> <li>base64_nopad_encode</li> <li>base64url_decode</li> <li>base64url_encode</li> <li>base64url_nopad_decode</li> <li>base64url_nopad_encode</li> <li>hex_decode</li> <li>hex_encode</li> </ul>"},{"location":"reference/kumo.encode/base32_decode/","title":"<code>kumo.encode.base32_decode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes base32 encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base32_encode/","title":"<code>kumo.encode.base32_encode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies base32 encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base32_nopad_decode/","title":"<code>kumo.encode.base32_nopad_decode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes <code>base32_nopad</code> encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base32_nopad_encode/","title":"<code>kumo.encode.base32_nopad_encode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies <code>base32_nopad</code> encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base32hex_decode/","title":"<code>kumo.encode.base32hex_decode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes base32hex encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base32hex_encode/","title":"<code>kumo.encode.base32hex_encode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies base32hex encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base32hex_nopad_decode/","title":"<code>kumo.encode.base32hex_nopad_decode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes <code>base32hex_nopad</code> encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base32hex_nopad_encode/","title":"<code>kumo.encode.base32hex_nopad_encode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies base32hex encoding, with no padding, to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base64_decode/","title":"<code>kumo.encode.base64_decode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes base64 encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base64_encode/","title":"<code>kumo.encode.base64_encode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies base64 encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base64_nopad_decode/","title":"<code>kumo.encode.base64_nopad_decode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes <code>base64_nopad</code> encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base64_nopad_encode/","title":"<code>kumo.encode.base64_nopad_encode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies <code>base64_nopad</code> encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base64url_decode/","title":"<code>kumo.encode.base64url_decode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes base64url encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base64url_encode/","title":"<code>kumo.encode.base64url_encode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies base64url encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/base64url_nopad_decode/","title":"<code>kumo.encode.base64url_nopad_decode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes <code>base64url_nopad</code> encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/base64url_nopad_encode/","title":"<code>kumo.encode.base64url_nopad_encode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies <code>base64url_nopad</code> encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.encode/hex_decode/","title":"<code>kumo.encode.hex_decode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Decodes hex encoded STRING, and returns the decoded string.</p>"},{"location":"reference/kumo.encode/hex_encode/","title":"<code>kumo.encode.hex_encode(STRING)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Applies hex encoding to STRING, and returns the encoded string.</p>"},{"location":"reference/kumo.http/","title":"Module <code>kumo.http</code>","text":"<p>This module provides HTTP client functionality.</p>"},{"location":"reference/kumo.http/#available-functions","title":"Available Functions","text":"<ul> <li>Request</li> <li>Response</li> <li>build_client</li> <li>build_url</li> </ul>"},{"location":"reference/kumo.http/Request/","title":"The HTTP Request Object","text":"<p>This object is returned from client:get(), client:post() and client:put() and represents a request that has yet to be sent to the remote server.</p> <p>You can use the methods of this object to further configure the request, and then send the request.</p> <p>The following methods are supported:</p>"},{"location":"reference/kumo.http/Request/#requestheadername-value","title":"request:header(name, value)","text":"<p>Sets an HTTP header.  <code>name</code> and <code>value</code> are both strings and correspond to the header name and value respectively.</p> <pre><code>request:header('Content-Type', 'application/json')\n</code></pre>"},{"location":"reference/kumo.http/Request/#requestheadersheaders","title":"request:headers({HEADERS})","text":"<p>Sets multiple HTTP headers. <code>HEADERS</code> is an object-style table holding name/value pairs for the headers and values that should be set.</p> <pre><code>request:headers {\n['Content-Type'] = 'application/json',\n['X-Something'] = 'value',\n}\n</code></pre>"},{"location":"reference/kumo.http/Request/#requestbasic_authusername-password","title":"request:basic_auth(username [, password])","text":"<p>Configures the username and optional password that should be used to perform HTTP Basic authentication.</p> <p>Consider using a keysource with kumo.secrets.load to retrieve credentials.</p>"},{"location":"reference/kumo.http/Request/#requestbearer_authtoken","title":"request:bearer_auth(token)","text":"<p>Configures the token to be used for HTTP Bearer authentication</p> <p>Consider using a keysource with kumo.secrets.load to retrieve credentials.</p>"},{"location":"reference/kumo.http/Request/#requestbodybody","title":"request:body(body)","text":"<p>Sets the body of the request. Body must be a string.</p> <pre><code>local request = kumo.http.build_client({}):post 'https://example.com'\nrequest:header('Content-Type', 'application/json')\nrequest:body(kumo.json_encode {\nkey = 'value',\n})\n</code></pre>"},{"location":"reference/kumo.http/Request/#requestform_url_encodedparams","title":"request:form_url_encoded({PARAMS})","text":"<p>Sets the body of the request to the provided parameters, using the <code>application/x-www-form-urlencoded</code> encoding scheme. The <code>Content-Type</code> header is implicitly set to <code>application/x-www-form-urlencoded</code>.</p> <p><code>PARAMS</code> is an object-style table whose values must be UTF-8 strings.</p> <pre><code>local request = kumo.http.build_client({}):post 'https://example.com'\nrequest:form_url_encoded {\nkey = 'value',\nother_key = 'other_value',\n}\n</code></pre>"},{"location":"reference/kumo.http/Request/#requestform_multipart_dataparams","title":"request:form_multipart_data({PARAMS})","text":"<p>Sets the body of the request to the provided parameters, using the <code>multipart/form-data</code> encoding scheme. The <code>Content-Type</code> header is implicitly set to <code>multipart/form-data</code> with the automatically determined boundary field.</p> <p><code>PARAMS</code> is an object-style table whose values should be either UTF-8 strings or lua binary strings.  Binary strings are encoded as <code>application/octet-stream</code> in the generated form data.</p> <pre><code>local request = kumo.http.build_client({}):post 'https://example.com'\nrequest:form_multipart_data {\nkey = 'value',\nother_key = 'other_value',\n}\n</code></pre>"},{"location":"reference/kumo.http/Request/#requestsend","title":"request:send()","text":"<p>Sends the request and returns Response object representing the result of the request.</p>"},{"location":"reference/kumo.http/Response/","title":"The HTTP Response Object","text":"<p>This object is returned from request:send() and represents the in-progress response.  Status and header information is available to query from the response object ahead of requesting the body in either text or byte format. Once the body has been retrieved, the other methods of the response object can no longer be called.</p> <p>The following methods are supported:</p>"},{"location":"reference/kumo.http/Response/#responsestatus_code","title":"response:status_code()","text":"<p>Returns the numeric HTTP status code indicating the outcome of the request.</p>"},{"location":"reference/kumo.http/Response/#responsestatus_reason","title":"response:status_reason()","text":"<p>Returns the standardized reason-phrase representation of the status code. May return nil if the status code is non-standard or otherwise unknown.</p> <p>The purpose of the reason is for human understanding and logging. You should not use the reason in conditional logic.</p>"},{"location":"reference/kumo.http/Response/#responsestatus_is_informational","title":"response:status_is_informational()","text":"<p>Returns true if the status code is in the range <code>100</code> - <code>199</code>.</p>"},{"location":"reference/kumo.http/Response/#responsestatus_is_success","title":"response:status_is_success()","text":"<p>Returns true if the status code is in the range <code>200</code> - <code>299</code>.</p>"},{"location":"reference/kumo.http/Response/#responsestatus_is_redirection","title":"response:status_is_redirection()","text":"<p>Returns true if the status code is in the range <code>300</code> - <code>399</code>.</p>"},{"location":"reference/kumo.http/Response/#responsestatus_is_client_error","title":"response:status_is_client_error()","text":"<p>Returns true if the status code is in the range <code>400</code> - <code>499</code>.</p>"},{"location":"reference/kumo.http/Response/#responsestatus_is_server_error","title":"response:status_is_server_error()","text":"<p>Returns true if the status code is in the range <code>500</code> - <code>599</code>.</p>"},{"location":"reference/kumo.http/Response/#responseheaders","title":"response:headers()","text":"<p>Returns a headermap object that holds the response headers from the request.</p> <p>You can index the headers to look up a specific result:</p> <pre><code>local headers = response:headers()\nprint('x-header value is', headers['x-header'])\n</code></pre> <p>Indexing into the headermap is case-insensitive, so these are both equivalent:</p> <pre><code>local headers = response:headers()\nprint('x-header value is', headers['x-header'])\nprint('x-header value is', headers['X-Header'])\n</code></pre> <p>You can also iterate over the headers:</p> <pre><code>local headers = response:headers()\nfor k, v in pairs(headers) do\nprint('header', k, v)\nend\n</code></pre>"},{"location":"reference/kumo.http/Response/#responsecontent_length","title":"response:content_length()","text":"<p>Returns the length of the response data in bytes, or nil if no <code>Content-Length</code> header was present in the response.</p> <p>Note that this should be the length of the data returned by the <code>response:bytes()</code> method, but because the <code>response:text()</code> method may perform conversion to produce UTF-8, it may not be the same as the length of the textual result.</p>"},{"location":"reference/kumo.http/Response/#responsebytes","title":"response:bytes()","text":"<p>Returns the raw response content as bytes.</p>"},{"location":"reference/kumo.http/Response/#responsetext","title":"response:text()","text":"<p>This method decodes the response body with BOM sniffing and with malformed sequences replaced with the REPLACEMENT CHARACTER. Encoding is determined from the <code>charset</code> parameter of the <code>Content-Type</code> header, and defaults to utf-8 if not presented.</p>"},{"location":"reference/kumo.http/build_client/","title":"<code>kumo.http.build_client({PARAMS})</code>","text":"<p>Constructs an HTTP client object.</p> <p>The client maintains state, including a connection pool, that can be used across multiple HTTP requests.</p> <p><code>PARAMS</code> is an object-style table with the follow keys:</p> <ul> <li><code>user_agent</code> - optional string that will be used to set the <code>User-Agent</code> header   for all requests made by the client</li> </ul> <pre><code>local response = kumo.http.build_client({}):get('https://example.com/'):send()\nprint(response:status_code(), response:status_reason())\nfor k, v in pairs(response:headers()) do\nprint('Header', k, v)\nend\nprint(response:text())\n</code></pre>"},{"location":"reference/kumo.http/build_client/#client-methods","title":"Client Methods","text":"<p>The returned client object has the following methods:</p>"},{"location":"reference/kumo.http/build_client/#clientgeturl","title":"client:get(URL)","text":"<p>Returns a Request object that has been configured to make a GET request to the specified URL.  The URL is a string.</p>"},{"location":"reference/kumo.http/build_client/#clientposturl","title":"client:post(URL)","text":"<p>Returns a Request object that has been configured to make a POST request to the specified URL.  The URL is a string.</p>"},{"location":"reference/kumo.http/build_client/#clientputurl","title":"client:put(URL)","text":"<p>Returns a Request object that has been configured to make a PUT request to the specified URL.  The URL is a string.</p>"},{"location":"reference/kumo.http/build_url/","title":"<code>kumo.http.build_url(base, {PARAMS})</code>","text":"<p>Given a base URL and a set of parameters, combine the two together and return the result as a string.</p> <p><code>PARAMS</code> is an object-style table consisting of key/value pairs that should be added as GET parameters to the URL:</p> <pre><code>local url = kumo.http.build_url('https://example.com/?existing=value', {\na = 1,\nb = 2,\n})\nassert(url == 'https://example.com/?existing=value&amp;a=1&amp;b=2')\n</code></pre>"},{"location":"reference/kumo.regex_set_map/","title":"Module <code>kumo.regex_set_map</code>","text":"<p>This module provides functions that help with making regex -&gt; value maps.</p>"},{"location":"reference/kumo.regex_set_map/#available-functions","title":"Available Functions","text":"<ul> <li>new</li> </ul>"},{"location":"reference/kumo.regex_set_map/new/","title":"<code>kumo.regex_set_map.new([{MAP}])</code>","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>Create a new regex set map from a set of key/value pairs.</p> <p>A regex set can efficiently match a haystack string against a list of multiple regular expressions in a single search operation.  The search operation on the regex set knows which regular expression matched, and that is used here to map to a more meaningful value.</p> <p>Since the regex set needs to be compiled, the set is considered to be immutable; it cannot have entries added after it has been created, so you need to build up a lua table with the mapping to pass to <code>new</code>.</p> <pre><code>-- This example categorizes text into either 'hello', 'bye' results\nlocal map = kumo.regex_set_map.new {\nhello = 'hello',\nbye = 'bye',\nlater = 'bye',\n-- more complex patterns need to quote the map key:\n['Good day'] = 'hello',\n}\nassert(map['hello there'] == 'hello')\nassert(map['goodbye'] == 'bye')\nassert(map['see you later'] == 'bye')\nassert(map['not.set'] == nil)\n</code></pre>"},{"location":"reference/kumo.secrets/","title":"Module <code>kumo.secrets</code>","text":"<p>This module provides functions that are useful when working with secrets and credentials.</p>"},{"location":"reference/kumo.secrets/#available-functions","title":"Available Functions","text":"<ul> <li>load</li> </ul>"},{"location":"reference/kumo.secrets/load/","title":"<code>kumo.secrets.load(SOURCE)</code>","text":"<p>Given a keysource, load and return the bytes stored in that source.</p>"},{"location":"reference/kumo.secrets/load/#example-of-loading-a-credential-from-a-vault","title":"Example of Loading a credential from a vault","text":"<pre><code>local request = kumo.http.build_client({}):get 'https://example.com/'\nlocal passwd = kumo.secrets.load {\nvault_mount = 'secret',\nvault_path = 'example.com-passwd',\n}\nrequest:basic_auth('username', passwd)\nlocal response = request:send()\n</code></pre>"},{"location":"reference/kumo.shaping/","title":"Module <code>kumo.shaping</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>This module provides functions to configure the KumoMTA Traffic Shaping Automation daemon.</p> <p>This module is only present in the <code>tsa-daemon</code> process; attempting to reference it elsewhere will fail.</p>"},{"location":"reference/kumo.shaping/#available-functions","title":"Available Functions","text":"<ul> <li>load</li> </ul>"},{"location":"reference/kumo.shaping/load/","title":"<code>kumo.shaping.load({PATHS})</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>This function will load traffic shaping data from the list of filenames or HTTP/HTTPS URLs that is passed to it.</p> <p>For example, in the <code>tsa-daemon</code> configuration, you might use it like this:</p> <pre><code>kumo.on('tsa_load_shaping_data', function()\nlocal shaping = cached_load_shaping_data {\n-- This is the default file used by the shaping helper\n-- in KumoMTA, which references the community shaping rules\n'/opt/kumomta/share/policy-extras/shaping.toml',\n-- and maybe you have your own rules\n'/opt/kumomta/policy/shaping.toml',\n}\nreturn shaping\nend)\n</code></pre>"},{"location":"reference/kumo.shaping/load/#shaping-data-format","title":"Shaping Data Format","text":"<p>If a given path ends with <code>.toml</code>, it will be interpreted as TOML. Otherwise, it will be interpreted as JSON.</p> <p>This documentation uses TOML as it is a bit more friendly for humans to read and write.</p> <p>Shaping data is considered as an ordered series of shaping configuration files, where successive files layer and merge over earlier files.</p>"},{"location":"reference/kumo.shaping/load/#domains-and-merging","title":"Domains and Merging","text":"<p>Each file contains information keyed by the destination domain name.</p> <p>The values in a domain section must be valid values for kumo.make_egress_path, with a couple of special additional values indicated below.</p> <p>The special domain name <code>\"default\"</code> is used to define common, shared values, used as the basis for every domain.</p> <p>In this example, <code>connection_limit</code> and <code>enable_tls</code> are set for every domain. However, when sending to <code>gmail.com</code>, its <code>connection_limit</code> of <code>100</code> will override the <code>10</code> from the <code>default</code> section, and it will also use the <code>enable_tls</code> value from the default section; the values are merged together:</p> <pre><code>[\"default\"]\nconnection_limit = 10\nenable_tls = \"Opportunistic\"\n[\"gmail.com\"]\nconnection_limit = 100\n</code></pre> <p>Specifying the same domain in separate files will also merge the configuration, which allows us to share community-provided base rules that you can then choose to override without replacing everything for that domain.</p> <p>However, if you want to completely replace the information for a domain, you can indicate that by using <code>replace_base = true</code>:</p> <pre><code>[\"gmail.com\"]\n# Discard any other `gmail.com` rules provided by earlier files\nreplace_base = true\nconnection_limit = 10\n</code></pre> <p><code>replace_base</code> is only meaningful in the context of the current domain section in the current file; subsequent sections for that same domain will continue to merge in as normal, unless they also use <code>replace_base</code>.</p>"},{"location":"reference/kumo.shaping/load/#mx-rollup","title":"MX Rollup","text":"<p>By default, the shaping rules associated with a domain are applied to the site_name that is constructed from the list of MX hosts in DNS for that domain.  That allows the rules to apply to every domain that uses a shared set of MXs, for example, every G-Suite hosted domain will share <code>gmail.com</code> rules.</p> <p>For some domains this may not be desirable; in this situations you can prevent the rule from using the site_name by setting <code>mx_rollup = false</code>:</p> <pre><code>[\"example.com\"]\nmx_rollup = false\n</code></pre>"},{"location":"reference/kumo.shaping/load/#per-source-rules","title":"Per-Source Rules","text":"<p>You can provide a list of source-specific rules like this:</p> <pre><code>[\"example.com\".sources.\"my source name\"]\nconnection_limit = 5\n</code></pre> <p>The section is named in the format <code>DOMAIN.sources.SOURCE</code>.  Both the <code>DOMAIN</code> and the <code>SOURCE</code> must be quoted using double-quotes in order for the structure to be correct.</p>"},{"location":"reference/kumo.shaping/load/#traffic-shaping-automation-rules","title":"Traffic Shaping Automation Rules","text":"<p>The shaping data can include automation rules that will be evaluated by the optional <code>tsa-daemon</code> process.</p> <p>Here's an example that defines policy for <code>yahoo.com</code>:</p> <pre><code>[\"yahoo.com\"]\nmax_deliveries_per_connection = 20\n[[\"yahoo.com\".automation]]\nregex = \"\\\\[TS04\\\\]\"\naction = \"Suspend\"\nduration = \"2 hours\"\n</code></pre> <p>In TOML, the <code>[[DOMAIN.automation]]</code> syntax appends an additional entry to the list of <code>automation</code> rules in <code>DOMAIN</code>.</p> <p>This particular rule uses a regex to look for <code>[TS04]</code> in the delivery status responses from yahoo, and when it matches, the action taken is to suspend delivery to yahoo.com from the triggering source.  Other sources will be handled independently.</p> <p>The following fields are possible in an automation rule:</p> <ul> <li><code>regex</code> - required string, the regular expression used to match the rule.    Supported Regex Syntax is documented here</li> <li><code>action</code> - required action to take.  Can be one of:<ul> <li><code>\"Suspend\"</code> - Suspend delivery</li> <li><code>{SetConfig{name=\"NAME\", value=\"VALUE\"}}</code> - define a configuration override that sets <code>NAME=VALUE</code>.</li> </ul> </li> <li><code>trigger</code> - optional. Can be one of:<ul> <li><code>\"Immediate\"</code> - this is the default. The action is taken each time a <code>regex</code> matches.</li> <li><code>{Threshold=\"10/hr\"}</code> - defines a threshold; the action won't trigger in this case until 10 events have occurred in the preceding hour.</li> </ul> </li> <li><code>duration</code> - required string specifying the duration of the effects of the action.</li> </ul>"},{"location":"reference/message/","title":"Message","text":"<p>A message object represents a message that is either in the process of being received, is queued, is in the process of being delivered, or has just been delivered.</p> <p>Messages are created by the system and are then passed to your policy script via various events when the system needs your input into acting on the message.</p>"},{"location":"reference/message/#available-methods","title":"Available Methods","text":"<ul> <li>add_authentication_results</li> <li>append_header</li> <li>check_fix_conformance</li> <li>dkim_sign</li> <li>dkim_verify</li> <li>from_header</li> <li>get_address_header</li> <li>get_all_headers</li> <li>get_all_named_header_values</li> <li>get_data</li> <li>get_first_named_header_value</li> <li>get_meta</li> <li>id</li> <li>import_scheduling_header</li> <li>import_x_headers</li> <li>parse_rfc3464</li> <li>prepend_header</li> <li>recipient</li> <li>remove_all_named_headers</li> <li>remove_x_headers</li> <li>save</li> <li>sender</li> <li>set_force_sync</li> <li>set_meta</li> <li>set_recipient</li> <li>set_scheduling</li> <li>set_sender</li> <li>to_header</li> </ul>"},{"location":"reference/message/add_authentication_results/","title":"<code>message:add_authentication_results(server_id, results)</code>","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>This method will prepend an <code>Authentication-Results</code> header to the message, as specified by RFC 8601.</p> <p>The parameters are:</p> <ul> <li><code>server_id</code> - the authserv-id.  It is suggested to use     <code>msg:get_meta('hostname')</code> to obtain the hostname that was configured in     the corresponding SMTP listener.</li> <li><code>results</code> - an array of authenticationresult     objects holding the results of various authentication methods.</li> </ul>"},{"location":"reference/message/add_authentication_results/#example-obtaining-dkim-authentication-results","title":"Example: obtaining DKIM authentication results","text":"<pre><code>kumo.on('smtp_server_message_received', function(msg)\n-- Verify the dkim signature and return the results.\n-- Note that this example isn't making any policy decisions;\n-- it is only annotating the message with the results and\n-- allowing it to be relayed\nlocal verify = msg:dkim_verify()\n-- Add the results to the message\nmsg:add_authentication_results(msg:get_meta 'hostname', verify)\nend)\n</code></pre> <p>might produce an <code>Authentication-Results</code> header like this:</p> <pre><code>Authentication-Results: hostname.example.com;\n        dkim=pass\n        header.a=rsa-sha256\n        header.b=jo0EO4dX\n        header.d=github.com\n        header.i=@github.com\n        header.s=pf2023\n</code></pre>"},{"location":"reference/message/add_authentication_results/#see-also","title":"See Also:","text":"<ul> <li>msg:dkim_verify()</li> </ul>"},{"location":"reference/message/append_header/","title":"<code>message:append_header(NAME, VALUE)</code>","text":"<p>Constructs a header from <code>NAME: VALUE</code> and appends it to the header portion of the message.</p>"},{"location":"reference/message/check_fix_conformance/","title":"<code>message:check_fix_conformance(CHECKS, FIXES)</code>","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>Warning</p> <p>Fixing messages with this method is inherently imperfect: it is based on a deliberately relaxed interpretation of the message content and it is possible, or even likely, that non-conforming input is parsed in a way that results in omitting certain details from the original input.</p> <p>The purpose of this method is as a best-effort convenience for correcting minor and obviously recognizable issues that cannot easily be resolved at the message generation stage.</p> <p>It is recommended that you carefully evaluate the effects of this method before deploying it in production.</p> <p>This method serves two related functions:</p> <ul> <li>To check RFC conformance issues for which you wish to reject the message.</li> <li>To correct RFC conformance issues in case you wish to accept the message.</li> </ul> <p>It accepts two parameters that encode the set of conformance issues that are applicable. The conformance set is represented as a string listing the issues separated by a <code>|</code> character:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\nlocal failed = msg:check_fix_conformance(\n-- check for and reject messages with these issues:\n'MISSING_COLON_VALUE',\n-- fix messages with these issues:\n'LINE_TOO_LONG|NAME_ENDS_WITH_SPACE|NEEDS_TRANSFER_ENCODING|NON_CANONICAL_LINE_ENDINGS|MISSING_DATE_HEADER|MISSING_MESSAGE_ID_HEADER|MISSING_MIME_VERSION'\n)\nif failed then\nkumo.reject(552, string.format('5.6.0 %s', failed))\nend\nend)\n</code></pre> <p>The set of supported conformance issues is:</p> Label Meaning MISSING_COLON_VALUE A header was listed with only its name, and without any value. eg: <code>\"Subject\"</code> instead of <code>\"Subject: the subject\"</code> NON_CANONICAL_LINE_ENDINGS The message contained line endings that were not in the canonical <code>CRLF</code> form required by SMTP NAME_ENDS_WITH_SPACE A header name ended with space instead of a colon. eg: <code>\"Subject :\"</code> instead of <code>\"Subject: \"</code>. While that is valid for HTTP, it is invalid for email. LINE_TOO_LONG The line length for the body portion exceeds the MIME message wrapping width that is intended to keep message text wrapping within 80 columns. NEEDS_TRANSFER_ENCODING The parsed content includes 8-bit content and thus needs to have transfer encoding applied in order to safely transit the 7-bit SMTP network MISSING_DATE_HEADER The <code>\"Date:\"</code> header is not present MISSING_MESSAGE_ID_HEADER The <code>\"Message-ID:\"</code> header is not present MISSING_MIME_VERSION The <code>\"Mime-Version:\"</code> header is either not present or is set to some other value than <code>\"1.0\"</code> <p>The way this method works is that it will attempt to parse the data associated with the message into a MIME tree. The parsing stage will accumulate the set of conformance issues it uncovers as it parses the tree.</p> <p>Then the <code>CHECKS</code> parameter is decoded into the set of issues for which an error needs to be generated. If there is an intersection between <code>CHECKS</code> and the discovered conformance issues, then an error message is generated, listing the problematic issues. Here's an example:</p> <pre><code>Message has conformance issues: LINE_TOO_LONG\n</code></pre> <p>That message is returned from the method as a string so that you can then choose to issue an appropriate error response. For example:</p> <pre><code>local failed = msg:check_fix_conformance(checks, fixes)\nif failed then\n-- Rejects with an error like:\n-- `552 5.6.0 Message has conformance issues: LINE_TOO_LONG`\nkumo.reject(552, string.format('5.6.0 %s', failed))\nend\n</code></pre> <p>If after processing the <code>CHECKS</code> parameter an error was not returned, the <code>FIXES</code> parameter is consulted; if there is an intersection between <code>FIXES</code> and the discovered conformance issues, then the message will be \"fixed\".</p> <p>The strategy for fixing is simple:</p> <ul> <li>If any of the problems are not due to missing headers:<ul> <li>The message will be rebuilt from the parsed tree. This will cause headers and   parts to be re-encoded to follow the best practices coded into the built-in   mime message builder.</li> </ul> </li> <li>Missing headers will be synthesized and added to the rebuilt message</li> <li>The resulting message will then be re-encoded as a byte stream and assigned   as the data that will be saved when the message is ready to be spooled.</li> </ul> <p>Note</p> <p>Since fixing issues other than missing headers essentially rewrites the message, the chances are very high that any digital signature in the original message will be invalidated.</p>"},{"location":"reference/message/dkim_sign/","title":"<code>message:dkim_sign(SIGNER)</code>","text":"<p>Computes the DKIM signature for the message using the provided SIGNER and prepends it to the message.</p> <p>See also kumo.dkim.rsa_sha256_signer</p>"},{"location":"reference/message/dkim_verify/","title":"<code>message:dkim_verify()</code>","text":"Since: Version 2023.11.28-b5252a41 <p>The functionality described in this section requires version 2023.11.28-b5252a41 of KumoMTA, or a more recent version.</p> <p>This method will verify each DKIM signature that is present at the top level of the message, up to a limit of 10 signatures.  The limit is in place to limit the scope of a DoS attack being carried out through maliciously constructed messages.</p> <p>For each signature, an authenticationresult object will be constructed and an array of those results will be returned to the caller.</p>"},{"location":"reference/message/dkim_verify/#example-obtaining-dkim-authentication-results","title":"Example: obtaining DKIM authentication results","text":"<pre><code>kumo.on('smtp_server_message_received', function(msg)\n-- Verify the dkim signature and return the results.\n-- Note that this example isn't making any policy decisions;\n-- it is only annotating the message with the results and\n-- allowing it to be relayed\nlocal verify = msg:dkim_verify()\nprint('dkim', kumo.json_encode_pretty(verify))\n-- Add the results to the message\nmsg:add_authentication_results(msg:get_meta 'hostname', verify)\nend)\n</code></pre> <p>might print something like this to the diagnostic log:</p> <pre><code>dkim    [\n  {\n    \"props\": {\n      \"header.d\": \"github.com\",\n      \"header.i\": \"@github.com\",\n      \"header.s\": \"pf2023\",\n      \"header.a\": \"rsa-sha256\",\n      \"header.b\": \"jo0EO4dX\"\n    },\n    \"result\": \"pass\",\n    \"method\": \"dkim\",\n    \"reason\": null,\n    \"method_version\": null\n  }\n]\n</code></pre> <p>and produce an <code>Authentication-Results</code> header:</p> <pre><code>Authentication-Results: hostname.example.com;\n        dkim=pass\n        header.a=rsa-sha256\n        header.b=jo0EO4dX\n        header.d=github.com\n        header.i=@github.com\n        header.s=pf2023\n</code></pre>"},{"location":"reference/message/dkim_verify/#see-also","title":"See Also:","text":"<ul> <li>msg:add_authentication_results()</li> </ul>"},{"location":"reference/message/from_header/","title":"<code>message:from_header()</code>","text":"<p>Gets the <code>\"From\"</code> header, parses it as a list of mailboxes and groups, and returns an addressheader object.</p> <p>Returns <code>nil</code> if no matching header could be found.</p> <p>See also message:get_address_header and message:to_header.</p>"},{"location":"reference/message/get_address_header/","title":"<code>message:get_address_header(NAME)</code>","text":"<p>Gets the first header whose name matches <code>NAME</code>, parses it as a list of mailboxes and groups, and returns an addressheader object.</p> <p>Returns <code>nil</code> if no matching header could be found.</p> <p>See also message:from_header and message:to_header.</p>"},{"location":"reference/message/get_all_headers/","title":"<code>message:get_all_headers()</code>","text":"<p>Gets the all the headers, decode the values to UTF-8 and return them in a lua array style table of tables:</p> <pre><code>local headers = message:get_all_headers()\nassert(headers == {\n{ 'Subject', 'The Subject' },\n{ 'Date', 'Sun Feb 26 02:45:02 PM MST 2023' },\n})\n</code></pre>"},{"location":"reference/message/get_all_named_header_values/","title":"<code>message:get_all_named_header_values(NAME)</code>","text":"<p>Gets the all the headers whose name matches <code>NAME</code>, decode them to UTF-8 and return them in a lua array style table.</p> <p>Returns an empty table if no matching headers were found.</p>"},{"location":"reference/message/get_data/","title":"<code>message:get_data()</code>","text":"<p>Returns the message body/data as a string.</p>"},{"location":"reference/message/get_first_named_header_value/","title":"<code>message:get_first_named_header_value(NAME)</code>","text":"<p>Gets the first header whose name matches <code>NAME</code>, decode it to UTF-8 and return it.</p> <p>Returns <code>nil</code> if no matching header could be found.</p>"},{"location":"reference/message/get_meta/","title":"<code>message:get_meta(KEY)</code>","text":"<p>Messages are associated with some metadata. You can think of this metadata as being equivalent to a JSON object.</p> <p>The <code>get_meta</code> method allows you to retrieve a field of that object.</p> <pre><code>msg:set_meta('foo', 'bar')\nprint(msg:get_meta 'foo') -- prints 'bar'\n</code></pre> <p>See also msg:set_meta.</p>"},{"location":"reference/message/get_meta/#pre-defined-meta-values","title":"Pre-defined meta values","text":"<p>The following meta values are unique to the message scope:</p> Scope Name Purpose Since Message <code>queue</code> specify the name of the queue to which the message will be queued. Must be a string value. Message <code>tenant</code> specify the name/identifier of the tenant, if any. Must be a string value. Message <code>campaign</code> specify the name/identifier of the campaign. Must be a string value. Message <code>routing_domain</code> Overrides the domain of the recipient domain for routing purposes. (Since: Version 2023.08.22-4d895015) <p>Note</p> <p>Additional metadata is available in the message scope that is copied in from the connection scope, for a full list of all available metadata, see the Predefined Metadata page.</p>"},{"location":"reference/message/id/","title":"<code>message:id()</code>","text":"<p>Each message is uniquely identified by the system using an id.</p> <p>At the time of writing, the id is a version 1 UUID, which is based upon the time at which the message was created by the system. In the future, the system may change to adopt the newer v7 UUID.</p> <p><code>message:id()</code> returns the UUID encoded as a hexadecimal string, without any dashes or braces.</p>"},{"location":"reference/message/import_scheduling_header/","title":"<code>message:import_scheduling_header(HEADER_NAME, REMOVE)</code>","text":"<p>Reads the header specified and attempts to parse it as JSON-encoded version of the message:set_scheduling() parameters. If successful, it will call message:set_scheduling() with that value, and if REMOVE is set to true, will remove the header from the message.</p> <p>For example, given this message:</p> <pre><code>X-Schedule: {\"dow\":\"Mon,Wed\",\"tz\":\"America/Phoenix\",\"start\":\"09:00:00\",\"end\":\"17:00:00\"}\nSubject: hello\n\nThis message should only be delivered during working hours\nin Phoenix on Mondays or Wednesdays.\n</code></pre> <p>this policy script will parse and remove that header, and apply the scheduling constraints:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\nmsg:import_scheduling_header 'X-Schedule'\nend)\n</code></pre>"},{"location":"reference/message/import_x_headers/","title":"<code>message:import_x_headers([NAMES])</code>","text":"<p>When called with no parameters, iterates the headers of the message, and for each header with an <code>\"X-\"</code> prefix, the import the header into the message metadata.</p> <p>When called with a list of header names, only those headers, if present in the message, will be imported to the message metadata.</p> <p>When importing an <code>X-</code> header, the header name is normalized to lowercase and <code>-</code> is transformed to underscore.</p> <p>For example, with a message content of:</p> <pre><code>X-Campaign-ID: 12345\nX-Mailer: foobar\nSubject: the subject\n\nThe body\n</code></pre> <p>calling:</p> <pre><code>message:import_x_headers()\nprint(message:get_meta 'x_campaign_id') -- prints 12345\nprint(message:get_meta 'x_mailer') -- prints foobar\n</code></pre> <p>but calling:</p> <pre><code>message:import_x_headers { 'x-campaign-id' }\nprint(message:get_meta 'x_campaign_id') -- prints 12345\nprint(message:get_meta 'x_mailer') -- prints nothing\n</code></pre>"},{"location":"reference/message/parse_rfc3464/","title":"<code>message:parse_rfc3464()</code>","text":"<p>Parses the message data as an RFC 3464 delivery status report.</p> <p>If the message is not an RFC 3464 report, returns <code>nil</code>. If the message is malformed, raises a lua error.</p> <p>Otherwise, returns a lua table that looks like:</p> <pre><code>report = {\nper_message = {\nreporting_mta = {\nmta_type = 'dns',\nname = 'cs.utk.edu',\n},\n},\n-- This is an array style table, with one entry per\n-- recipient in the report\nper_recipient = {\n{\noriginal_recipient = {\nrecipient_type = 'rfc822',\nrecipient = 'louisl@larry.slip.umd.edu',\n},\nfinal_recipient = {\nrecipient_type = 'rfc822',\nrecipient = 'louisl@larry.slip.umd.edu',\n},\naction = 'failed',\nstatus = {\nclass = 4,\nsubject = 0,\ndetail = 0,\n},\ndiagnostic_code = {\ndiagnostic_type = 'smtp',\ndiagnostic = '426 connection timed out',\n},\nlast_attempt_date = '1994-07-07T21:15:49Z',\n},\n},\n}\n</code></pre>"},{"location":"reference/message/prepend_header/","title":"<code>message:prepend_header(NAME, VALUE)</code>","text":"<p>Constructs a header from <code>NAME: VALUE</code> and prepends it to the message content.</p>"},{"location":"reference/message/recipient/","title":"<code>message:recipient()</code>","text":"<p>Returns the envelope recipient of the message.  The return value is an EnvelopeAddress</p> <p>See also message:sender.</p>"},{"location":"reference/message/remove_all_named_headers/","title":"<code>message:remove_all_named_headers(NAME)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Removes all header fields with name <code>NAME</code> from the message header.</p>"},{"location":"reference/message/remove_x_headers/","title":"<code>message:remove_x_headers([NAMES])</code>","text":"<p>When called with no parameters, removes all headers with an <code>\"X-\"</code> prefix from the message.</p> <p>When called with a list of header names, only those headers, if present in the message, will be removed from the message.</p> <p>For example, with a message content of:</p> <pre><code>X-Campaign-ID: 12345\nX-Mailer: foobar\nSubject: the subject\n\nThe body\n</code></pre> <p>calling:</p> <pre><code>message:remove_x_headers()\n</code></pre> <p>will result in the body changing to:</p> <pre><code>Subject: the subject\n\nThe body\n</code></pre> <p>but calling:</p> <pre><code>message:remove_x_headers { 'x-campaign-id' }\n</code></pre> <p>will result in the body changing to:</p> <pre><code>X-Mailer: foobar\nSubject: the subject\n\nThe body\n</code></pre>"},{"location":"reference/message/save/","title":"<code>message:save()</code>","text":"<p>Save the message data and metadata to the spool.</p> <p>You do not typically need to call this method.</p>"},{"location":"reference/message/sender/","title":"<code>message:sender()</code>","text":"<p>Returns the envelope sender of the message.  The return value is an EnvelopeAddress</p> <p>See also message:recipient.</p>"},{"location":"reference/message/set_force_sync/","title":"<code>message:set_force_sync(force)</code>","text":"<p>When <code>force</code> is <code>true</code>, each future attempt to save the message metadata or data will use a high durability write, delaying further processing until the message data has been written to the spool.</p> <p>When <code>force</code> is <code>false</code>, which is the default setting, whether high durability writes are used is a function of the configuration of the spool(s) that you have enabled in your configuration.</p> <p>Note</p> <p>Using this together with RocksDB spool can be incredibly harmful to overall    performance, as forcing a flush is a database-wide operation.</p>"},{"location":"reference/message/set_meta/","title":"<code>message:set_meta(KEY, VALUE)</code>","text":"<p>Messages are associated with some metadata. You can think of this metadata as being equivalent to a JSON object.</p> <p>The <code>set_meta</code> method allows you to set a field of that object to a value that you specify.</p> <p>You can assign any value that is serializable as a JSON:</p> <pre><code>-- set foo='bar', a string value\nmsg:set_meta('foo', 'bar')\n-- set foo=123, a numeric value\nmsg:set_meta('foo', 123)\n-- set foo=true, a boolean value\nmsg:set_meta('foo', true)\n-- set foo={key=\"value\"}, an object value\nmsg:set_meta('foo', { key = 'value' })\n</code></pre> <p>You can retrieve a metadata value via message:get_meta.</p>"},{"location":"reference/message/set_meta/#pre-defined-meta-values","title":"Pre-defined meta values","text":"<p>The following meta values are unique to the message scope:</p> Scope Name Purpose Since Message <code>queue</code> specify the name of the queue to which the message will be queued. Must be a string value. Message <code>tenant</code> specify the name/identifier of the tenant, if any. Must be a string value. Message <code>campaign</code> specify the name/identifier of the campaign. Must be a string value. Message <code>routing_domain</code> Overrides the domain of the recipient domain for routing purposes. (Since: Version 2023.08.22-4d895015) <p>Note</p> <p>Additional metadata is available in the message scope that is copied in from the connection scope, for a full list of all available metadata, see the Predefined Metadata page.</p>"},{"location":"reference/message/set_recipient/","title":"<code>message:set_recipient(ENVELOPE)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Sets the envelope recipient of the message.  The value can be an EnvelopeAddress or a string that can be parsed into an <code>EnvelopeAddress</code>.</p> <pre><code>message:set_recipient 'someone.else@example.com'\n</code></pre> <p>See also message:set_sender.</p>"},{"location":"reference/message/set_scheduling/","title":"<code>message:set_scheduling { SCHED }</code>","text":""},{"location":"reference/message/set_scheduling/#messageset_schedulingnil","title":"<code>message:set_scheduling(nil)</code>","text":"<p>Allows setting schedule constraints on the message.</p> <p>When called with <code>nil</code> as a parameter, will clear any scheduling constraints that are set on the message.</p> <p>Otherwise, <code>SCHED</code> is a lua object that accepts a number of fields as listed below. There are two separate groups of scheduling constraint:</p> <ul> <li>Deferred initial delivery, using the <code>first_attempt</code> field</li> <li>Constrained time/day of week delivery using the <code>dow</code>, <code>tz</code>, <code>start</code> and <code>end</code> fields.</li> </ul> <p>When using constrained time of delivery, all four of the associated fields must be specified.  If not using constrained time of delivery, all four of the associated fields must be omitted.</p> <p>Constrained delivery modifies the normal exponential backoff retry schedule in a simple way: the target time is computed as normal, and if that time does not fall within the constrained delivery window, the scheduled time will be moved to the next following date/time at which delivery will be acceptable. In practice, that will be the <code>start</code> time on the follow appropriate <code>dow</code>.</p> <p>Just setting the <code>first_attempt</code>:</p> <pre><code>msg:set_scheduling { first_attempt = '2023-03-01T17:00:00:00-08:00' }\n</code></pre> <p>setting constraints to deliver only on Mondays and Wednesdays during business hours, Phoenix time.  Note that <code>end</code> has to be quoted to be used as a table key in lua, because it is a language keyword:</p> <pre><code>msg:set_scheduling {\ndow = 'Mon,Wed',\ntz = 'America/Phoenix',\nstart = '09:00:00',\n['end'] = '17:00:00',\n}\n</code></pre> <p>and both together:</p> <pre><code>msg:set_scheduling {\nfirst_attempt = '2023-03-01T17:00:00:00-08:00',\ndow = 'Mon,Wed',\ntz = 'America/Phoenix',\nstart = '09:00:00',\n['end'] = '17:00:00',\n}\n</code></pre>"},{"location":"reference/message/set_scheduling/#first_attempt","title":"first_attempt","text":"<p>Optional String.</p> <p>If present, must be an RFC 3339 date/time string which specifies the earliest time at which the message will be scheduled for delivery.</p>"},{"location":"reference/message/set_scheduling/#dow","title":"dow","text":"<p>String.</p> <p>Specifies the comma separated list of days of the week on which delivery will be permitted.  Days can be three-letter prefixes or the full English day names. For example both <code>\"Mon,Tue,Wed,Thu,Fri\"</code> and <code>\"Monday,Tuesday,Wednesday,Thursday,Friday\"</code> are acceptable ways to indicate working week days.</p>"},{"location":"reference/message/set_scheduling/#tz","title":"tz","text":"<p>String.</p> <p>Specifies the name of the timezone in which to interpret the scheduling constraints.  The timezone name must be a name from the IANA Time Zone Data such as <code>\"America/Phoenix\"</code>.  Short forms like <code>\"PST\"</code> have ambiguous interpretations and are NOT accepted.</p>"},{"location":"reference/message/set_scheduling/#start","title":"start","text":"<p>String.</p> <p>Specifies the time of day in <code>\"HH:MM:SS\"</code> form of the start of an acceptable delivery window.  The time is interpreted in the timezone specified by the <code>tz</code> field.</p>"},{"location":"reference/message/set_scheduling/#end","title":"end","text":"<p>String.</p> <p>Specifies the time of day in <code>\"HH:MM:SS\"</code> form of the end of an acceptable delivery window.  The time is interpreted in the timezone specified by the <code>tz</code> field.</p>"},{"location":"reference/message/set_sender/","title":"<code>message:set_sender(ENVELOPE)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Sets the envelope sender of the message.  The value can be an EnvelopeAddress or a string that can be parsed into an <code>EnvelopeAddress</code>.</p> <pre><code>message:set_sender(string.format('bounce-%s@%s', HASH, DOMAIN))\n</code></pre> <p>See also message:set_recipient.</p>"},{"location":"reference/message/to_header/","title":"<code>message:to_header()</code>","text":"<p>Gets the <code>\"To\"</code> header, parses it as a list of mailboxes and groups, and returns an addressheader object.</p> <p>Returns <code>nil</code> if no matching header could be found.</p> <p>See also message:get_address_header and message:from_header.</p>"},{"location":"reference/redis/","title":"<code>require 'redis'</code>","text":"<p>The redis module provides access to redis data stores.</p>"},{"location":"reference/redis/#available-functions","title":"Available Functions","text":"<ul> <li>open</li> </ul>"},{"location":"reference/redis/open/","title":"<code>redis.open { PARAMS }</code>","text":"<p>Opens a connection to a Redis data store and returns a connection handle.</p> <pre><code>local redis = require 'redis'\n-- Open a connection and increment a counter, returning its new value\nlocal conn = redis.open { node = 'redis://127.0.0.1/' }\nprint(conn:query('incr', 'test-count'))\n</code></pre> <p>PARAMS is a lua table with the following keys:</p> <ul> <li> <p><code>node</code> - the redis URL string identifying the server.  Can be a table listing   multiple servers if you have a redis cluster deployed.</p> </li> <li> <p><code>pool_size</code> - optional integer. Specifies the maximum number of spare   connections to be maintained by the connection pool.  The default is 10.</p> </li> <li> <p><code>read_from_replicas</code> - optional boolean. If true, when connecting to a redis   cluster, reads are issued to replicas while writes are issued to the primary   data stores.</p> </li> <li> <p><code>username</code> - optional string. convenience for working with the cluster, so   that you only need to specify the username once. This is not used for connecting   to a single node.</p> </li> <li> <p><code>password</code> - optional string. convenience for working with the cluster, so   that you only need to specify the password once. This is not used for connecting   to a single node.</p> </li> </ul> <p>The returned connection handle has a single <code>\"query\"</code> method:</p>"},{"location":"reference/redis/open/#connquerycmd-args","title":"<code>conn:query(CMD, [ARGS])</code>","text":"<p>Issue a redis command and return the result.</p> <p>See Redis Commands for a list of commands.</p> <p>The redis INCRBY command increments a key by a value; it has the syntax:</p> <pre><code>INCRBY key increment\n</code></pre> <p>To use INCRBY to increment <code>my-key</code> by <code>2</code>:</p> <pre><code>conn:query(\"INCRBY\", \"my-key\", 2)\n</code></pre>"},{"location":"reference/sqlite/","title":"<code>require 'sqlite'</code>","text":"<p>The sqlite module provides access to sqlite databases.</p>"},{"location":"reference/sqlite/#available-functions","title":"Available Functions","text":"<ul> <li>open</li> </ul>"},{"location":"reference/sqlite/open/","title":"<code>sqlite.open(PATH, [BUSY_TIMEOUT=500])</code>","text":"<p>Opens the sqlite database at <code>PATH</code> and returns a connection handle.</p> <p><code>BUSY_TIMEOUT</code> specifies the time in milliseconds over which sqlite should retry operations when it is unable to get an exclusive lock. The default is 500ms.</p> <p>The returned connection object has a single method, <code>execute</code> which can be used to execute a query.</p> <p>Note</p> <p>when using the special path <code>:memory:</code>, sqlite will create an in-memory database which is great for this contrived example, but not a great deal of use in a real worl usage inside KumoMTA.</p> <pre><code>local sqlite = require 'sqlite'\nlocal db = sqlite.open ':memory:'\n-- For the sake of this example, populate with some simple data\ndb:execute 'CREATE TABLE people (name, age)'\n-- You can use prepared statements with positional arguments like this:\ndb:execute('INSERT INTO people (name, age) values (?, ?)', 'john', 42)\n-- and with named arguments like this:\ndb:execute(\n'INSERT INTO people (name, age) values (:name, :age)',\n{ name = 'fred', age = 32 }\n)\n-- Lets print out just the ages from the database; when the query\n-- returns only a single column, the returned value will be an\n-- array style lua table consisting of just the values.  In this case,\n-- it is equivalent to `{32, 42}`\nprint 'query ages'\nlocal ages = db:execute 'select age from people order by age'\nfor k, v in ipairs(ages) do\nprint(k, v)\nend\n-- When multiple columns are returned, they are presented as\n-- an array style table of lua object style tables will be returned.\n-- In this case it is equivalent to:\n-- `{ {name=\"john\", age=42 }, {name=\"fred\", age=32}}`\nprint 'query all'\nlocal ages = db:execute 'select * from people order by age'\nfor k, v in ipairs(ages) do\nprint('row', k)\nfor name, value in pairs(v) do\nprint(name, value)\nend\nend\n-- When no rows are returned by the query, the return value is\n-- the number of rows affected by the query. In this case, because\n-- 2 records are being deleted, this will print 2\nprint('deleted rows:', db:execute 'delete from people')\n</code></pre> <p>sqlite queries are executed via a thread pool so that the query won't block important IO scheduling.</p> <p>Queries and query results are not implicitly cached.</p>"},{"location":"reference/tsa/","title":"Module <code>tsa</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>This module provides functions to configure the KumoMTA Traffic Shaping Automation daemon.</p> <p>This module is only present in the <code>tsa-daemon</code> process; attempting to <code>require</code> it elsewhere will fail.</p>"},{"location":"reference/tsa/#available-functions","title":"Available Functions","text":"<ul> <li>configure_tsa_db_path</li> <li>start_http_listener</li> </ul>"},{"location":"reference/tsa/configure_tsa_db_path/","title":"<code>kumo.configure_tsa_db_path(PATH)</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>This function should be called only from inside your tsa_init event handler, and MUST be called before kumo.tsa.start_http_listener.</p> <p>Its purpose is to specify the path in which the tsa-daemon will persist event and configuration information in a local sqlite database.</p> <p>The default value for <code>PATH</code> is <code>\"/var/spool/kumomta/tsa.db\"</code>.</p> <p>Since the path is passed to sqlite, you may use URI filenames as specified in the sqlite3_open documentation, such as <code>\":memory:\"</code> to use an in-memory database that will be discarded when the tsa-daemon is restarted.</p>"},{"location":"reference/tsa/start_http_listener/","title":"<code>kumo.start_http_listener { PARAMS }</code>","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Configure and start the TSA HTTP service.</p> <p>This function should be called only from inside your tsa_init event handler.</p> <p>This function behaves exactly like kumo.start_http_listener except that it will start the Traffic Shaping Automation specific HTTP service.</p>"},{"location":"rustapi/","title":"Internal Rust API","text":"<p>This section contains automatically generated documentation from the internal Rust code.  It is included in here to aid those hacking on the internals.</p> <p>There are no stability guarantees with this API: it may change without any regard for backward compatibility.</p> <p>The following crates are part of the KumoMTA workspace:</p> <ul> <li>bounce_classify</li> <li>cidr_map</li> <li>config</li> <li>data_loader</li> <li>dns_resolver</li> <li>domain_map</li> <li>duration_serde</li> <li>kumo_api_types</li> <li>kumo_dkim</li> <li>kumo_log_types</li> <li>kumo_server_common</li> <li>kumo_server_lifecycle</li> <li>kumo_server_memory</li> <li>kumo_server_runtime</li> <li>lruttl</li> <li>maildir</li> <li>mailparsing</li> <li>message</li> <li>mod_amqp</li> <li>mod_digest</li> <li>mod_dns_resolver</li> <li>mod_encode</li> <li>mod_http</li> <li>mod_kafka</li> <li>mod_memoize</li> <li>mod_redis</li> <li>mod_sqlite</li> <li>mta_sts</li> <li>regex_set_map</li> <li>rfc5321</li> <li>spool</li> <li>throttle</li> <li>timeq</li> <li>version_info</li> </ul>"},{"location":"rustapi/static.files/SourceSerif4-LICENSE-3bb119e13b1258b7/","title":"SourceSerif4 LICENSE 3bb119e13b1258b7","text":"<p>Copyright 2014-2021 Adobe (http://www.adobe.com/), with Reserved Font Name 'Source'. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries. Copyright 2014 - 2023 Adobe (http://www.adobe.com/), with Reserved Font Name \u2018Source\u2019. All Rights Reserved. Source is a trademark of Adobe in the United States and/or other countries.</p> <p>This Font Software is licensed under the SIL Open Font License, Version 1.1.</p> <p>This license is copied below, and is also available with a FAQ at: http://scripts.sil.org/OFL</p>"},{"location":"rustapi/static.files/SourceSerif4-LICENSE-3bb119e13b1258b7/#sil-open-font-license-version-11-26-february-2007","title":"SIL OPEN FONT LICENSE Version 1.1 - 26 February 2007","text":"<p>PREAMBLE The goals of the Open Font License (OFL) are to stimulate worldwide development of collaborative font projects, to support the font creation efforts of academic and linguistic communities, and to provide a free and open framework in which fonts may be shared and improved in partnership with others.</p> <p>The OFL allows the licensed fonts to be used, studied, modified and redistributed freely as long as they are not sold by themselves. The fonts, including any derivative works, can be bundled, embedded, redistributed and/or sold with any software provided that any reserved names are not used by derivative works. The fonts and derivatives, however, cannot be released under any other type of license. The requirement for fonts to remain under this license does not apply to any document created using the fonts or their derivatives.</p> <p>DEFINITIONS \"Font Software\" refers to the set of files released by the Copyright Holder(s) under this license and clearly marked as such. This may include source files, build scripts and documentation.</p> <p>\"Reserved Font Name\" refers to any names specified as such after the copyright statement(s).</p> <p>\"Original Version\" refers to the collection of Font Software components as distributed by the Copyright Holder(s).</p> <p>\"Modified Version\" refers to any derivative made by adding to, deleting, or substituting -- in part or in whole -- any of the components of the Original Version, by changing formats or by porting the Font Software to a new environment.</p> <p>\"Author\" refers to any designer, engineer, programmer, technical writer or other person who contributed to the Font Software.</p> <p>PERMISSION &amp; CONDITIONS Permission is hereby granted, free of charge, to any person obtaining a copy of the Font Software, to use, study, copy, merge, embed, modify, redistribute, and sell modified and unmodified copies of the Font Software, subject to the following conditions:</p> <p>1) Neither the Font Software nor any of its individual components, in Original or Modified Versions, may be sold by itself.</p> <p>2) Original or Modified Versions of the Font Software may be bundled, redistributed and/or sold with any software, provided that each copy contains the above copyright notice and this license. These can be included either as stand-alone text files, human-readable headers or in the appropriate machine-readable metadata fields within text or binary files as long as those fields can be easily viewed by the user.</p> <p>3) No Modified Version of the Font Software may use the Reserved Font Name(s) unless explicit written permission is granted by the corresponding Copyright Holder. This restriction only applies to the primary font name as presented to the users.</p> <p>4) The name(s) of the Copyright Holder(s) or the Author(s) of the Font Software shall not be used to promote, endorse or advertise any Modified Version, except to acknowledge the contribution(s) of the Copyright Holder(s) and the Author(s) or with their explicit written permission.</p> <p>5) The Font Software, modified or unmodified, in part or in whole, must be distributed entirely under this license, and must not be distributed under any other license. The requirement for fonts to remain under this license does not apply to any document created using the Font Software.</p> <p>TERMINATION This license becomes null and void if any of the above conditions are not met.</p> <p>DISCLAIMER THE FONT SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT OF COPYRIGHT, PATENT, TRADEMARK, OR OTHER RIGHT. IN NO EVENT SHALL THE COPYRIGHT HOLDER BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, INCLUDING ANY GENERAL, SPECIAL, INDIRECT, INCIDENTAL, OR CONSEQUENTIAL DAMAGES, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF THE USE OR INABILITY TO USE THE FONT SOFTWARE OR FROM OTHER DEALINGS IN THE FONT SOFTWARE.</p>"},{"location":"tutorial/checking_logs/","title":"Check for success in the logs","text":"<p>When diagnosing the failure (or monitoring the success) of your test messages, the logs provide extensive information.</p> <p>The easiest way to monitor activity is with the built-in <code>tailer</code> utility. Open a new terminal (because you cannot tail the logs and simultaneously send mail from the same session) and start the <code>tailer</code> utility:</p> <pre><code>sudo /opt/kumomta/sbin/tailer --tail /var/log/kumomta\n</code></pre> <pre><code>{\n\"type\": \"Reception\",\n\"id\": \"d7ef132b5d7711eea8c8000c29c33806\",\n\"sender\": \"test@example.com\",\n\"recipient\": \"test@example.com\",\n\"queue\": \"example.com\",\n\"site\": \"\",\n\"size\": 320,\n\"response\": {\n\"code\": 250,\n\"enhanced_code\": null,\n\"content\": \"\",\n\"command\": null\n},\n\"peer_address\": {\n\"name\": \"moto\",\n\"addr\": \"127.0.0.1\"\n},\n\"timestamp\": 1695847980,\n\"created\": 1695847980,\n\"num_attempts\": 0,\n\"bounce_classification\": \"Uncategorized\",\n\"egress_pool\": null,\n\"egress_source\": null,\n\"feedback_report\": null,\n\"meta\": {},\n\"headers\": {},\n\"delivery_protocol\": null,\n\"reception_protocol\": \"ESMTP\",\n\"nodeid\": \"d8e014c7-eaeb-4683-a56e-61324e91b1fc\"\n}\n</code></pre> <p>Note</p> <p>These example log entries have been formatted for ease of reading in the documentation.</p> <p>This assumes a default installation with the logs located in <code>/var/log/kumomta/</code>.</p> <p>If you want to dive in deeper, compressed logs are found in <code>/var/log/kumomta/</code> as can be seen in this tree. Logs are segmented by a combination of size/time and stored in compressed files named after the time that the segment was started. To read these, you need to unpack them first. You have many options for configuring logging.</p> <pre><code>/var/log/kumomta\n\u251c\u2500\u2500 20230311-033705\n\u251c\u2500\u2500 20230311-033844\n\u251c\u2500\u2500 20230312-182542\n\u2514\u2500\u2500 20230314-181435\n</code></pre> <p>We can take a look at a specific log by decompressing it and since these are zstd compressed, you can view all but the current one with <code>zstdcat</code>.  ZSTD is a streaming compression utility so the current file cannot be accessed until it is flushed and closed. You can force the current log to close early by stopping or restarting KumoMTA.</p> <p>Using the example above, we can see the content of the newest file after stopping KumoMTA with a <code>zstdcat /var/log/kumomta/20230314-181435</code>.</p> <p>The default for log segments is to flush them after 1GB of data is written, but you can adjust them to flush after a certain amount of time. The kumo.configure_local_logs page of the Reference Manual has all of the available logging configuration options.</p>"},{"location":"tutorial/checking_logs/#next-steps","title":"Next Steps","text":"<p>With KumoMTA installed, configured, and tested, the tutorial is complete.</p> <p>See more on Next Steps.</p>"},{"location":"tutorial/configuring_kumomta/","title":"Configuring KumoMTA","text":"<p>The KumoMTA configuration is entirely written in Lua. Lua is a powerful embedded scripting language that is easy to read and code, and is very powerful. It is used for custom scripts in Cisco security appliances, Roblox, World of Warcraft, and really awesome MTAs. You can read more about how we leverage Lua here.</p> <ol> <li> <p>Create an initial core configuration by copying the example at https://docs.kumomta.com/userguide/configuration/example/ and writing it to <code>/opt/kumomta/etc/policy/init.lua</code>.</p> <p></p> </li> <li> <p>Update the relay_hosts configuration within the start_esmtp_listener function to reflect which networks are authorized to inject mail:</p> <pre><code>-- override the default set of relay hosts\nrelay_hosts = { '127.0.0.1', '192.168.1.0/24' }\n</code></pre> </li> <li> <p>By default only localhost and private networks are able to relay (send) mail.  Add the IP address or CIDR block of your injectors here to allow them to relay mail.</p> <p>For HTTP, this is done with the trusted_hosts setting in a listener stanza:</p> <pre><code>kumo.start_http_listener {\nlisten = '0.0.0.0:8000',\n-- allowed to access any http endpoint without additional auth\ntrusted_hosts = { '127.0.0.1', '::1' },\n}\n</code></pre> <p>Note</p> <p>If you are going to allow the HTTP listener on any IP other than localhost, you should also configure TLS and HTTP Validation.</p> </li> <li> <p>Create a local copy of the Traffic Shaping Helper configuration file. The helpers are designed to provide simple configuration for standard use cases, but the Traffic Shaping Helper in particular uses a community-managed settings file located in <code>policy-extras</code> that is subject to change when your KumoMTA installation is updated. By copying it to a separate location, you can add your own rules or replace ones from the community file without your changes being lost during an update. The example config is designed so that both files are used. Only edit <code>/opt/kumomta/etc/policy/shaping.toml</code> when you want to make changes.</p> <pre><code>sudo cp /opt/kumomta/share/policy-extras/shaping.toml /opt/kumomta/etc/policy/shaping.toml\n</code></pre> <p>For more information, see the Configure Traffic Shaping Automation section of the User Guide.</p> </li> </ol> <ol> <li> <p>Configure the listener_domains.toml file, written to <code>/opt/kumomta/etc/policy/listener_domains.toml</code> in the following format, substituting your own sending domain information:</p> <p><pre><code>[\"bounce.example.com\"]\n# You can specify multiple options if you wish\nlog_oob = true\nlog_arf = true\nrelay_to = false\n</code></pre> For more information, see the Configuring Inbound and Relay Domains page of the User Guide.</p> <p>Note</p> <p>The preceding example configures the server to accept traffic from the outside world addressed to the bounce.example.com domain, as long as the incoming messages are either Out-Of-Band DSN (bounce) notifications, or Feedback Loop messages, but will not accept regular mail for inbound relay such as with a corporate mail environment.</p> </li> <li> <p>Configure the sources.toml file, written to <code>/opt/kumomta/etc/policy/sources.toml</code> in the following format, substituting your own IP and ehlo information:</p> <pre><code>[source.\"ip-1\"]\nsource_address = \"10.0.0.1\"\nehlo_domain = 'mta1.examplecorp.com'\n[source.\"ip-2\"]\nsource_address = \"10.0.0.2\"\nehlo_domain = 'mta2.examplecorp.com'\n[pool.\"Default\"]\n[pool.\"Default\".\"ip-1\"]\n[pool.\"pool-1\"]\n[pool.\"pool-1\".\"ip-2]\n</code></pre> <p>For more information, see the Configuring Sending IPs page of the User Guide.</p> </li> <li> <p>Configure the queues.toml file, written to <code>/opt/kumomta/etc/policy/queues.toml</code> in the following format, substituting your own tenant names and header names:</p> <pre><code>scheduling_header = \"X-Schedule\"\ntenant_header = \"X-Tenant\"\nremove_tenant_header = true\ncampaign_header = \"X-Campaign\"\nremove_campaign_header = true\ndefault_tenant = \"default-tenant\"\n[tenant.'default-tenant']\negress_pool = 'default'\n[tenant.'mytenant']\negress_pool = 'pool-1'\nmax_age = '10 hours'\n[queue.'gmail.com']\nmax_age = '22 hours'\nretry_interval = '17 mins'\n</code></pre> <p>For More information, see the Configuring Queue Management page of the User Guide.</p> </li> <li> <p>Configure DKIM signing keys. Read the guide for details, but the short version is below:</p> <p>Replace the domain and selector with your own, then generate signing keys with:</p> <pre><code>export DOMAIN=&lt;your_domain&gt;\nexport SELECTOR=&lt;your_selector&gt;\nsudo mkdir -p /opt/kumomta/etc/dkim/$DOMAIN\nsudo openssl genrsa -f4 -out /opt/kumomta/etc/dkim/$DOMAIN/$SELECTOR.key 1024\nsudo openssl rsa -in /opt/kumomta/etc/dkim/$DOMAIN/$SELECTOR.key -outform PEM -pubout -out /opt/kumomta/etc/dkim/$DOMAIN/$SELECTOR.pub\nsudo chown kumod:kumod /opt/kumomta/etc/dkim/$DOMAIN -R\n</code></pre> </li> <li> <p>Configure the dkim_data.toml file, written to <code>/opt/kumomta/etc/policy/dkim_data.toml</code> in the following format, substituting your own DKIM signing information:</p> <pre><code>[base]\n# Default selector to assume if the domain/signature block\n# doesn't specify one\nselector = \"dkim1024\"\n# The default set of headers to sign if otherwise unspecified\nheaders = [\"From\", \"To\", \"Subject\", \"Date\", \"MIME-Version\", \"Content-Type\", \"Sender\"]\n# Domain blocks match based on the sender domain of the incoming message\n[domain.\"example.com\"]\nselector = 'dkim1024'\nheaders = [\"From\", \"To\", \"Subject\", \"Date\", \"MIME-Version\", \"Content-Type\", \"Sender\"]\nalgo = \"sha256\"\n# Optional override of keyfile path Default is \"/opt/kumomta/etc/dkim/DOMAIN/SELECTOR.key\"\nfilename = \"/full/path/to/key.\"\n</code></pre> <p>Note</p> <p>These instructions assume that the keyfiles are already created and in place, along with the appropriate DNS records. See the UserGuide for more information.</p> </li> </ol> <p>You now have a basic and safe sending configuration that will allow you to move on to Starting KumoMTA.</p>"},{"location":"tutorial/installing_kumomta/","title":"Installing KumoMTA","text":"<p>Pre-built repos are available for supported Operating Systems, making installation straightforward:</p> <pre><code>sudo dnf -y install dnf-plugins-core\nsudo dnf config-manager \\\n--add-repo \\\nhttps://openrepo.kumomta.com/files/kumomta-rocky.repo\nsudo yum install kumomta\n</code></pre> <p>This installs the KumoMTA daemon to /opt/kumomta/sbin/kumod</p> <p>Note</p> <p>Alternatively you can install the kumomta-dev package in order to take advantage of the latest pre-release features. This is only recommended for testing environments.</p> <p>KumoMTA is now installed with a basic policy that allows relay from localhost, but it will need a more granular configuration policy for production use.</p> <p>Proceed to the Configuring KumoMTA section for more details.</p>"},{"location":"tutorial/lab_notes/","title":"Lab Notes","text":"<p>This page is a collection of interesing notes worth mentioning if you are experimenting with configs.</p>"},{"location":"tutorial/lab_notes/#toml-files","title":"TOML Files","text":"<p>TOML files can be super handy for abstracting config settings from the underlying Lua.  For instance, you might have 500 DKIM keys for  domains you manage, but the DKIM signing process is always the same. You can create one signing configuration in Lua and have it read  in the 500 sets of settings from a single TOML file.</p> <p>Be aware that TOML files dont really tolerate duplicate entries. If you have duplicate keys unter a heading, unpredictable things can happen.</p> <p>TOML files can be much easier to use than other forms of config files because due to the easy to use structure and the ability to comment.</p> <p>IE: [Top_Heading]   \"key\" = \"value\"</p>"},{"location":"tutorial/lab_notes/#this-is-a-comment","title":"This is a comment.","text":""},{"location":"tutorial/next_steps/","title":"Next Steps","text":"<p>With KumoMTA installed, configured, and tested, the tutorial is complete.</p> <p>From here, proceed to the User Guide to learn more about Installation, Configuration, Operation, and Advanced Policies.</p>"},{"location":"tutorial/quickstart/","title":"Quickstart Tutorial","text":"<p>This adbridged set of instructions assumes you are an experienced MailOps administrator looking for the basic commands needed for an install. More detailed instructions are in the next section of the tutorial. This tutorial is not intended to be a replacement for reading the full documentation, but rather will show how to install and configure KumoMTA for a specific environment and serve as a basis to your own unique deployment.</p> <p>This tutorial assumes the reader has a basic understanding of Linux administration, experience installing and managing an MTA, a provisioned physical or virtual machine, and a minimal installer for Rocky Linux 9.</p> <ol> <li> <p>Provision an AWS t2.xlarge (or larger) instance (or any physical or virtual server with at least 4 CPUs, 16Gb RAM, 300Gb Hard Drive).</p> <p>Note</p> <p>The hardware here is for a high-throughput sending environment, but KumoMTA can run on a smaller footprint for low-volume environments. if your sending needs are smaller, you can deploy to a server with 1 CPU, 2GB RAM, and 10Gb of storage.</p> </li> <li> <p>Install Rocky Linux 9. A minimal install is sufficient.</p> </li> <li> <p>Update the OS and disable Postfix if needed</p> <pre><code>sudo dnf clean all\nsudo dnf update -y\nsudo systemctl stop postfix.service\nsudo systemctl disable postfix.service\n</code></pre> </li> <li> <p>Add the KumoMTA repo to your config manager and yum install it like this:</p> <pre><code>sudo dnf -y install dnf-plugins-core\nsudo dnf config-manager \\\n--add-repo \\\nhttps://openrepo.kumomta.com/files/kumomta-rocky.repo\nsudo yum install kumomta\n</code></pre> <p>Note</p> <p>Alternatively you can install the kumomta-dev package in order to take advantage of the latest pre-release features. This is only recommended for testing environments.</p> </li> <li> <p>The instructions above will place a default configuration file at /opt/kumomta/etc/policy/init.lua and start the KumoMTA service, if the service does not start by default it can be started and enabled with the following commands:</p> <pre><code>sudo systemctl start kumomta\nsudo systemctl enable kumomta\n</code></pre> <p>Alternately you can run it manually with : <pre><code>sudo /opt/kumomta/sbin/kumod --policy \\\n/opt/kumomta/etc/policy/init.lua --user kumod&amp;\n</code></pre></p> <p>KumoMTA will now be installed and running the init.lua configuration from <code>/opt/kumomta/sbin/kumod</code>.  If you started it manually, the <code>&amp;</code> pushes the running process to the background, type 'fg' to bring it forward again.</p> </li> <li> <p>Test your KumoMTA configuration using telnet or the tool of your choice:</p> <pre><code>telnet localhost 25\nTrying ::1...\ntelnet: connect to address ::1: Connection refused\nTrying 127.0.0.1...\nConnected to localhost.\nEscape character is '^]'.\n220 localhost.localdomain KumoMTA\nehlo moto\n250-localhost.localdomain Aloha moto\n250-PIPELINING\n250-ENHANCEDSTATUSCODES\n250 STARTTLS\nMAIL FROM:test@example.com\n250 OK EnvelopeAddress(\"test@example.com\")\nRCPT TO:test@example.com\n250 OK EnvelopeAddress(\"test@example.com\")\nDATA\n354 Send body; end with CRLF.CRLF\nSubject: Test Message Using KumoMTA\n\nThis is a test.\n.\n250 OK ids=d7ef132b5d7711eea8c8000c29c33806\nquit\n221 So long, and thanks for all the fish!\n</code></pre> </li> <li> <p>View the log entries related to your test message:</p> <pre><code>$ sudo /opt/kumomta/sbin/tailer --tail /var/log/kumomta\n</code></pre> <pre><code>{\n\"type\": \"Reception\",\n\"id\": \"d7ef132b5d7711eea8c8000c29c33806\",\n\"sender\": \"test@example.com\",\n\"recipient\": \"test@example.com\",\n\"queue\": \"example.com\",\n\"site\": \"\",\n\"size\": 320,\n\"response\": {\n\"code\": 250,\n\"enhanced_code\": null,\n\"content\": \"\",\n\"command\": null\n},\n\"peer_address\": {\n\"name\": \"moto\",\n\"addr\": \"127.0.0.1\"\n},\n\"timestamp\": 1695847980,\n\"created\": 1695847980,\n\"num_attempts\": 0,\n\"bounce_classification\": \"Uncategorized\",\n\"egress_pool\": null,\n\"egress_source\": null,\n\"feedback_report\": null,\n\"meta\": {},\n\"headers\": {},\n\"delivery_protocol\": null,\n\"reception_protocol\": \"ESMTP\",\n\"nodeid\": \"d8e014c7-eaeb-4683-a56e-61324e91b1fc\"\n}\n</code></pre> <p>Note</p> <p>In the default configuration, it will take about 10 seconds for the log files to flush and show the log entries in the <code>tailer</code> output. You can speed that up by changing the <code>max_segment_duration</code> in the <code>init.lua</code> file, or just by restarting the server via <code>sudo systemctl restart kumomta</code>.</p> <p>These example log entries have been formatted for ease of reading in the documentation.</p> </li> </ol>"},{"location":"tutorial/quickstart/#next-steps","title":"Next Steps","text":"<p>This page described a situation where you already have a fully prepared server/instance and just needed basic install instructions. Read on to look at server selection and sizing, OS preparation, installation, and testing in more detail.</p>"},{"location":"tutorial/server_environment/","title":"Environmental Considerations","text":"<p>When deciding on server hardware, senders must balance vertical and horizontal scaling based on their preferences. KumoMTA is built to support both vertical and horizontal scaling, with both single-node performance of several million messages per hour, as well as support for clustered installations.</p> <p>For illustrative purposes, we will consider a sender who is sending an average of 8 million messages per day, during a core window of 8 hours per day, or one million messages per hour peak throughput.</p> <p>For this example, we will use an average message size of 50 KB, resulting in 1 Million * 50KB = 50,000,000 KB or 50GB total transfer/hour (400GB/day).</p> <p>Expressed in terms of throughput, 50GB / 3600s = 111 Mbps (0.1Gbps), something handled easily by Gigabit networking.</p> <p>This means that our build is targeting a burst speed of one million messages per hour, a common use case for larger scale senders. If your needs are lower, you can certainly provision a smaller server than what will be discussed in this section of the tutorial.</p>"},{"location":"tutorial/server_environment/#network","title":"NETWORK","text":"<p>Because this use case involves slightly over 100Mbps, most network environments will be able to handle this traffic without modification. Be sure to verify that your server (or virtual server host) is connected to a network that supports Gigabit or faster connectivity.</p>"},{"location":"tutorial/server_environment/#storage-volume","title":"STORAGE VOLUME","text":"<p>The total volume is important for calculating storage capacity.  KumoMTA does not store the full body after delivery, but it will be needed to calculate spool capacity and memory use.  In a worst case scenario, if all of your messages are deferred (temporarily undeliverable) then your delayed queue is going to need to store all messages until delivery resumes. Given that the messages relaying through the server add up to 400GB per day, you will need 400G in storage capacity to handle a full-day outage.</p> <p>Under normal circumstances, most messages will deliver in realtime, and queue depth will generally be correlated to your sending reputation; the better your sending reputation, the less spool storage you need, so there is one more good reason to maintain a good sending reputation.</p> <p>You should allocate enough spool storage to accomodate as many days of sending outage as you feel comfortable tolerating, in most cases a day's worth of storage is sufficient, given that you typically don't see full outbound outages that last more than a few hours in well-managed datacenters.</p> <p>Note</p> <p>Spool storage is calculated as ((Average_Message_Size_in_bytes + 512) x message volume)</p> <p>Logs will also consume drive space. The amount of space is highly dependent on your specific configuration, but based on the default server policy, each log line will consume about 250-500 bytes on disk thanks to KumoMTA's use of <code>zstd</code> compression, and there may be an average of 2-5 log lines per message.  In this example we are going to assume logging at a rate of 2KB per message in order to include a safety margin.</p> <p>So we have 2KB * 8 Million messages = ~16.3Gb (per day of log storage). If you are looking at storing 30 days of logs, this results in roughly 500GB of storage for logs.</p> <p>You are also going to need about around 100GB for the OS (including keeping OS logs and other /var elements without the immediate risk of disk overflow), resulting in a total storage allocation of 1Tb. Note that this assumes retention of a full month of MTA logs, a full day of spool delay, and a sizable partition for OS logs. This number can be brought down significantly through log rotation and a more conservative deffered spool estimate.</p> <p>When installing the OS, the disks should be partitioned to keep the spool and logs separate from the OS. In addition, separating the /var directory (other than the directories within /var that are used for KumoMTA) to its own partition is highly recommended.</p>"},{"location":"tutorial/server_environment/#cpu","title":"CPU","text":"<p>KumoMTA is built on a multithreaded scheduler architecture and takes full advantage of multiple CPU cores. While it can operate on a single (v)CPU, we recommend starting with at least four CPU cores to allow for workload between things like DKIM signing, connection handling, and IO management to be spread out more efficiently.</p>"},{"location":"tutorial/server_environment/#ram","title":"RAM","text":"<p>KumoMTA will process as many messages in RAM as possible, so more is better.  We recommend 16Gb RAM, but you will see benefits from adding more as your message processing volume increases.</p> <p>So, from all of that we see a need for 4 vCPUs, 16Gb RAM, and 1TB of storage. In AWS, that translates to somewhere between an xlarge to a 4xlarge instance size, depending on instance type.</p> <p>With our server selected, we can install the OS and prepare it.</p>"},{"location":"tutorial/starting_kumomta/","title":"Starting KumoMTA","text":"<p>If you followed all the instructions above without errors, you should now have a working MTA on a properly sized server.</p> <p>Check to see if it is already running from the install instructions above:</p> <pre><code>sudo systemctl status kumomta\n</code></pre> <p>If the service is already running, you will need to restart it to apply the changes made above:</p> <pre><code>sudo systemctl restart kumomta\n</code></pre> <p>Start the MTA with this:</p> <pre><code>sudo systemctl start kumomta\n</code></pre> <p>You can enable it to restart as a service with a reboot with:</p> <pre><code>sudo systemctl enable kumomta\n</code></pre> <p>Alternately you can start it manually with:</p> <pre><code> sudo /opt/kumomta/sbin/kumod --policy \\\n/opt/kumomta/etc/policy/init.lua --user kumod&amp;\n</code></pre> <ul> <li>Using sudo allows KumoMTA to run as a privileged user so it can access port 25 which is needed to deliver via SMTP to the internet.</li> <li>The daemon <code>kumod</code> is the MTA.</li> <li>The directive --policy makes kumod load the 'init.lua' file as configuration policy.</li> <li>Because we launched with sudo, you need to use the directive --user and provide a valid user to assign responsibility to.</li> <li>The line ends with a <code>&amp;</code> that forces the daemon to run in the background and returns you to a usable prompt (use <code>fg</code> to bring it back to the foreground).</li> </ul> <p>You can also get immediate feedback by pre-pending <code>KUMOD_LOG=kumod=info</code> (or debug for more detail):</p> <pre><code>sudo KUMOD_LOG=kumod=info /opt/kumomta/sbin/kumod --policy /opt/kumomta/etc/policy/init.lua --user kumod&amp;\n</code></pre> <p>If all goes well, it should return a PID and drop you back to a Linux prompt.</p> <p>If KumoMTA does not start, refer to the Troubleshooting Page of the User Guide.</p>"},{"location":"tutorial/system_preparation/","title":"System Preparation","text":"<p>Now that we know what to build, lets go ahead and build it.</p>"},{"location":"tutorial/system_preparation/#os-installation","title":"OS Installation","text":"<p>For AWS users:</p> <ul> <li>Log into AWS, select EC2 and hit the Launch Instance button.</li> <li>Give this server a name and then search for \"Rocky\" in the OS images, select \"Rocky 9\".</li> <li>Under Instance Type, select a t2.xlarge, provide your keypair for login or create a pair if necessary.</li> <li>In the Network Settings, select or create a security group that includes ports 22,25,80,443,587,2025. These will be important for sending and receiving email in a number of ways.</li> <li>Finally, modify the storage volume to 1TB (or anything over 300Gb) and click Launch Instance.</li> </ul> <p>When AWS has finished building your server instance, you can select it and connect. I prefer to find the SSH client information and use a remote terminal emulator like Putty or Terminal like this:</p> <pre><code>ssh -i \"yourkeyname.pem\" rocky@ec2-\\&lt;pub-lic-ip\\&gt;.&lt;zone&gt;.compute.amazonaws.com\n</code></pre>"},{"location":"tutorial/system_preparation/#os-preparation","title":"OS Preparation","text":"<p>Regardless of what system you deploy, there are things you need to do to prepare the OS before installing the MTA.</p> <ul> <li>Update the installed packages</li> <li>Install basic testing and support tools</li> <li>Turn off services that are wasteful or can interfere</li> <li>Tune the use of memory and file access for best performance</li> <li>Automate updates and startup for resiliency</li> </ul> <p>Note</p> <p>Rocky Linux is very similar to RedHat Enterprise Linux (RHEL), as is Alma and CentOS. The instructions below are shown for a Rocky 9 system but with slight modification, should work for any DNF package management system. For Amazon Linux (AL2) the instructions are identical, but replace \"dnf\" with \"yum\".</p> <pre><code># Do basic updates\nsudo dnf clean all\nsudo dnf update -y\n\n# Grab some handy tools\nsudo dnf install -y wget bind bind-utils telnet firewalld\n\nsudo systemctl start named\nsudo systemctl enable named\n</code></pre> <p>For the sake of simplicity you can automate daily updates of installed packages using <code>cron</code>:</p> <pre><code># Make sure it all stays up to date\n# Run a dnf update at 3AM daily\necho \"0 3 * * * root /usr/bin/dnf update -y &gt;/dev/null 2&gt;&amp;1\" | \\\nsudo tee /etc/cron.d/dnf-updates &gt;/dev/null\n</code></pre> <p>Next configure the local firewall:</p> <pre><code># Build a basic firewall\nsudo echo \"ZONE=public\n\" | sudo tee -a /etc/sysconfig/network-scripts/ifcfg-eth0\n\nsudo systemctl stop firewalld\nsudo systemctl start firewalld.service\nsudo firewall-cmd --set-default-zone=public\nsudo firewall-cmd --zone=public --change-interface=eth0\nsudo firewall-cmd --zone=public --permanent --add-service=http\nsudo firewall-cmd --zone=public --permanent --add-service=https\nsudo firewall-cmd --zone=public --permanent --add-service=ssh\nsudo firewall-cmd --zone=public --permanent --add-service=smtp\nsudo firewall-cmd --zone=public --permanent --add-port=587/tcp\n\nsudo systemctl enable firewalld\nsudo firewall-cmd --reload\n</code></pre> <p>Finally, disable unnecessary services like postfix and qpidd:</p> <pre><code>sudo systemctl stop postfix.service\nsudo systemctl disable postfix.service\nsudo systemctl stop qpidd.service\nsudo systemctl disable qpidd.service\n</code></pre>"},{"location":"tutorial/system_preparation/#creating-a-self-signed-certificate","title":"Creating a Self-Signed Certificate","text":"<p>Before you continue, you should ensure that your system has a valid SSL Certificate.  If you do not have one available, a self-signed certificate is acceptable for most purposes (Change the certificate variables before executing this):</p> <pre><code># For the certificate enter your FQDN\nMYFQDN=\"my.company.com\"\n# For the certificate, what country code are you in? (CA,US,UK, etc)\nCERT_CO=US\n\n# For the certificate, what State or Province are you in? (Alberta, California, etc)\"\nCERT_ST=\"California\"\n# For the certificate, what city are you in? (Edmonton, Houston, etc)\"\nCERT_LO=\"Los Angeles\"\n# For the certificate, what is the name of your company or organization\"\nCERT_ORG=\"My Company\"\n# Generate private key\nopenssl genrsa -out ca.key 2048\n# Generate CSR\nopenssl req -new -key ca.key -out ca.csr -subj \"/C=$CERT_CO/ST=$CERT_ST/L=$CERT_LO/O=$CERT_ORG/CN=$MYFQDN/\"\n# Generate Self Signed Key\nopenssl x509 -req -days 365 -in ca.csr -signkey ca.key -out ca.crt\n\n# Copy the files to the correct locations\nsudo mv -f ca.crt /etc/pki/tls/certs\nsudo mv -f ca.key /etc/pki/tls/private/ca.key\nsudo mv -f ca.csr /etc/pki/tls/private/ca.csr\n\n# If Apache HTTPD is installed, update the SSL config (IGNORE ERRORS)\nsudo sed -i 's/SSLCertificateFile \\/etc\\/pki\\/tls\\/certs\\/localhost.crt/SSLCertificateFile \\/etc\\/pki\\/tls\\/certs\\/ca.crt/' /etc/httpd/conf.d/ssl.conf\nsudo sed -i 's/SSLCertificateKeyFile \\/etc\\/pki\\/tls\\/private\\/localhost.key/SSLCertificateKeyFile \\/etc\\/pki\\/tls\\/private\\/ca.key/' /etc/httpd/conf.d/ssl.conf\n</code></pre> <p>With this preparation complete, we're ready to Install KumoMTA.</p>"},{"location":"tutorial/testing_kumomta/","title":"Testing KumoMTA","text":"<p>Now that you have KumoMTA installed, you should test it from the command line of the installed host. This is easy if you installed the basic tools as described earlier.</p> <p>Note that the default SMTP listener is on port 25, so we have use that in these examples.</p>"},{"location":"tutorial/testing_kumomta/#telnet-method-for-smtp","title":"Telnet method for SMTP","text":"<p>Start a telnet session with <code>telnet localhost 25</code>, replacing youremail@address.com with your actual email address:</p> <pre><code>ehlo moto\nmail from:youremail@address.com\nrcpt to:youremail@address.com\nDATA\nfrom:youremail@address.com\nto:youremail@address.com\nsubject: My First Email\n\nHey, this is my first email!\n.\n</code></pre> <p>Note</p> <p>If you have not specifically requested outbound use of port 25 from AWS, then it is very possible the message will not be delivered.</p>"},{"location":"tutorial/testing_kumomta/#curl-method-for-http-api","title":"Curl method for HTTP API","text":"<pre><code>$ curl -H 'Content-Type: application/json' 'http://127.0.0.1:8000/api/inject/v1' -d '{\n    \"envelope_sender\": \"noreply@example.com\",\n    \"content\": \"Subject: hello\\n\\nHello there\",\n    \"recipients\": [\n        {\n            \"email\": \"recipient@example.com\"\n        }\n    ]\n}'\n</code></pre> <p>See the HTTP injection API reference for more information.</p>"},{"location":"tutorial/testing_kumomta/#using-swaks-for-testing","title":"Using Swaks for testing","text":"<p>Swaks, the Swiss Army Knife for SMTP by John Jetmore is a fantastic tool for testing.</p> <p>Install Swaks:</p> <pre><code>curl -O https://jetmore.org/john/code/swaks/files/swaks-20201014.0.tar.gz\ntar -xvzf swaks-20201014.0.tar.gz\nchmod 755 ./swaks-20201014.0/swaks\n</code></pre> <p>Basic Swaks usage:</p> <pre><code>swaks --to user@example.com --server 127.0.0.1 --port 25\n</code></pre> <p>Regardless of testing method used, the next step is to check the logs.</p>"},{"location":"userguide/","title":"User Guide","text":"<p>This is the KumoMTA User Guide.</p> <p>The User Guide is intended for those who have a general understanding of operating an MTA and are looking for information on how to use KumoMTA in particular.</p> <p>Those who are brand new to email operations, or those who just want the minimum information needed to get started, should refer to the Tutorial.</p> <p>Those who are experienced at using KumoMTA and are looking for more detailed information on specific commands and functions may be better served by the Reference Manual.</p> <p>The user guide is structured in the typical order a user would need in the process of setting up and administrating a server:</p> <ul> <li>General - Information on the project, its history, and how to interact with the developer team.</li> <li>Installation - Information on how to install KumoMTA for a variety of use cases and platforms.</li> <li>Configuration - An explanation of how to configure KumoMTA for typical use cases.</li> <li>Operation - Information on how to manage and interact with a KumoMTA server.</li> <li>Policy - A deeper dive into the policy capabilities of KumoMTA and how to implement advanced use cases.</li> </ul>"},{"location":"userguide/configuration/bounce/","title":"Configuring Bounce Classification","text":"<p>By default, the logs will contain extensive information on the responses provided by a remote host during a delivery attempt:</p> <pre><code>// The response from the peer, if applicable\n\"response\": {\n// the SMTP status code\n\"code\": 250,\n// The ENHANCEDSTATUSCODE portion of the response parsed\n// out into individual fields.\n// This one is from a \"2.0.0\" status code\n\"enhanced_code\": {\n\"class\": 2,\n\"subject\": 0,\n\"detail\": 0,\n},\n// the remainder of the response content\n\"content\": \"OK ids=8a5475ccbbc611eda12250ebf67f93bd\",\n// the SMTP command verb to which the response was made.\n// eg: \"MAIL FROM\", \"RCPT TO\" etc. \".\" isn't really a command\n// but is used to represent the response to the final \".:\n// we send to indicate the end of the message payload.\n\"command\": \".\"\n},\n</code></pre> <p>This information includes the IANA Status Codes provided by the remote host, but there are a large number of codes that can be interpreted in a variety of ways, and many mailbox providers use status codes differently.</p> <p>To make it easier to handle bounces, the Bounce Classifier can be configured:</p> <pre><code>kumo.on('init', function()\nkumo.configure_local_logs {\nlog_dir = '/var/log/kumomta',\n}\nkumo.configure_bounce_classifier {\nfiles = {\n'/opt/kumomta/share/bounce_classifier/iana.toml',\n},\n}\nend)\n</code></pre> <p>Once configured, the Bounce Classifier will populate the bounce_classification field in the logs with the applicable category.</p> <p>An example of classification rules:</p> <pre><code>[rules]\nInvalidRecipient = [\n\"^(451|550) [45]\\\\.1\\\\.[1234] \",\n\"^45[02] [45]\\\\.2\\\\.4 \", # Mailing list expansion\n\"^5\\\\d{2} [45]\\\\.7\\\\.17 \", # RRVS: Mailbox owner has changed\n]\nBadDomain = [\n\"^(451|550) [45]\\\\.1\\\\.10 \", # NULL MX\n\"^5\\\\d{2} [45]\\\\.7\\\\.18 \", # RRVS: domain owner has changed\n]\n</code></pre> <p>Users can create their own classification rules file by copying the default file, editing it, and adding the path to their custom rules file to the files option in the kumo.configure_bounce_classifier function call. Each defined rules file will be merged into the full ruleset.</p> <p>For additional information, see the reference manual page on bounce classification.</p>"},{"location":"userguide/configuration/bounce/#configuring-out-of-band-bounce-processing","title":"Configuring Out-Of-Band Bounce Processing","text":"<p>Not all bounces occur while the server is connected to the remote host. It is not uncommon for a remote host to accept a message, perform further processing, and then determine that the message should be rejected. This can be because of user validation, AntiVirus/AntiSpam processing, or other post-connection logic. When a remote host rejects a message after accepting it, RFCs require that a Message Disposition Notification (MDN) message be sent to the return path address of the message specified in the MAIL FROM command during the relay session. See https://en.wikipedia.org/wiki/Bounce_message for more information.</p> <p>The KumoMTA server can process these MDN messages, but must be configured to know which domains are candidates for OOB bounce processing.  This is most simply accomplished using the listener domains policy helper, with a snippet like this:</p> <pre><code>[\"bounce.examplecorp.com\"]\n# accept and log OOB messages send to bounce.examplecorp.com\nlog_oob = true\n</code></pre>"},{"location":"userguide/configuration/bounce/#oob-message-disposition-after-processing","title":"OOB Message Disposition After Processing","text":"<p>For most use cases, the desired outcome after a DSN message is processed is to discard the message, but in some cases it can be desirable to forward the message for further processing or storage, especially during testing and migration.</p> <p>To queue a message after processing, add <code>relay_to = true</code> to the listener domain configuration:</p> <pre><code>[\"bounce.examplecorp.com\"]\n# accept and log OOB messages send to bounce.examplecorp.com\nlog_oob = true\nrelay_to = true\n</code></pre> <p>In addition, it should be noted that the MX record for your domain will still be pointed at the KumoMTA instance, which means that in order to avoid a mail loop you will need to configure routing for the domain to specify where the message should be relayed to from the KumoMTA instance:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\nif msg:recipient().domain == 'bounce.examplecorp.com' then\n-- Re-route the message to the intended destination\nmsg:set_meta('routing_domain', '[192.168.1.100]')\n-- In earlier versions of KumoMTA, you need to set the queue\n-- this way instead\n-- msg:set_meta('queue', '[192.168.1.100]')\nend\nend)\n</code></pre>"},{"location":"userguide/configuration/concepts/","title":"Configuration Concepts","text":"<p>KumoMTA uses Lua in place of a more traditional formatted configuration file.</p> <p>Lua is a surprisingly powerful configuration language, allowing you to either statically define configuration or dynamically build it by pulling from multiple data sources.</p> <p>While using a scripting language for configuration may sound complicated, in practice many configurations end up being very succinct and readable.  Take a look at the example policy to see how a Lua configuration can appear quite similar to a traditional configuration file.</p> <p>For more information on implementing policies in KumoMTA, refer to the policy chapter.</p>"},{"location":"userguide/configuration/concepts/#configuration-location","title":"Configuration Location","text":"<p>By default, the server will load from <code>/opt/kumomta/etc/policy/init.lua</code> on startup. We recommend using this location, but information on starting the server with an alternate path can be found in the chapter on starting KumoMTA.</p>"},{"location":"userguide/configuration/concepts/#configuration-scopes","title":"Configuration Scopes","text":"<p>To better understand how a KumoMTA configuration is built, it helps to review the general flow of a message through the KumoMTA server. This is covered in more detail in the Queues chapter of the reference manual but will be summarized here.</p> <pre><code>graph TD\n   SQ[\"Scheduled Queue: campaign:tenant@domain.com\"]\n   SMTPL[\"ESMTP Listener\"]\n   HTTPI[\"Injection API\"]\n   RQ1[\"Ready Queue: 10.0.0.1-&gt;MX(domain.com)\"]\n   RQ2[\"Ready Queue: 10.0.0.2-&gt;MX(domain.com)\"]\n   POOL[\"egress pool\"]\n   IP1[\"Source: 10.0.0.1\"]\n   IP2[\"Source: 10.0.0.2\"]\n   MAINT[\"Queue Maintainer\"]\n   DESTSITE[\"domain.com\"]\n\n   SMTPL --&gt; SQ\n   HTTPI --&gt; SQ\n   SQ --&gt; MAINT\n   IP1 --&gt; POOL\n   IP2 --&gt; POOL\n   POOL -- per tenant:domain config --&gt; MAINT\n   MAINT -- throttle per tenant:domain config --&gt; RQ1\n   MAINT -- throttle per tenant:domain config --&gt; RQ2\n   RQ1 -- throttle per source:domain config\\nconnect via 10.0.0.1 --&gt; DESTSITE\n   RQ2 -- throttle per source:domain config\\nconnect via 10.0.0.2 --&gt; DESTSITE</code></pre> <p>1) A message is injected into the KumoMTA server. This is affected by configuring either an SMTP Listener or an HTTP Listener.</p> <p>2) The message is assigned into a Scheduled Queue based on the combination of its campaign, tenant, and destination domain. If there is no defined campaign or tenant, the message is placed in a queue based on the elements that are present.</p> <p>At this point, the behavior of the queue can be configured to control things such as the age of a message, the retry intervals, and the routing of a message. These options are described in the Configuring Queue Management chapter.</p> <p>3) The KumoMTA server moves the message from the Scheduled Queue into the Ready Queue based on retry intervals configured for the Standby Queue. If a message is on its first attempt, it will be moved to the Ready Queue immediately.</p> <p>4) Messages move from the Ready Queue to their destination via an egress path that was configured for the Ready Queue. This egress path is defined as a combination of an egress source and a site name. Traffic shaping and other similar options are configured based on this combination, see the Configuring Traffic Shaping chapter for more information.</p> <ul> <li> <p>The egress source is a configured structure that defines the name, source IP, and ehlo domain of a given pathway, and it is added to an egress pool, which the message is assigned to as part of the queue config. Note: While routing is assigned at the egress pool level, traffic shaping happens at the egress source level.</p> </li> <li> <p>The site name is an identifier string created by merging the combined MX hostnames for a given destination domain. This approach allows the server to queue and throttle based not on the destination domain for a given message, but on the aggregate of all domains that share the same set of MXes.</p> </li> </ul> <p>5) All delivery attempts are logged, and any messages that receive a 4xx tempfail response from the remote host are returned to the Scheduled Queue to await a retry attempt. See the Configuring Logging chapter for more information on logging.</p>"},{"location":"userguide/configuration/concepts/#configuration-structure","title":"Configuration Structure","text":"<p>There is a lot of flexibility in how a KumoMTA policy file is laid out, but a few things are generally consistent:</p>"},{"location":"userguide/configuration/concepts/#init-event","title":"Init Event","text":"<p>The majority of the base server configuration will reside within an init event handler. The init event is fired when the server first starts up, making it the appropriate time for basic server configuration.</p> <p>Because these attributes are only loaded on init, an explicit reload must be triggered when anything in the init handler is changed, whether the change is in the policy script itself or a change in a data source or file accessed by the policy script.</p> <p>An example:</p> <pre><code>kumo.on('init', function()\nkumo.define_spool {\nname = 'data',\npath = '/var/spool/kumomta/data',\nkind = 'RocksDB',\n}\nend)\n</code></pre>"},{"location":"userguide/configuration/concepts/#realtime-events","title":"Realtime Events","text":"<p>Attributes that are needed at the time of queueing and sending are handled in events that are called repeatedly as messages pass through the server. Any such events are constantly firing, and as such any file or data source access involved in those events will update immediately unless caching is configured.</p> <p>That said, any modification to the policy script itself is subject to caching of the Lua policy, which is refreshed every 300 seconds or 1024 executions by default.</p> <p>An example:</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nreturn kumo.make_queue_config {\negress_pool = tenant,\n}\nend)\n</code></pre>"},{"location":"userguide/configuration/concepts/#external-data","title":"External Data","text":"<p>Because the configuration is implemented through policy, the traditional practice of breaking things up into discrete files and assembling them using include statements does not apply.</p> <p>Since includes were often used for dynamic information such as relay domains or relay hosts, the recommended practice is to store that specific data in a data file or data source and load it using Lua data access functions.</p> <p>For example, DKIM signing information by domain and selector could be stored in a JSON file like this:</p> <pre><code>{\n\"examplecorp.com\": \"s1024\",\n\"newcorp.com\": \"dkim2023\"\n}\n</code></pre> <p>The data file could then be read and used to control signing:</p> <pre><code>local DKIM_CONFIG = kumo.json_load '/opt/kumomta/etc/policy/dkim_config.json'\nfunction dkim_sign(msg)\nlocal sender_domain = msg:from_header().domain\nlocal selector = DKIM_CONFIG[sender_domain]\n-- and so on\nend\n</code></pre> <p>That said, Lua does support Include and Require directives, but they operate similarly to the Include and Require directives commonly used in programming languages.</p>"},{"location":"userguide/configuration/dkim/","title":"Configuring DKIM Signing","text":""},{"location":"userguide/configuration/dkim/#what-it-is","title":"What it is","text":"<p>DomainKeys Identified Mail (DKIM) is a mechanism that allows verification of the source and contents of email messages. Using DKIM, sending domains can include a cryptographic signature in outgoing email messages. A message's signature may be verified by an MTA during transit and by the Mail User Agent (MUA) upon delivery. A verified signature indicates the message was sent by the sending domain and the message was not altered in transit. When a DKIM signature fails verification that indicates the message may have been altered during transit or that the sender is fraudulently using the sending domain name.</p> <p>The 2011 DKIM specification is located here: rfc6376.</p> <p>This diagram gives a graphical view of how DKIM works.</p> <pre><code>---\ntitle: DKIM Process flow\n---\ngraph TD\n    SENDER[\"Sender\"]\n    SMTA[\"Sending MTA\"]\n    SIGN[\"Sign Message Using Private Key\"]\n    VALIDATE[\"Validate Signature using Public Key\"]\n    RMTA[\"Receiving MTA\"]\n    MBOX[\"User Mailbox\"]\n    SPAM[\"Spam Folder\"]\n    DNS\n    SMTA --&gt; SIGN\n    SIGN --&gt; RMTA\n    RMTA --&gt; VALIDATE\n    SENDER -- Publish Public Key --&gt; DNS\n    DNS -- Get Sender's Public Key --&gt; RMTA\n    VALIDATE -- Valid Signature --&gt; MBOX\n    VALIDATE -- Invalid Signature --&gt; SPAM\n\n   style SMTA fill:orange,color:black\n   style RMTA fill:skyblue,color:black\n   style DNS fill:#A2E4B8,color:black\n   style MBOX fill:#E8DD8E,color:black\n</code></pre>"},{"location":"userguide/configuration/dkim/#enabling-dkim-signing-in-kumomta","title":"Enabling DKIM signing in KumoMTA","text":"<p>A system administrator with access to manage DNS generates a public/private key pair to use for signing all outgoing messages for the domain (multiple key pairs are allowed). The public key is published in DNS, and the private key is made available to their DKIM-enabled outbound email servers. This is step \"1\" in the diagram.</p> <p>When an email is sent by an authorized user within the domain, the DKIM-enabled email system uses the stored private key to generate a digital signature of the message. This signature is included in a DKIM-Signature header and prepended to the email. The email is then sent on to the recipient's mail server. This is step \"2\" in the diagram.</p>"},{"location":"userguide/configuration/dkim/#generating-dkim-keys","title":"Generating DKIM Keys","text":"<p>Generate public and private keys for each signing domain and create the DKIM public key DNS records for those domains.</p> <p>The OpenSSL cryptography toolkit can be used to generate RSA or Ed25519 keys for DKIM. The most recent rfc indicates that Ed25519 should be used, but be aware that Ed25519 DKIM support is currently very limited with most email services. RSA keys are also supported and are still more widely accepted. As an example, the following openssl commands are used to generate RSA public and private keys for the a domain you choose with a selector you choose. The files can be stored in any directory such as <code>~/kumomta/keys/</code>, but the default is <code>/opt/kumomta/etc/dkim/</code>.</p> <p>Replace the domain and selector with your own, then generate signing keys with:</p> <pre><code>$ export DOMAIN=&lt;your_domain&gt;\n$ export SELECTOR=&lt;your_selector&gt;\n$ sudo mkdir -p /opt/kumomta/etc/dkim/$DOMAIN\n$ sudo openssl genrsa -f4 -out /opt/kumomta/etc/dkim/$DOMAIN/$SELECTOR.key 1024\n$ sudo openssl rsa -in /opt/kumomta/etc/dkim/$DOMAIN/$SELECTOR.key \\\n-outform PEM -pubout -out /opt/kumomta/etc/dkim/$DOMAIN/$SELECTOR.pub\n$ sudo chown kumod:kumod /opt/kumomta/etc/dkim/$DOMAIN -R\n</code></pre> <p>Any DKIM verification implementations must support key sizes of 512, 768, 1024, 1536, and 2048 bits. A signer may choose to sign messages using any of these sizes and may use a different size for different selectors. Larger key sizes provide greater security but impose higher CPU costs during message signing and verification. It is not recommended to use a key size lower than 1024 unless absolutely necessary. Note that Google requires senders to sign with a 1024 bit or greater key size.</p> <p>The resulting RSA public key should look similar to:</p> <pre><code>-----BEGIN PUBLIC KEY-----\nMIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQDnkmt7Vty2iLsVCpNCx4+tbufL\nxwe+P13AmzYYa9SHIV2Is3G+U4vRlAEg1McK1ssrsjF5GWGSKSeDrYJY06I8ruZS\nCpPIHQo85GAkmGbBPHMhZuk8x5XSgI8VkjAZDbiJAwg1U6MV5deWqrzDC8OJ3+RK\nKPrbKH5ubT9V9pLKawIDAQAB\n-----END PUBLIC KEY-----\n</code></pre> <p>Once the public and private keys have been generated, create a DNS text record for <code>&lt;SELECTOR&gt;._domainkey.&lt;DOMAIN&gt;</code> (IE: <code>dkim1024._domainkey.example.com</code>). The DNS record contains several DKIM \"tag=value\" pairs and should be similiar to the record shown below:</p> <p>for RSA256:</p> <pre><code>default._domainkey.example.com. 86400 IN TXT\n\"v=DKIM1; k=rsa; h=sha256; p=MIbBa...DaQAB\"\n</code></pre> <p>DKIM DNS text record tags are defined below. Do not include the quotes below when including a tag value in the DNS text record.</p> <ul> <li> <p><code>v=</code> DKIM key record version. The value of this tag must be set to \"DKIM1\".</p> </li> <li> <p><code>k=</code> Key type. This tag defines the syntax and semantics of the p= tag     value. Currently, this tag should have the value \"rsa\" or \"ed25519\" as     appropriate.</p> </li> <li> <p><code>h=</code> Hash algorithm. Currently, this tag should have the value \"sha1\"     or \"sha256\" if using RSA.</p> </li> <li> <p><code>t=</code> Flags. The only value currently defined is \"y\". If specified, this     tag indicates the signing domain is testing DKIM.</p> </li> <li> <p><code>p=</code> DKIM public key value* generated as described above.</p> </li> <li> <p><code>s=</code> Service Type. If specified, this tag should be set to \"*\" or     \"email\" which represents all service types or the email service type.     Currently, \"email\" is the only service using this key.</p> </li> <li> <p><code>n=</code> Notes. If specified, the value of this tag is quoted-printable     text used as a note to anyone reading the DNS text record. The tag is not     interpreted by DKIM verification and should be used sparingly because of     space limitations of the DNS text record.</p> </li> </ul>"},{"location":"userguide/configuration/dkim/#using-the-dkim_signlua-policy-helper","title":"Using the dkim_sign.lua Policy Helper","text":"<p>To simplify DKIM configuration using a TOML configuration file, you can use the <code>dkim_sign.lua</code> policy helper.</p> <p>The policy helper is configured to look for keys under the default path of <code>/opt/kumomta/etc/dkim/DOMAIN/SELECTOR.key</code> but can be overridden on a per-domain basis if needed.</p> <p>To use the policy helper, add the following to your default policy:</p> <pre><code>local dkim_sign = require 'policy-extras.dkim_sign'\nlocal dkim_signer = dkim_sign:setup { '/opt/kumomta/etc/dkim_data.toml' }\nkumo.on('smtp_server_message_received', function(msg)\n-- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\ndkim_signer(msg)\nend)\nkumo.on('http_message_generated', function(msg)\n-- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\ndkim_signer(msg)\nend)\n</code></pre> <p>The preceding policy example sets up the <code>dkim_sign</code> helper and adds calls for signing to the events that fire for message arrival. The call to the <code>dkim_signer</code> function much be placed last in the events to ensure that no further manipulation of the messages occur after signing.</p> <p>In addition create and populate the configured <code>dkim_data.toml</code> file, located at <code>/opt/kumomta/etc/dkim_data.toml</code> in this example.</p> <pre><code>[base]\n# If these are present, we'll use hashicorp vault instead\n# of reading from disk\nvault_mount = \"secret\"\nvault_path_prefix = \"dkim/\"\n# To do double or triple signing, add each additional\n# signature name to this list and see the `signature.\"MyESPName\"`\n# block below\nadditional_signatures = [\"MyESPName\"]\n# Default selector to assume if the domain/signature block\n# doesn't specify one\nselector = \"dkim1024\"\n# The default set of headers to sign if otherwise unspecified\n# This reccommended set comes from section 5.4.1 of RFC 6376\n# See https://datatracker.ietf.org/doc/html/rfc6376#section-5.4\nheaders = [\n\"From\", \"Reply-To\", \"Subject\", \"Date\", \"To\", \"Cc\",\n\"Resent-Date\", \"Resent-From\", \"Resent-To\", \"Resent-Cc\",\n\"In-Reply-To\", \"References\", \"List-Id\", \"List-Help\",\n\"List-Unsubscribe\", \"List-Subscribe\", \"List-Post\",\n\"List-Owner\", \"List-Archive\"\n]\n# Domain blocks match based on the sender domain of the\n# incoming message\n[domain.\"example.com\"]\nselector = 'dkim1024'\nheaders = [\"From\", \"To\", \"Subject\", \"Date\", \"Sender\"]\nalgo = \"sha256\" # or \"ed25519\". Omit to use the default of \"sha256\"\n# optional overridden filename.\n# Default is \"/opt/kumomta/etc/dkim/DOMAIN/SELECTOR.key\"\nfilename = \"/full/path/to/key.\"\n# TODO: reception-time policy for signing based on DNS.\npolicy = \"TempFailIfNotInDNS\" # Reject\n#policy = \"SignAlways\"         # Sign and relay\n#policy = \"SignOnlyIfInDNS\"    # Don't sign. Allow fallback to additional_signatures\n# The signature block is independent of the sender domain.\n# They are consulted based on the value of `base.additional_signatures`\n# above.\n# In addition to the same values that are found in the `domain` block,\n# the following keys are supported\n[signature.\"MyESPName\"]\n# Policy is interpreted differently for these\npolicy = \"Always\" # Always add this signature\n#policy = \"OnlyIfMissingDomainBlock\" # Use this as a fallback\n# specifies the signing domain for this signature block\ndomain = \"myesp.com\"\n</code></pre>"},{"location":"userguide/configuration/dkim/#implementing-dkim-signing-using-lua","title":"Implementing DKIM Signing using Lua","text":"<p>Configure KumoMTA to sign emails passing through the MTA with DKIM signatures. This is done with Lua in policy.  The sample <code>init.lua</code> policy provided with KumoMTA declairs a basic working DKIM signer that you can copy and modify as needed.  This signs a message with <code>RSA256</code> using a selector named <code>default</code> on headers <code>From</code>, <code>To</code>, and <code>Subject</code> using the DKIM key located at example-private-dkim-key.pem. (More documentation)</p> <pre><code>local signer = kumo.dkim.rsa_sha256_signer {\ndomain = msg:from_header().domain,\nselector = 'default',\nheaders = { 'From', 'To', 'Subject' },\nfile_name = 'example-private-dkim-key.pem',\n}\n</code></pre> <p>Where you want to enable dkim signing, simply call that signer in policy.</p> <p>IE:  <code>msg:dkim_sign(signer)</code></p>"},{"location":"userguide/configuration/domains/","title":"Configuring Inbound and Relay Domains","text":"<p>When listening via SMTP, it is common to simply define a list of <code>relay_hosts</code> that are permitted to connect and relay messages through the server. Any host that connects and does not match the list of relay hosts will be allowed to connect to the server, but will not be permitted to relay mail through the server.</p> <pre><code>kumo.start_esmtp_listener {\nlisten = '0.0.0.0:25',\n-- override the default set of relay hosts\nrelay_hosts = { '127.0.0.1', '192.168.1.0/24' },\n}\n</code></pre>"},{"location":"userguide/configuration/domains/#using-the-listener_domainslua-policy-helper","title":"Using the listener_domains.lua Policy Helper","text":"<p>For most basic use cases, it will be simpler to use the <code>listener_domains.lua</code> policy helper script to manage the listener domain configuration in a simple TOML file.</p> <p>To use the helper, add the following to the top level of your server policy script:</p> <pre><code>local listener_domains = require 'policy-extras.listener_domains'\nkumo.on(\n'get_listener_domain',\nlistener_domains:setup { '/opt/kumomta/etc/listener_domains.toml' }\n)\n</code></pre> <p>Then create a text file at <code>/opt/kumomta/etc/listener_domains.toml</code> with the following format:</p> <pre><code>[\"*\"]\n# You can specify * as a default, overridden by any more explicitly defined domains.\n# Since all options are false by default, this would only be needed to default\n# An option to true for all domains.\nrelay_to = false\nlog_oob = true\nlog_arf = true\n[\"example.com\"]\n# allow relaying mail from anyone, so long as it is\n# addressed to example.com\nrelay_to = true\n[\"bounce.example.com\"]\n# accept and log OOB bounce reports sent to bounce.example.com\nlog_oob = true\n[\"fbl.example.com\"]\n# accept and log ARF feedback reports sent to fbl.example.com\nlog_arf = true\n[\"send.example.com\"]\n# relay to anywhere, so long as the sender domain is send.example.com\n# and the connected peer matches one of the listed CIDR blocks\nrelay_from = [ '10.0.0.0/24' ]\n[\"auth-send.example.com\"]\n# relay to anywhere, so long as the sender domain is auth-send.example.com\n# and the connected peer has authenticated as any of the authorization identities\n# listed below using SMTP AUTH\nrelay_from_authz = [ 'username1', 'username2' ]\n# wildcards are permitted. This will match\n# &lt;anything&gt;.example.com that doesn't have\n# another non-wildcard entry explicitly\n# listed in this set of domains.\n# Note that \"example.com\" won't match\n# \"*.example.com\".\n[\"*.example.com\"]\n# You can specify multiple options if you wish\nlog_oob = true\nlog_arf = true\nrelay_to = true\n# and you can explicitly set options to false to\n# essentially exclude an entry from a wildcard\n[\"www.example.com\"]\nrelay_to = false\nlog_arf = false\nlog_oob = false\n# Define a per-listener configuration\n[listener.\"127.0.0.1:25\".\"*.example.com\"]\nlog_oob = false\n</code></pre>"},{"location":"userguide/configuration/domains/#configuring-domains-for-relaying-bounces-and-feedback-loops","title":"Configuring Domains for Relaying, Bounces, and Feedback Loops","text":"<p>By default, if a host connects to the listener and is not listed in the <code>relay_hosts</code> directive, that host will not be permitted to inject messages. While that is acceptable for most outbound relaying, it is necessary in most use cases to also configure certain exceptions on a destination-domain basis for things such as inbound mail relay, out-of-band bounce processing, and feedback loop processing.</p> <p>When a host not on the relay_hosts list connects to a listener and issues a <code>RCPT TO</code> command, the get_listener_domain hook is fired, allowing for policy to be applied based on the destination domain of the message.</p> <p>To apply policy based on the domain, the <code>make_listener_domain</code> function is used:</p> <pre><code>kumo.on('get_listener_domain', function(domain, listener, conn_meta)\nif domain == 'example.com' then\nreturn kumo.make_listener_domain {\nrelay_to = true,\nlog_oob = true,\nlog_fbl = true,\n}\nend\nend)\n</code></pre> <p>In the preceding example, the domain <code>example.com</code> is permitted for inbound relay, resulting in messages destined for the domain being accepted and queued, while messages will also be checked for whether they are OOB or FBL messages, which are processed, logged, and discarded.</p> <p>Additional information on the <code>log_oob</code> and <code>log_arf</code> options can be found in the Configuring Bounce Classification and the Configuring Feedback Loop Processing chapters respectively.</p> <p>For more information, see the make_listener_domain page of the Reference manual.</p>"},{"location":"userguide/configuration/example/","title":"An Example Configuration","text":"<p>A default policy file is not published with KumoMTA to prevent the average installation from having an excess of commented-out boilerplate from filling production configurations.</p> <p>The following serves as an example of a complete base policy for a functional installation that addresses common use cases for a typical installation. This is not intended as a copy/paste policy file, but as an example to direct new users in developing their server policy file.</p> <p>The content of this example will be detailed in the following sections of this chapter, links will be in the comments of the example policy.</p>"},{"location":"userguide/configuration/example/#the-example-server-policy","title":"The Example Server Policy","text":"<pre><code>-- NOTE: This example policy is not meant to be used as-is, and will require some editing.\n-- We strongly recommend reading the User Guide chapter on configuration before working with\n-- this example policy. See https://docs.kumomta.com/userguide/configuration\n-- This file must be written to /opt/kumomta/etc/policy/init.lua for use.\n-- This require statement is needed in any script passed to KumoMTA.\n-- Includes from this policy script will not need this declared again.\nlocal kumo = require 'kumo'\nlocal utils = require 'policy-extras.policy_utils'\n-- Load the policy helpers to simplify common configuration use cases\nlocal shaping = require 'policy-extras.shaping'\nlocal queue_module = require 'policy-extras.queue'\nlocal listener_domains = require 'policy-extras.listener_domains'\nlocal sources = require 'policy-extras.sources'\nlocal dkim_sign = require 'policy-extras.dkim_sign'\nlocal log_hooks = require 'policy-extras.log_hooks'\n-- START SETUP\n-- Configure the sending IP addresses that will be used by KumoMTA to\n-- connect to remote systems using the sources.lua policy helper.\n-- Note that defining sources and pools does nothing without some form of\n-- policy in effect to assign messages to the source pools you have defined.\n-- WARNING: THIS WILL NOT LOAD WITHOUT THE source.toml FILE IN PLACE\n-- SEE https://docs.kumomta.com/userguide/configuration/sendingips/\nsources:setup { '/opt/kumomta/etc/policy/sources.toml' }\n-- Configure DKIM signing. In this case we use the dkim_sign.lua policy helper.\n-- WARNING: THIS WILL NOT LOAD WITHOUT the dkim_data.toml FILE IN PLACE\n-- See https://docs.kumomta.com/userguide/configuration/dkim/\nlocal dkim_signer =\ndkim_sign:setup { '/opt/kumomta/etc/policy/dkim_data.toml' }\n-- Load Traffic Shaping Automation Helper\nlocal shaper = shaping:setup_with_automation {\npublish = { 'http://127.0.0.1:8008' },\nsubscribe = { 'http://127.0.0.1:8008' },\nextra_files = { '/opt/kumomta/etc/policy/shaping.toml' },\n}\n-- Send a JSON webhook to a local network host.\n-- See https://docs.kumomta.com/userguide/operation/webhooks/\nlog_hooks:new_json {\nname = 'webhook',\nurl = 'http://10.0.0.1:4242/log',\nlog_parameters = {\nheaders = { 'Subject', 'X-Customer-ID' },\n},\n}\n-- Configure queue management settings. These are not throttles, but instead\n-- control how messages flow through the queues.\n-- WARNING: ENSURE THAT WEBHOOKS AND SHAPING ARE SETUP BEFORE THE QUEUE HELPER FOR PROPER OPERATION\n-- WARNING: THIS WILL NOT LOAD WITHOUT the queues.toml FILE IN PLACE\n-- See https://docs.kumomta.com/userguide/configuration/queuemanagement/\nlocal queue_helper =\nqueue_module:setup { '/opt/kumomta/etc/policy/queues.toml' }\n-- END SETUP\n--START EVENT HANDLERS\n-- Called On Startup, handles initial configuration\nkumo.on('init', function()\n-- Define the default \"data\" spool location; this is where\n-- message bodies will be stored.\n-- See https://docs.kumomta.com/userguide/configuration/spool/\nkumo.define_spool {\nname = 'data',\npath = '/var/spool/kumomta/data',\nkind = 'RocksDB',\n}\n-- Define the default \"meta\" spool location; this is where\n-- message envelope and metadata will be stored.\nkumo.define_spool {\nname = 'meta',\npath = '/var/spool/kumomta/meta',\nkind = 'RocksDB',\n}\n-- Configure publishing of TSA logs to automation daemon\nshaper.setup_publish()\n-- Configure logging to local disk. Separating spool and logs to separate\n-- disks helps reduce IO load and can help performance.\n-- See https://docs.kumomta.com/userguide/configuration/logging/\nkumo.configure_local_logs {\nlog_dir = '/var/log/kumomta',\nmax_segment_duration = '1 minute',\n-- headers = { 'Subject', 'X-Customer-ID' },\n}\n-- Configure bounce classification.\n-- See https://docs.kumomta.com/userguide/configuration/bounce/\nkumo.configure_bounce_classifier {\nfiles = {\n'/opt/kumomta/share/bounce_classifier/iana.toml',\n},\n}\n-- Configure HTTP Listeners for injection and management APIs.\n-- See https://docs.kumomta.com/userguide/configuration/httplisteners/\nkumo.start_http_listener {\nlisten = '0.0.0.0:8000',\n-- allowed to access any http endpoint without additional auth\ntrusted_hosts = { '127.0.0.1', '::1' },\n}\nkumo.start_http_listener {\nuse_tls = true,\nlisten = '0.0.0.0:8001',\n-- allowed to access any http endpoint without additional auth\ntrusted_hosts = { '127.0.0.1', '::1' },\n}\n-- Define an SMTP listener. Can be used multiple times with different\n-- parameters to define multiple listeners!\n-- See https://docs.kumomta.com/userguide/configuration/smtplisteners/\nkumo.start_esmtp_listener {\nlisten = '0.0.0.0:25',\nhostname = 'mail.example.com',\n-- override the default set of relay hosts\nrelay_hosts = { '127.0.0.1', '192.168.1.0/24' },\n}\n-- Add an IPv6 Listener\nkumo.start_esmtp_listener {\nlisten = '[::]:25',\nrelay_hosts = { '::1' },\n}\n-- Use shared throttles rather than in-process throttles, do not enable\n-- without first installing and configuring redis.\n-- See https://docs.kumomta.com/reference/kumo/configure_redis_throttles/\n-- kumo.configure_redis_throttles { node = 'redis://127.0.0.1/' }\nend) -- END OF THE INIT EVENT\n-- Configure listener domains for relay, oob bounces, and FBLs using the\n-- listener_domains.lua policy helper.\n-- WARNING: THIS WILL NOT LOAD WITHOUT THE listener_domains.toml FILE IN PLACE\n-- SEE https://docs.kumomta.com/userguide/configuration/smtplisteners/\nkumo.on(\n'get_listener_domain',\nlistener_domains:setup { '/opt/kumomta/etc/policy/listener_domains.toml' }\n)\n-- Configure traffic shaping using the shaping.lua policy helper.\n-- Commented out by default since we recommend using the Traffic Shaping Automation helper loaded below.\n-- WARNING: THIS WILL NOT LOAD WITHOUT AN ADDITIONAL SCRIPT IN PLACE\n-- SEE https://docs.kumomta.com/userguide/configuration/trafficshaping/\n-- kumo.on('get_egress_path_config', shaping:setup { '/opt/kumomta/share/policy-extras/shaping.toml', '/opt/kumomta/etc/policy/shaping.toml', })\n-- Call the Traffic Shaping Automation Helper to configure shaping rules.\nkumo.on('get_egress_path_config', shaper.get_egress_path_config)\n-- Processing of incoming messages via SMTP\nkumo.on('smtp_server_message_received', function(msg)\n-- Protect against SMTP Smuggling (https://sec-consult.com/blog/detail/smtp-smuggling-spoofing-e-mails-worldwide/)\nlocal failed = msg:check_fix_conformance(\n-- check for and reject messages with these issues:\n'NON_CANONICAL_LINE_ENDINGS',\n-- fix messages with these issues:\n''\n)\nif failed then\nkumo.reject(552, string.format('5.6.0 %s', failed))\nend\n-- Call the queue helper to set up the queue for the message.\nqueue_helper:apply(msg)\n-- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\ndkim_signer(msg)\nend)\n-- Processing of incoming messages via HTTP\nkumo.on('http_message_generated', function(msg)\n-- Call the queue helper to set up the queue for the message.\nqueue_helper:apply(msg)\n-- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\ndkim_signer(msg)\nend)\n-- END OF EVENT HANDLERS\n</code></pre>"},{"location":"userguide/configuration/fbl/","title":"Configuring Feedback Loop Processing","text":"<p>Feedback Loops are provided by several mailbox providers, including AOL, Hotmail, Comcast, and Yahoo! as a method for informing senders regarding which messages are receiving spam complaints.</p> <p>The mailbox providers send registered senders formatted abuse report messages to a pre-configured address in ARF format, but those messages typically do not include information that can help senders suppress future sends to the recipient that reported the message. KumoMTA can not only process and log ARF messages, but it can also inject tracking headers into the message that it can later decode to preserve recipient data needed for unsubscribing recipients that have reported messages as spam.</p> <p>For more information on Feedback Loops and how to apply for them, see https://www.emailfeedbackloops.com/.</p>"},{"location":"userguide/configuration/fbl/#configuring-tracking-headers","title":"Configuring Tracking Headers","text":"<p>By default, KumoMTA will include a supplemental tracking header that will be extracted as part of the ARF message processing. This setting is controlled by the supplemental_header option in the kumo.start_esmtp_listener function. Additional metadata can be preserved by listing the metadata keys desired in the include_meta_names argument.</p> <pre><code>kumo.start_esmtp_listener {\n-- ..\ntrace_headers = {\n-- this is the default: add the supplemental header\nsupplemental_header = true,\n-- this is the default: the name of the supplemental header\nheader_name = 'X-KumoRef',\ninclude_meta_names = { 'tenant', 'campaign' },\n},\n}\n</code></pre> <p>See the trace headers section of the start_esmtp_listener section of the reference manual for more information.</p>"},{"location":"userguide/configuration/fbl/#configuring-arf-domains","title":"Configuring ARF Domains","text":"<p>For KumoMTA to process inbound messages as ARF, the inbound receiving domain must be configured as a candidate for ARF processing.  This is most simply accomplished using the listener domains policy helper, with a snippet like this:</p> <pre><code>[\"fbl.examplecorp.com\"]\n# accept and log ARF feedback reports sent to fbl.examplecorp.com\nlog_arf = true\n</code></pre> <p>The preceding example designates that messages injected from remote hosts destined for fbl.examplecorp.com will be accepted and then processed as ARF abuse report messages.</p>"},{"location":"userguide/configuration/fbl/#message-disposition-after-processing","title":"Message Disposition After Processing","text":"<p>For most use cases, the desired outcome after a message is processed is to discard the message, but in some cases it can be desirable to forward the message for further processing or storage, especially during testing and migration.</p> <p>To queue a message after processing, add <code>relay_to = true</code> to the domain configuration:</p> <pre><code>[\"fbl.examplecorp.com\"]\n# accept and log ARF feedback reports sent to fbl.examplecorp.com\nlog_arf = true\nrelay_to = true\n</code></pre> <p>In addition, it should be noted that the MX record for your domain will still be pointed at the KumoMTA instance, which means that in order to avoid a mail loop you will need to configure routing for the domain to specify where the message should be relayed to from the KumoMTA instance, by overriding the destination queue for the message in the smtp_server_message_received event:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\nif msg:recipient():domain() == 'fbl.examplecorp.com' then\n-- Re-route the message to the intended destination\nmsg:set_meta('routing_domain', '[192.168.1.100]')\n-- In earlier versions of KumoMTA, you need to set the queue\n-- this way instead\n-- msg:set_meta('queue', '[192.168.1.100]')\nend\nend)\n</code></pre>"},{"location":"userguide/configuration/fbl/#fbl-message-logs","title":"FBL Message Logs","text":"<p>All feedback loop messages are logged to the destination configured in the configure_local_logs function, using the <code>Feedback</code> type.</p> <p>The format of a Feedback loop message log entry is as follows:</p> <pre><code>{\n\"type\": \"Feedback\",\n\"feedback_report\": {\n\"feedback_type\": \"abuse\",\n\"user_agent\": \"SomeGenerator/1.0\",\n\"version\": 1,\n\"arrival_date\": \"2005-03-08T18:00:00Z\",\n\"incidents\": nil,\n\"original_envelope_id\": nil,\n\"original_mail_from\": \"&lt;somesender@example.net&gt;\",\n\"reporting_mta\": {\n\"mta_type\": \"dns\",\n\"name\": \"mail.example.com\",\n},\n\"source_ip\": \"192.0.2.1\",\n\"authentication_results\": [\n\"mail.example.com; spf=fail smtp.mail=somesender@example.com\",\n],\n\"original_rcpto_to\": [\n\"&lt;user@example.com&gt;\",\n],\n\"reported_domain\": [\n\"example.net\",\n],\n\"reported_uri\": [\n\"http://example.net/earn_money.html\",\n\"mailto:user@example.com\",\n],\n// any fields found in the report that do not correspond to\n// those defined by RFC 5965 are collected into this\n// extensions field\n\"extensions\": {\n\"removal-recipient\": [\n\"user@example.com\",\n],\n},\n// The original message or message headers, if provided in\n// the report\n\"original_message\": \"From: &lt;somesender@example.net&gt;\nReceived: from mailserver.example.net (mailserver.example.net\n    [192.0.2.1]) by example.com with ESMTP id M63d4137594e46;\n    Tue, 08 Mar 2005 14:00:00 -0400\nX-KumoRef: eyJfQF8iOiJcXF8vIiwicmVjaXBpZW50IjoidGVzdEBleGFtcGxlLmNvbSJ9\nTo: &lt;Undisclosed Recipients&gt;\nSubject: Earn money\nMIME-Version: 1.0\nContent-type: text/plain\nMessage-ID: 8787KJKJ3K4J3K4J3K4J3.mail@example.net\nDate: Thu, 02 Sep 2004 12:31:03 -0500\nSpam Spam Spam\nSpam Spam Spam\nSpam Spam Spam\nSpam Spam Spam\n\",\n// if original_message is present, and a kumo-style trace\n// header was decoded from it, then this holds the decoded\n// trace information\n\"supplemental_trace\": {\n\"recipient\": \"test@example.com\",\n},\n}\n}\n</code></pre>"},{"location":"userguide/configuration/httplisteners/","title":"Configuring HTTP Listeners","text":"<p>An HTTP listener can be defined with a <code>kumo.start_http_listener</code> function.  In the example below you can see the definition of IP address, Port, and specific trusted hosts that are permitted to to use that listener.</p> <p>Each listener can have its own trust list, hostname and TLS settings.</p> <pre><code>kumo.start_http_listener {\nlisten = '0.0.0.0:8000',\n-- allowed to access any http endpoint without additional auth\ntrusted_hosts = { '127.0.0.1', '::1' },\nuse_tls = true,\n}\n</code></pre> <p>Refer to the Reference Manual for detailed options.</p>"},{"location":"userguide/configuration/httplisteners/#what-can-you-use-the-http-listener-for","title":"What can you use the HTTP listener for?","text":"<p>Aside from injecting messages using the Inject API, you can also perform arbitrary administrative bounces, and collect detailed metrics.  A list of HTTP API functions exists here.</p>"},{"location":"userguide/configuration/httplisteners/#configuring-for-https","title":"Configuring for HTTPS","text":"<p>The HTTP listener can easily be secured with TLS by adding the TLS directives and a certificate to the configuration.  Below is an example of an HTTPS configuration.</p> <pre><code>kumo.start_http_listener {\ntrusted_hosts = { '127.0.0.1', '::1' },\nlisten = '0.0.0.0:443',\nhostname = 'mail.example.com',\nuse_tls = true,\ntls_certificate = '/path/to/cert.pem',\ntls_private_key = '/path/to/key.pem',\n--[[ Alternately configure to pull the certificate from HashiCorp Vault ]]\n--\n--[[\n   tls_certificate = {\n    vault_mount = 'secret',\n    vault_path = 'tls/mail.example.com.cert',\n    vault_address = \"http://127.0.0.1:8200\",\n    vault_token = \"hvs.TOKENTOKENTOKEN\",\n  },\n]]\n--\n}\n</code></pre>"},{"location":"userguide/configuration/logging/","title":"Configuring Logging","text":"<p>By default, KumoMTA writes to a (zstd compressed) JSON log format, the details of which can be found on the Logging Reference Page,</p>"},{"location":"userguide/configuration/logging/#basic-log-configuration","title":"Basic Log Configuration","text":"<p>The simplest logging configuration, added to the init event, is as follows:</p> <pre><code>kumo.configure_local_logs {\nlog_dir = '/var/log/kumomta',\n-- We recommend setting this when you're getting started;\n-- this option is discussed in more detail below\nmax_segment_duration = '10 seconds',\n}\n</code></pre> <p>For multiple log files, the <code>configure_local_logs</code> function can be called multiple times with different parameters.</p> <p>Note</p> <p>Logs can also be published as webhooks. See the Publishing Log Events Via Webhooks chapter.</p>"},{"location":"userguide/configuration/logging/#os-considerations","title":"OS Considerations","text":"<p>The log directory should be isolated to its own partition, in order to prevent a full log partition from affecting the overall server. For best performance, the log directory should be on a separate disk from the spool. The log partition should be monitored to ensure that the disk does not fill to 100% capacity.</p>"},{"location":"userguide/configuration/logging/#compression-and-rotation","title":"Compression and Rotation","text":"<p>The server writes logs as a series of zstd compressed files, resulting in high storage efficiency as logs are written, instead of having to write large files to disk and compress them during file rotation.</p> <p>By default, files are rotated after every 1Gb of uncompressed log data, resulting in files on disk that are approximately 50MB in size. The maximum size is configurable, see the Logging Reference Page.</p> <p>Logs can be viewed in real time using the <code>tailer</code> utility:</p> <pre><code>$ /opt/kumomta/sbin/tailer --tail /var/log/kumomta\n/var/tmp/kumo-logs/20231013-003826\n{\"type\":\"Reception\",\"id\":\"d69b7572696011eebb51227d27bbd7ab\",...}\n{\"type\":\"TransientFailure\",\"id\":\"d69b7572696011eebb51227d27bbd7ab\",...}\nwaiting for more files\n</code></pre> <p>Logs will appear as the segment files are flushed, which happens as zstd accumulates enough data to write out a block, or when the <code>max_file_size</code> is reached, or when shutting down the server.</p> <p>It is possible to configure KumoMTA to rotate logs on a time interval basis, so that you can see log records emerge more quickly when you are first experimenting with kumomta and have very little load:</p> <pre><code>kumo.configure_local_logs {\n-- ..\nmax_segment_duration = '10 seconds',\n}\n</code></pre> <p>See the Logging Reference Page for more information on this setting.</p>"},{"location":"userguide/configuration/logging/#logging-message-headers","title":"Logging Message Headers","text":"<p>It's a common practice to encode important per-user or per-campaign information in message headers, or to use a message Subject line as an identifier in reporting. This requires logging the headers, which can be achieved by specifying the desired headers in the configuration:</p> <pre><code>kumo.configure_local_logs {\n-- ..\nheaders = { 'Subject', 'X-Client-ID' },\n}\n</code></pre>"},{"location":"userguide/configuration/logging/#customizing-the-log-format","title":"Customizing the log format","text":"<p>If a non-JSON format is needed for the logs, the template option can be used:</p> <pre><code>kumo.configure_local_logs {\n-- ..\ntemplate = [[{{type}} id={{ id }}, from={{ sender }} code={{ code }} age={{ timestamp - created }}]],\n}\n</code></pre> <p>The Mini Jinja templating engine is used to evalute logging templates.  The full supported syntax is documented here. Any key present in the default log format can be used in the templating engine.</p>"},{"location":"userguide/configuration/logging/#configuring-individual-record-types","title":"Configuring Individual Record Types","text":"<p>Sometimes it is necessary to configure logging on a more granular basis, especially when using custom log formats. KumoMTA supports this using the per_record option:</p> <pre><code>kumo.configure_local_logs {\nper_record = {\nReception = {\n-- use names like \"20230306-022811_recv\" for reception logs\nsuffix = '_recv',\n},\nDelivery = {\n-- put delivery logs in a different directory\nlog_dir = '/var/log/kumo/delivery',\n},\nTransientFailure = {\n-- Don't log transient failures\nenable = false,\n},\nBounce = {\n-- Instead of logging the json record, evaluate this\n-- template string and log the result.\ntemplate = [[Bounce! id={{ id }}, from={{ sender }} code={{ code }} age={{ timestamp - created }}]],\n},\n-- For any record type not explicitly listed, apply these settings.\n-- This effectively turns off all other log records\nAny = {\nenable = false,\n},\n},\n}\n</code></pre> <p>This can be used to override paths, disable logs, or customize the format of specific event types.</p>"},{"location":"userguide/configuration/policy_helpers/","title":"Lua Policy Helpers","text":"<p>KumoMTA is designed around the concept of configuration as code, where all configuration of KumoMTA is implemented through Lua policy rather than static text files.</p> <p>Configuration as code offers numerous advantages, including late loading of config for lower memory consumption and minimal reloads and direct data source connectivity to make your KumoMTA instances a well-integrated part of your DevOps environment rather than a black box that requires automated config file updates and reload commands to be issued.</p> <p>Configuration as code enables advanced use cases such as storing your DKIM signing keys in HashiCorp Vault for realtime DKIM signing and checking SMTP Authentication credentials against a live data source.</p> <p>While configuration as code provides extreme flexibility and deep integration capabilities, that can come at the cost of complexity. In order to make KumoMTA more accessible for those who are accustomed to a static configuration file and don't need deeper integration, we have developed a set of policy helpers. These helpers are premade Lua policy scripts that implement common use cases by reading formatted TOML and JSON files to configure KumoMTA.</p>"},{"location":"userguide/configuration/policy_helpers/#an-example","title":"An Example","text":"<p>For example, DKIM signing can be implemented using Lua directly in the following example:</p> <pre><code>-- Called once the body has been received.\n-- For multi-recipient mail, this is called for each recipient.\nkumo.on('smtp_server_message_received', function(msg)\nlocal signer = kumo.dkim.rsa_sha256_signer {\ndomain = msg:from_header().domain,\nselector = 'default',\nheaders = { 'From', 'To', 'Subject' },\nkey = 'example-private-dkim-key.pem',\n}\nmsg:dkim_sign(signer)\nend)\n</code></pre> <p>Or even dynamically configured against a data source:</p> <pre><code>function get_key(domain, selector)\nlocal db = sqlite:open '/opt/kumomta/etc/dkim/keys.db'\nlocal result = db:execute(\n'select data from keys where domain=? and selector=?',\ndomain,\nselector\n)\nreturn result[1]\nend\nlocal sqlite_signer = kumo.dkim.rsa_sha256_signer {\nkey = {\nkey_data = get_key(msg:from_header().domain, 'default'),\n},\n}\n</code></pre> <p>A more straightforward implementation can be performed by using the DKIM signing helper:</p> <pre><code>local dkim_sign = require 'policy-extras.dkim_sign'\nlocal dkim_signer = dkim_sign:setup { '/opt/kumomta/etc/dkim_data.toml' }\nkumo.on('smtp_server_message_received', function(msg)\n-- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\ndkim_signer(msg)\nend)\nkumo.on('http_message_generated', function(msg)\n-- SIGNING MUST COME LAST OR YOU COULD BREAK YOUR DKIM SIGNATURES\ndkim_signer(msg)\nend)\n</code></pre> <p>With the helper code in place, users can manage a simple TOML or JSON file to control DKIM signing:</p> <pre><code>[domain.\"example.com\"]\nselector = 'dkim1024'\nheaders = [\"From\", \"To\", \"Subject\", \"Date\", \"MIME-Version\", \"Content-Type\", \"Sender\"]\nalgo = \"sha256\"\n# optional overridden filename.\n# Default is \"/opt/kumomta/etc/dkim/DOMAIN/SELECTOR.key\"\nfilename = \"/full/path/to/key.\"\n</code></pre> <p>This approach allows for full control of DKIM signing without the need to implement a data integration or fully code the signing parameters in Lua.</p>"},{"location":"userguide/configuration/policy_helpers/#current-kumomta-policy-helpers","title":"Current KumoMTA Policy Helpers","text":"<p>All policy helpers listed below are implemented in the Example Lua Policy and can be used to simplify your KumoMTA installation. In addition, the policy helper source code is available to use as a starting point for developing your own integrated configuration: where the helpers are pulling from a TOML or JSON file, they could be modified to connect directly to a data source.</p> <ul> <li>Listener_Domains - Helper for configuring which domains are allowed to relay, process bounces, and process abuse reports.</li> <li>Sources - Helper for configuring the egress sources and pools used for relaying messages.</li> <li>Queues - Helper for configuring tenant and queue configuration, including retry intervals, tenant identifier headers, and the mapping from tenant to egress pool.</li> <li>Shaping - Helper for configuring traffic shaping rules to use for destination domains. Also can be configured for Traffic Shaping Automation.</li> <li>Dkim_Sign - Helper for configuring parameters for DKIM signing for each signing domain.</li> <li>Log_Hooks - Helper for configuring webhooks.</li> </ul>"},{"location":"userguide/configuration/queuemanagement/","title":"Configuring Queue Management","text":"<p>After a message is injected, it is placed into a Scheduled Queue based on the combination of its Campaign, Tenant, Destination and Routing Domains. If any of these attributes are not set, the queue will be based on whichever elements are present. The Scheduled Queue is also used for messages that encountered a temporary failure and are awaiting a retry. See Configuration Concepts for more information.</p>"},{"location":"userguide/configuration/queuemanagement/#using-the-queues-helper","title":"Using The Queues Helper","text":"<p>To help simplify configuration for those with typical use cases, we have provided the queue.lua policy helper.</p> <p>The queue.lua policy helper simplifies configuration of queue management, including identifying and assigning tenant and campaign information as well as message scheduling.</p> <p>To use the queue.lua policy helper, adding the following to your init.lua policy:</p> <pre><code>local queue_module = require 'policy-extras.queue'\nlocal queue_helper =\nqueue_module:setup { '/opt/kumomta/etc/policy/queues.toml' }\n</code></pre> <p>In addition, create a file at <code>/opt/kumomta/etc/queues.toml</code> and populate it as follows:</p> <pre><code># Allow optional scheduled sends based on this header\n# https://docs.kumomta.com/reference/message/import_scheduling_header\nscheduling_header = \"X-Schedule\"\n# Set the tenant from this header and delete the header for added security\ntenant_header = \"X-Tenant\"\nremove_tenant_header = true\n# Set the campaign from this header and delete the header for added security\ncampaign_header = \"X-Campaign\"\nremove_campaign_header = true\n# The tenant to use if no tenant_header is present\ndefault_tenant = \"default-tenant\"\n[tenant.'default-tenant']\negress_pool = 'pool-1'\n[tenant.'mytenant']\n# Which pool should be used for this tenant\negress_pool = 'pool-2'\n# Override maximum message age based on tenant; this overrides settings at the domain level\nmax_age = '10 hours'\n# Only the authorized identities are allowed to use this tenant via the tenant_header\n#require_authz = [\"scott\"]\n# The default set of parameters\n[queue.default]\nmax_age = '24 hours'\n# Base settings for a given destination domain.\n# These are overridden by more specific settings\n# in a tenant or more specific queue\n[queue.'gmail.com']\nmax_age = '22 hours'\nretry_interval = '17 mins'\n[queue.'gmail.com'.'mytenant']\n# options here for domain=gmail.com AND tenant=mytenant for any unmatched campaign\n[queue.'gmail.com'.'mytenant'.'welcome-campaign']\n# options here for domain=gmail.com, tenant=mytenant, and campaign='welcome-campaign'\n</code></pre>"},{"location":"userguide/configuration/queuemanagement/#configuring-message-life-and-retry-times-using-lua","title":"Configuring Message Life and Retry Times Using Lua","text":"<p>There is no throttling configured at the Scheduled Queue level, instead, the Scheduled Queue is where messages are evaluated when retries are needed, meaning that at the Scheduled Queue level we configure settings such as the time between retries and the maximum age of a message.</p> <p>The settings for retry interval and message age are typically set globally and then overridden on a per-tenant basis.</p> <p>In the example below, a collection of per-tenant parameters is created, with global parameters set separately. When the get_queue_config  event fires, the two collections are merged and the resulting collection of parameters is passed to the <code>kumo.make_queue_config</code> function and passed back to the event handler.  See the make_queue_config page of the Reference Manual for more information.</p> <p>While the event includes arguments for the destination domain, tenant, and campaign, this example is based on the assumption that queue configuration is only customized at the tenant level:</p> <pre><code>local kumo = require 'kumo'\nlocal utils = require 'policy-extras.policy_utils'\nlocal TENANT_PARAMS = {\nTenantOne = {\nmax_age = '5 minutes',\n},\n}\nkumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nlocal params = {\nmax_age = '5 minutes',\nretry_interval = '10 minutes',\nmax_retry_interval = '100 minutes',\n}\nutils.merge_into(TENANT_PARAMS[tenant] or {}, params)\nreturn kumo.make_queue_config(params)\nend)\n</code></pre> <p>Note that the example above is designed specifically to show one method of storing and managing the parameters of the kumo.make_queue_config function, but users are free to store and combine parameters as they see fit.</p>"},{"location":"userguide/configuration/queuemanagement/#configuring-egress-pool-assignment-using-lua","title":"Configuring Egress Pool Assignment Using Lua","text":"<p>It's not enough to configure an Egress Pool, the server must also have assignment logic to determine which Egress pool should be used for a given message.</p> <p>Any logic can be used for Egress Pool assignment, leveraging the domain, tenant, and campaign provided for the get_queue_config event. This example is based on the idea that the Egress Pool will be named after the message's tenant:</p> <pre><code>local kumo = require 'kumo'\nlocal utils = require 'policy-extras.policy_utils'\nlocal TENANT_PARAMS = {\nTenantOne = {\nmax_age = '5 minutes',\n},\n}\nkumo.on('get_queue_config', function(domain, tenant, campaign)\nlocal params = {\nmax_age = '5 minutes',\nretry_interval = '10 minutes',\nmax_retry_interval = '100 minutes',\n-- Here we are assuming that there is an egress_pool configured\n-- for each valid tenant. If tenant is nil then the built-in\n-- \"unspecified\" egress pool will be used.\negress_pool = tenant,\n}\nutils.merge_into(TENANT_PARAMS[tenant] or {}, params)\nreturn kumo.make_queue_config(params)\nend)\n</code></pre> <p>An example of assigning a tenant name to a message is as follows, occurring during the smtp_server_message_received event, in this case using the tenant name stored in a header called <code>X-Tenant:</code></p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\n-- Assign tenant based on X-Tenant header.\nlocal tenant = msg:get_first_named_header_value 'X-Tenant'\nif tenant then\nmsg:set_meta('tenant', tenant)\nend\nend)\n</code></pre> <p>Note that the example above does not have any handling for an empty or incorrect X-Tenant header.</p>"},{"location":"userguide/configuration/sendingips/","title":"Configuring Sending IPs","text":"<p>By default, all traffic injected to the KumoMTA server will be delivered using the default interface configured on the host server. For smaller installations this is acceptable, but best practices recommend separating mail streams into their own IPs addresses in order to isolate reputation and enable larger sending volumes than would be possible on a single IP address.</p>"},{"location":"userguide/configuration/sendingips/#using-the-sourceslua-policy-helper","title":"Using the sources.lua Policy Helper","text":"<p>While the process for creating Egress Sources and Pools is defined below, most users will want to take advantage of the <code>sources.lua</code> policy helper. This is a supplemental script that takes care of the creation logic by leveraging a TOML configuration file you define.</p> <p>To use the <code>sources.lua</code> policy helper, add the following to your server policy script:</p> <pre><code>-- Configure source IPs.\nlocal sources = require 'policy-extras.sources'\nsources:setup { '/opt/kumomta/etc/sources.toml' }\n</code></pre> <p>In addition, create a file at <code>/opt/kumomta/etc/sources.toml</code> and populate it as follows:</p> <pre><code>[source.\"ip-1\"]\nsource_address = \"10.0.0.1\"\nehlo_domain = 'mta1.examplecorp.com'\n[source.\"ip-2\"]\nsource_address = \"10.0.0.2\"\nehlo_domain = 'mta2.examplecorp.com'\n[source.\"ip-3\"]\nsource_address = \"10.0.0.3\"\nehlo_domain = 'mta3.examplecorp.com'\n# Pool containing just ip-1, which has weight=1\n[pool.\"pool-1\"]\n[pool.\"pool-1\".\"ip-1\"]\n# Pool with multiple ips\n[pool.\"pool-2\"]\n[pool.\"pool-2\".\"ip-2\"]\nweight = 2\n# We're warming up ip-3, so use it less frequently than ip-2\n[pool.\"pool-2\".\"ip-3\"]\nweight = 1\n</code></pre> <p>The sources you define can include any options listed for the make_egress_source function.</p>"},{"location":"userguide/configuration/sendingips/#assigning-messages-to-pools","title":"Assigning Messages to Pools","text":"<p>It's not enough to simply create an Egress Source and assign it to an Egress Pool, the server requires explicit logic to know which message is assigned to which Egress Pool.</p> <p>This logic occurs in the events related to queue management, see the Queue Management chapter for more information.</p>"},{"location":"userguide/configuration/sendingips/#provisioning-egress-sources-using-lua","title":"Provisioning Egress Sources Using Lua","text":"<p>Note</p> <p>Most users will be satisfied with using the policy helper shown above. This section and the remainder of this page is for more advanced users.</p> <p>In KumoMTA, source IPs are described in an Egress Source. And Egress Source represents an object that can be used to send messages and is not attached to a particular protocol. While the most common use case is an IP address used for SMTP, it could also define a specific outbound port for sending through port-based NAT, or a specific configuration for sending over HTTP.</p> <p>An Egress Source is defined using the <code>kumo.make_egress_source</code> function, called during the init event. For more information, see the make_egress_source chapter of the Reference Manual.</p> <p>By default, the only option required for defining an Egress Source is a name, creating a logical grouping for messages used for queueing but still using the default server IP address:</p> <pre><code>kumo.on('get_egress_source', function(source_name)\nif source_name == 'ip-1' then\nreturn kumo.make_egress_source {\nname = 'ip-1',\n}\nend\nerror 'you need to do something for other source names'\nend)\n</code></pre> <p>Typically an Egress source is used to assign messages to a specific IP address for sending. It is a best practice for each source IP to have a unique hostname used during the EHLO command, that matches a PTR record that points to the external IP associated with the Egress Source. The IP address is set with the source address option and the hostname is set using the ehlo_domain option. The IP address used is not required to be unique to a given Egress Source:</p> <pre><code>kumo.on('get_egress_source', function(source_name)\nif source_name == 'ip-1' then\n-- Make a source that will emit from 10.0.0.1\nkumo.make_egress_source {\nname = 'ip-1',\nsource_address = '10.0.0.1',\nehlo_domain = 'mta1.examplecorp.com',\n}\nend\nerror 'you need to do something for other source names'\nend)\n</code></pre> <p>KumoMTA supports both IPv4 and IPv6 for sending, based on the source address assigned to the Egress Source:</p> <pre><code>kumo.on('get_egress_source', function(source_name)\nif source_name == 'ip-1' then\n-- Make a source that will emit from 10.0.0.1\nkumo.make_egress_source {\nname = 'ip-1',\nsource_address = '2001:db8:3333:4444:5555:6666:7777:8888',\nehlo_domain = 'mta2.examplecorp.com',\n}\nend\nerror 'you need to do something for other source names'\nend)\n</code></pre>"},{"location":"userguide/configuration/sendingips/#provisioning-egress-pools-using-lua","title":"Provisioning Egress Pools Using Lua","text":"<p>Note</p> <p>Most users will be satisfied with using the policy helper shown above. This section and the remainder of this page is for more advanced users.</p> <p>Messages cannot be assigned directly to an Egress Source, but are instead assigned to an Egress Pool. An Egress Pool contains one or more Egress Sources, and messages assigned to the pool are assigned in a round-robin fashion by default, with weighted round-robin available as an option.</p> <p>A given Egress Source can be added to multiple Egress Pools.</p> <p>Egress Pools are defined using the <code>kumo.make_egress_pool</code> function, called during the <code>get_egress_pool</code> event:</p> <pre><code>-- Maps a source name to the corresponding IP address\nlocal SOURCE_TO_IP = {\n['ip-1'] = '10.0.0.1',\n['ip-2'] = '10.0.0.2',\n['ip-3'] = '10.0.0.3',\n}\n-- This makes it convenient to author the pools, but is not as efficient\n-- as it could be. That is balanced out by using memoize below.\nfunction setup_pools()\nlocal pools = {\n{\nname = 'BestReputation',\nentries = {\n{ name = 'ip-1' },\n},\n},\n{\nname = 'MediumReputation',\nentries = {\n{ name = 'ip-2', weight = 2 },\n-- we're warming up ip-3, so use it less frequently than ip-2\n{ name = 'ip-3', weight = 1 },\n},\n},\n}\nlocal result = {}\nfor _, pool in ipairs(pools) do\nresult[pool.name] = kumo.make_egress_pool(pool)\nend\nreturn result\nend\n-- Wrap setup_pools as a caching version called get_pool_config\nlocal get_pool_config = kumo.memoize(setup_pools, {\nname = 'setup-my-pools',\nttl = '5 minutes',\ncapacity = 10,\n})\nkumo.on('get_egress_source', function(source_name)\nreturn kumo.make_egress_source {\nname = source_name,\nsource_address = SOURCE_TO_IP[source_name],\n}\nend)\nkumo.on('get_egress_pool', function(pool_name)\nlocal pools = get_pool_config()\nreturn pools[pool_name]\nend)\n</code></pre> <p>For more information, see the make_egress_pool chapter of the Reference Manual.</p>"},{"location":"userguide/configuration/smtplisteners/","title":"Configuring SMTP Listeners","text":"<p>An SMTP listener can be defined using the <code>kumo.start_esmtp_listener</code> function.</p> <p>The <code>kumo.start_esmtp_listener</code> function can be called multiple times to define multiple listeners. Each listener can have its own relay list, banner, hostname and list of controls to determine domain behavior.</p> <p>In the example below you can see the definition of IP address, Port, and specific relay hosts that are permitted to use that listener.</p> <pre><code>kumo.start_esmtp_listener {\nlisten = '0.0.0.0:25',\nhostname = 'mail.example.com',\nrelay_hosts = { '127.0.0.1', '192.168.1.0/24' },\n}\n</code></pre> <p>Refer to the start_esmtp_listener chapter of the Reference Manual for detailed options.</p> <p>For most use cases, it will be necessary to configure listeners on a per-domain basis regarding inbound traffic. This includes designating which domains are allowed for inbound relay and bounce/feedback loop processing. See the Configuring Inbound and Relay Domains section of the User Guide for more information.</p>"},{"location":"userguide/configuration/smtplisteners/#securing-inbound-smtp-listeners-with-smtp-auth","title":"Securing Inbound SMTP Listeners with SMTP AUTH","text":"<p>While the <code>relay_hosts</code> option is often sufficient when receiving mail from internal systems, those environments that receive messages from external hosts should considering implementing SMTP AUTH authentication using username/password.</p> <p>For more information, see the Checking Inbound SMTP Authentication page.</p>"},{"location":"userguide/configuration/spool/","title":"Configuring Spooling","text":"<p>KumoMTA uses separate storage areas for metadata and message contents, named meta and data respectively. The spool is defined as part of the init event within the server's init.lua policy.</p> <p>KumoMTA supports multiple message spooling options.</p> <p>There are two kinds of spool storage possible, detailed below.</p> <p>Note</p> <p>We recommend that most users deploy using RocksDB.</p>"},{"location":"userguide/configuration/spool/#localdisk","title":"LocalDisk","text":"<p>LocalDisk writes to the specified path on disk, separating messages from their metadata. LocalDisk will have a heavy performance dependency on your filesystem IO performance, and it is strongly recommended that the spool be mounted on separate storage from the logs and the rest of the server OS for maximum performance. If SSD drives are not used, 15K RPM disks are recommended. When using disk spooling, we recommend using ext4 with the noatime flag.</p> <pre><code>LABEL=/var/spool/kumomta/data /var/spool/kumomta/data ext4 rw,noatime,barrier=0 0 2\n</code></pre> <p>LocalDisk is the default, so it does not need to be explicitly specified:</p> <pre><code>kumo.on('init', function()\nkumo.define_spool {\nname = 'data',\npath = '/var/spool/kumo/data',\n}\nkumo.define_spool {\nname = 'meta',\npath = '/var/spool/kumo/meta',\n}\nend)\n</code></pre> <p>For additional performance, you can configure your listeners to defer spooling on their messages, see the Configuring SMTP Listeners page for more information.</p>"},{"location":"userguide/configuration/spool/#rocksdb","title":"RocksDB","text":"<p>A higher performance option is RocksDB.</p> <p>RocksDB makes heavy use of memory buffers and intelligent layout of storage to reduce I/O cost and increase performance. This gives increased performance similar to deferred spooling but with less risk because RocksDB uses a write-ahead-log and a background sync thread.</p> <pre><code>kumo.define_spool {\nname = 'data',\npath = '/var/spool/kumo/data',\nkind = 'RocksDB',\n}\nkumo.define_spool {\nname = 'meta',\npath = '/var/spool/kumo/meta',\nkind = 'RocksDB',\n}\n</code></pre>"},{"location":"userguide/configuration/trafficshaping/","title":"Configuring Traffic Shaping","text":"<p>By default, the KumoMTA server will send messages in the Ready Queue as fast as possible, with unlimited messages per connection. Because each Mailbox Provider (MBP) has their own expectations around how remote hosts should behave, best practices require that a sender employ a number of different traffic shaping throttles dependent on the destination provider and the reputation of the source IP.</p> <p>When KumoMTA needs to connect to a remote host to deliver messages, the get_egress_path_config is fired in order to define what configuration to use for the path.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, egress_source, site_name)\nreturn kumo.make_egress_path {\nenable_tls = 'OpportunisticInsecure',\n}\nend)\n</code></pre> <p>The kumo.make_egress_path function is called with the relevant parameters for the connection, determined by the Domain, Egress Source, and Site Name.</p> <p>Where the Domain in the event call is the actual domain from the recipient address (for example, corp.com for a message destined to user@corp.com), the site_name is defined in the server by building a string representation of all MX servers that service the destination domain.</p> <p>The site_name concept allows managing traffic more effectively for domains that have several or even a great many aliases. Rather than treating each domain as a separate destination, the traffic can be grouped and managed more closely to how the receiving site sees it: as one source.</p> <p>Many of the largest Mailbox Providers handle multiple domains, so queueing by site_name allows those organizations to be treated as a single entity for queueing and traffic shaping rather than as a large collection of single domains. For example, if all Gmail hosted mail was queued and throttled based on destination domain, an MTA would make thousands of excess connections to the Gmail servers, because it would consider every domain that routes to the Gmail servers as a separate and distinct entity with its own servers, potentially resulting in failures and throttling. Instead, KumoMTA assigns the same site_name to each message destined for a Gmail-hosted domain because the group of MX servers is the same.</p> <p>Messages in the Ready Queue are grouped into separate queues based on the combination of egress_source and site_name. The domain is provided for convenience when working on what parameters to use.</p>"},{"location":"userguide/configuration/trafficshaping/#using-the-shapinglua-helper","title":"Using The Shaping.lua Helper","text":"<p>While you can use whatever Lua policy you see fit to determine which traffic-shaping rules you wish to use for sending, the shaping.lua policy file is available as both an example of how rules can be stored and retrieved from a data source, and as a default set of traffic-shaping rules.</p> <p>To use the shaping.lua helper, add the following to your init.lua, outside the init event:</p> <pre><code>local shaping = require 'policy-extras.shaping'\nkumo.on('get_egress_path_config', shaping:setup())\n</code></pre> <p>The shaping.lua policy reads a TOML file that is maintained by the community and included in all repos, also found at https://github.com/KumoCorp/kumomta/blob/main/assets/policy-extras/shaping.toml, and which is structured as follows:</p> <pre><code>[\"default\"]\nconnection_limit = 10\nmax_connection_rate = \"100/min\"\nmax_deliveries_per_connection = 100\nmax_message_rate = \"100/s\"\nidle_timeout = \"60s\"\nenable_tls = \"Opportunistic\"\nconsecutive_connection_failures_before_delay = 100\n[\"example.com\"]\nmx_rollup = false\nmax_deliveries_per_connection = 100\nconnection_limit = 3\n</code></pre> <p>As a special case, the domain can be named default, in which case those settings will apply globally. The global settings are superseded by the domain settings, which are superseded by the source settings.</p> <p>The full set of available options is listed in the kumo.make_egress_path page of the Reference Manual.</p>"},{"location":"userguide/configuration/trafficshaping/#mx-rollups-and-option-inheritance","title":"MX Rollups and Option Inheritance","text":"<p>By default, shaping.lua treats each domain entry as applying to the site_name for the domain named, and those settings apply to any destination domain that maps to the site. If you need to explicitly override a setting for a destination domain that is not self-hosted but instead part of another site_name, you need to set the <code>mx_rollup</code> option to false when configuring the domain, as in the example above for example.com. If you configure a domain that belongs to another configured site without setting the <code>mx_rollup</code> option to false, you will cause an error.</p> <p>Consider the following example, with foo.com being a domain hosted by Yahoo!:</p> <pre><code>[\"default\"]\nconnection_limit = 10\nmax_connection_rate = \"100/min\"\nmax_deliveries_per_connection = 100\nmax_message_rate = \"100/s\"\nidle_timeout = \"60s\"\nenable_tls = \"Opportunistic\"\nconsecutive_connection_failures_before_delay = 100\n[\"yahoo.com\"]\nmax_deliveries_per_connection = 20\n[\"foo.com\"]\nmx_rollup = false\nmax_deliveries_per_connection = 50\nconnection_limit = 3\n[\"foo.com\".sources.\"IP-1\"]\nmax_deliveries_per_connection = 5\n</code></pre> <p>This example would result in the following active settings for mail being sent to foo.com on the IP-1 Egress Source:</p> <pre><code>connection_limit = 3\nmax_deliveries_per_connection = 5\nmax_connection_rate = \"100/min\"\nmax_message_rate = \"100/s\"\n</code></pre> <p>The mx_rollup option indicates whether or not the settings should apply to the domain or the site_name. In the example above, even though foo.com is hosted by Yahoo! we want to override the message throttle for the foo.com domain. The mx_rollup option is true by default and only needs to be specified for domains that override the main site name entry.</p> <p>While the default max_deliveries_per_connection is 100, it is overridden for yahoo.com (and all domains that share the same site name as the yahoo.com domain) to 20. The foo.com domain is part of the same site name as yahoo.com, but because mx_rollup is set to false the foo.com domain is treated separately and instead is set to 50. Because there is a sources entry for IP-1, the max_deliveries_per_connection is further overridden to 5 for that source's traffic in particular.</p>"},{"location":"userguide/configuration/trafficshaping/#overriding-the-shapingtoml-file","title":"Overriding the shaping.toml File","text":"<p>The <code>shaping.toml</code> file provides a community-contributed collection of traffic shaping rules that are useful for new servers, but traffic shaping rules are often configured in the context of the reputation of the various domains and IP addresses in a given environment, making it necessary to customize the rules according to your specific use cases.</p> <p>In addition, all per-source traffic shaping options must be in a user-defined shaping file since the default shaping.toml file does not suppoort per-source configuration.</p> <p>Because the shaping.toml file is part of the install repository, it should not be modified. Instead, create a separate file with your own traffic shaping rules in either TOML or JSON formats and pass it as part of the call to <code>shaping:setup()</code>:</p> <pre><code>-- load the community shaping.toml + local settings\nkumo.on(\n'get_egress_path_config',\nshaping:setup { '/opt/kumomta/etc/shaping.json' }\n)\n</code></pre> <p>You can load multiple override files too if you wish, by adding each file name to that table:</p> <pre><code>-- load the community shaping.toml + local settings\nkumo.on(\n'get_egress_path_config',\nshaping:setup {\n'/opt/kumomta/etc/shaping.toml',\n'/opt/kumomta/etc/shaping-generated.json',\n}\n)\n</code></pre> <p>When creating an override file, any settings that overlap with an existing domain definition will append any existing settings in the <code>shaping.toml</code> file, replacing any directly overlapping options.</p> <p>If you wish to discard all existing options for a domain defined in the shaping.toml file, add the replace_base = true option for that domain. The following example will replace the existing default traffic shaping options, but augment those for the other defined domains:</p> <pre><code>{\n\"default\": {\n\"replace_base\": true\n\"connection_limit\": 3,\n\"max_connection_rate\": \"100/min\",\n},\n\"yahoo.com\": {\n\"max_deliveries_per_connection\": 5,\n\"max_connection_rate\": \"20/min\",\n\"max_message_rate\": \"50/s\",\n}\n},\n\"foo.com\": {\n\"mx_rollup\": false // foo.com is hosted by yahoo.com, but we want to throttle it specifically.\n\"max_message_rate\": \"5/min\",\n},\n\"gmail.com\": {\n\"connection_limit\": 3,\n\"sources\": {\n\"ip-1\": {\n\"connection_limit\": 5\n},\n},\n},\n}\n</code></pre>"},{"location":"userguide/configuration/trafficshaping/#automating-traffic-shaping","title":"Automating Traffic Shaping","text":"<p>This section has covered how to configure traffic shaping in a static manner, but many traffic shaping decisions require real-time adjustments. See the Configuring Traffic Shaping Automation page for more information.</p>"},{"location":"userguide/configuration/trafficshapingautomation/","title":"Configuring Traffic Shaping Automation","text":"Since: Version 2023.08.22-4d895015 <p>The functionality described in this section requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>Many of the largest MailBox Providers (MBPs) operate platforms that provide feedback to senders through their response codes during the SMTP conversation. To ensure optimum throughput and deliverability, KumoMTA features Traffic Shaping Automation (TSA), via a daemon that monitors responses from the MBPs and adjusts traffic shaping rules on a granular level to ensure compliance with the guidelines of the MBPs in realtime.</p>"},{"location":"userguide/configuration/trafficshapingautomation/#tsa-architecture","title":"TSA Architecture","text":"<p>To better support clustered installations, as well as to limit load on the primary <code>kumod</code> service, Traffic Shaping Automation is implemented via a standalone daemon called <code>kumo-tsa-daemon.service</code> that is installed as a service that starts automatically when its configuration is present.</p> <p>The daemon monitors the events recorded by <code>kumod</code> and makes adjustments according to user-defined rules.</p> <p>There are three configuration locations required to implement TSA:</p> <ul> <li><code>tsa_init.lua</code> - A configuration file that controls the behavior of the TSA daemon.</li> <li><code>init.lua</code> - The server's init.lua must be modified in order to properly interact with the TSA daemon.</li> <li><code>shaping.toml</code> - A special automation entry is added to domain rules to power TSA adjustments.</li> </ul>"},{"location":"userguide/configuration/trafficshapingautomation/#configuring-the-tsa_initlua-file","title":"Configuring the <code>tsa_init.lua</code> File","text":"<p>The <code>tsa_init.lua</code> file controls the behavior of the TSA daemon, and should be written to <code>/opt/kumomta/etc/policy/tsa_init.lua</code>.</p> <p>An example of the <code>tsa_init.lua</code> file is below:</p> <pre><code>local tsa = require 'tsa'\nlocal kumo = require 'kumo'\nkumo.on('tsa_init', function()\ntsa.start_http_listener {\nlisten = '0.0.0.0:8008',\ntrusted_hosts = { '127.0.0.1', '::1' },\n}\nend)\nlocal cached_load_shaping_data = kumo.memoize(kumo.shaping.load, {\nname = 'tsa_load_shaping_data',\nttl = '5 minutes',\ncapacity = 4,\n})\nkumo.on('tsa_load_shaping_data', function()\nlocal shaping = cached_load_shaping_data {\n-- This is the default file used by the shaping helper\n-- in KumoMTA, which references the community shaping rules\n'/opt/kumomta/share/policy-extras/shaping.toml',\n-- and maybe you have your own rules\n'/opt/kumomta/etc/policy/shaping.toml',\n}\nreturn shaping\nend)\n</code></pre> <p>Warning</p> <p>Do not edit the <code>/opt/kumomta/share/policy-extras/shaping.toml</code> as it is overwritten when upgrading KumoMTA. Instead, create the <code>/opt/kumomta/etc/policy/shaping.toml</code> file as listed above and populate it with your own override rules.</p>"},{"location":"userguide/configuration/trafficshapingautomation/#changes-to-the-initlua-file","title":"Changes to the <code>init.lua</code> File","text":"<p>Note</p> <p>It's easiest to reference the Example Config to see how the complete configuration looks.</p> <p>The server's <code>init.lua</code> file will require modifications to enable it to be used with TSA.</p> <p>First, the following should be added to the start of the <code>init.lua</code> file, just below the initial <code>local kumo = require 'kumo'</code> line:</p> <pre><code>local shaping = require 'policy-extras.shaping'\nlocal shaper = shaping:setup_with_automation {\npublish = { 'http://127.0.0.1:8008' },\nsubscribe = { 'http://127.0.0.1:8008' },\nextra_files = { '/opt/kumomta/etc/policy/shaping.toml' },\n}\n</code></pre> <p>This section enabled communication with the TSA daemon. The publish and subscribe URLs correspond to the TSA daemon's HTTP listener endpoint defined in its tsa_init.lua.  For a single node deployment the values shown here are sufficient.  You may list multiple publish and/or subscribe endpoints to publish to multiple hosts and read shaping configuration from multiple hosts, respectively. In addition, while the <code>setup_with_automation</code> call is aware of the community shaping rules file, any custom file must be identified in the <code>extra_files</code> directive as seen in the example above.</p> <p>Next, the following should be added within the <code>kumo.on('init', function()</code> block:</p> <pre><code>-- Configure publishing of logs to automation daemon\nshaper.setup_publish()\n</code></pre> <p>This enables the logging required by the TSA daemon.</p> <p>Finally, the following must be added outside the init event to enable the TSA manipulations:</p> <pre><code>-- Attach various hooks to the shaper\nkumo.on('get_egress_path_config', shaper.get_egress_path_config)\n</code></pre>"},{"location":"userguide/configuration/trafficshapingautomation/#changes-to-the-shapingtoml-file","title":"Changes to the <code>shaping.toml</code> File","text":"<p>In addition to the domain-level traffic shaping rules currently in your <code>shaping.toml</code> file, you add additional automation entries based on the event you are targeting.</p> <pre><code>[[\"example.com\".automation]]\nregex = \"250 2\\\\.0\\\\.0 Ok\"\n# There is no \"trigger\" here, so the action is taken immediately\n# when a log record matches.\n# This action causes delivery to be suspended for the pathway (source + site-name)\naction = \"Suspend\"\n# for 2 hours\nduration = \"2 hours\"\n[[\"example.com\".automation]]\nregex = \"250 2\\\\.0\\\\.0 boop\"\n# sets max_connection_rate=\"100/s\"\naction = {SetConfig={name=\"max_connection_rate\", value=\"100/s\"}}\n# if we see 2 or more matches in an hour. Unlike throttles, this\n# doesn't divide down to per-second rates.\ntrigger = {Threshold=\"2/hr\"}\n# The config override will last for 2 hours\nduration = \"2 hours\"\n</code></pre> <p>The TSA daemon has two actions: temporary suspension of traffic to the triggering combination of egress source and site name, and adjustment of the traffic shaping rules to the triggering combination of egress source and site name.</p> <p>For more information, see the Traffic Shaping Automation Rules page in the Reference Manual.</p>"},{"location":"userguide/configuration/trafficshapingautomation/#monitoring-the-tsa-daemon","title":"Monitoring the TSA Daemon","text":"<p>Adjustments to the traffic shaping rules are achieved by creating a custom <code>shaping.toml</code> file that is maintained by the TSA daemon and loaded as an overlay on the existing `shaping.toml file created by the user.</p> <p>The generated TOML can be monitored by making an HTTP request. One example using curl:</p> <pre><code>$ curl -s 'http://localhost:8008/get_config_v1/shaping.toml'\n# Generated by tsa-daemon\n# Number of entries: 0\n</code></pre> <p>This call returns the current set of shaping rules in the same format as shaping.toml, the example is of an empty set.</p>"},{"location":"userguide/configuration/trafficshapingautomation/#debugging-tips","title":"Debugging Tips","text":"<p>If the tsa-deamon does not appear to be working, you can check to see if it is running with 'sudo systemctl status kumo-tsa-daemon' which should return a message that includes \"active (running)\".  If not you can stop and start it in a similar way.</p> <pre><code>sudo systemctl stop kumo-tsa-daemon\nsudo systemctl start kumo-tsa-daemon\n</code></pre> <p>Data for the TSA daemon is just like any other message in KumoMTA and will follow the same retry rules. The default is to retry in 20 minutes with exponential fallback.  If desired, this (or any other) scheduled queue can be customized with the get_queue_config hook.</p>"},{"location":"userguide/general/about/","title":"About This Manual","text":"<p>This is the Reference Manual for the KumoMTA SMTP server, version 1.0, through release 1.0. For license information, see the Legal Notices.</p> <p>Because this manual serves as a reference, it does not provide general instruction on SMTP or email infrastructure concepts. It also does not teach you how to use your operating system or command-line interpreter.</p> <p>The KumoMTA Software is under constant development, and this Manual is updated frequently as well.</p> <p>If you have questions about using KumoMTA, community support is available in the Forum and the Community Discord.</p>"},{"location":"userguide/general/about/#typographical-and-syntax-conventions","title":"Typographical and Syntax Conventions","text":"<p>This manual uses certain typographical conventions:</p> <p>Note</p> <p>This is a noteworthy section</p> <p>Warning</p> <p>This indicates a warning</p> <p>Danger</p> <p>This indicates something that can have dangerous consequences</p> <p><code>Text in this style</code> indicates input that you type in examples.</p> <p><code>Text in this style</code> indicates the names of executable programs and scripts, examples being <code>kumod</code> (the KumoMTA server executable).</p> <p><code>Text in this style</code> is used for variable input for which you should substitute a value of your own choosing.</p> <p>Text in this style is used for emphasis.</p> <p>Text in this style is used in table headings and to convey especially strong emphasis.</p> <p><code>Text in this style</code> is used to indicate a program option that affects how the program is executed, or that supplies information that is needed for the program to function in a certain way. Example: \u201cThe <code>--policy</code> option tells the <code>kumod</code> server the path to the initial policy file to execute on startup\u201d.</p> <p>File names and directory names are written like this: \u201cThe <code>simple-policy.lua</code> file is located in the <code>/etc/kumod</code> directory.\u201d</p> <p>Character sequences are written like this: \u201cTo specify a wildcard, use the <code>\u2018%\u2019</code> character.\u201d</p> <p>When commands or statements are prefixed by a prompt, we use these:</p> <pre><code>$&gt; type a command here\n#&gt; type a command as root here\nkumo&gt; type a KumoMTA CLI command here\n</code></pre> <p>Commands are issued in your command interpreter. On Unix, this is typically a program such as sh, csh, or bash.</p> <p>!!!     When you enter a command or statement shown in an example, do not type the     prompt shown in the example.</p> <p>In syntax descriptions, square brackets (\u201c[\u201d and \u201c]\u201d) indicate optional words or clauses. For example, in the following statement, --user is optional:</p> <p><code>kumod</code><code>--policy simple-policy.lua [--user] someuser</code></p>"},{"location":"userguide/general/architecture/","title":"KumoMTA Architecture","text":"<p>KumoMTA was built with large-scale sending in mind.  Here are a few key ideas that shape the implementation:</p> <ul> <li>Designed for modern multi-core, multi-threaded systems - Built on top of   Tokio, the core IO scheduler will use all available   parallelism.</li> <li>High Performance spool - We recommend using the RocksDB   based spool for a combination of in-memory buffering, write-ahead logging and   asynchronous data flushing that enable the best performance while minimizing   the risk of low-durability deferred spooling solutions.</li> <li>Advanced Queueing - KumoMTA has first-class support for queuing based on the combination of   tenant, campaign and destination site.  Having separate queues make it   easier to see and manage your traffic.</li> <li>Native MX Rollup - The Destination Site concept makes it easier to shape traffic to big receiving sites   that provide service for many domains. Rather than shaping based on just the   domain name, KumoMTA will traverse the MX records for the destination and use   that information as the basis for shaping. As a result, KumoMTA sees all   G-suite hosted domains as going to the same destination without requiring   any static configuration.  The same approach works for any domains that   share identical MX records, not just G-suite.</li> <li>Powerful Configuration - No limiting, bespoke, domain-specific configuration files   here! KumoMTA embeds the Lua language to express both declarative configuration   as well as enable you to express more advanced configuration to match your   policy or setup.</li> <li>Composable and logical extensibility - There are very few implicit   behaviors or actions, and those that exist are easy to control or disable.   This design principle means that new features can be delivered as new   functions or new modules that you can trigger from your policy configuration   if you wish to use them.</li> </ul>"},{"location":"userguide/general/credits/","title":"Credits","text":"<p>While KumoMTA Corporation owns all copyrights in the KumoMTA software and the KumoMTA manual, we wish to thank the following developers, contributors, and supporters who have helped make KumoMTA what it is today.</p>"},{"location":"userguide/general/credits/#developers","title":"Developers","text":"<p>The following people have made notable contributions to the KumoMTA software:</p> <ul> <li>Wez Furlong - Initial KumoMTA developer and architect.</li> </ul>"},{"location":"userguide/general/credits/#documenters","title":"Documenters","text":"<p>The following people have helped with writing the KumoMTA documentation:</p> <ul> <li> <p>Wez Furlong - Initial author of the Reference Manual sections of the documentation.</p> </li> <li> <p>Tom Mairs - Initial author of the User Guide portion of the documentation.</p> </li> <li> <p>Mike Hillyer - Initial author of the supplemental sections of the documentation.</p> </li> </ul>"},{"location":"userguide/general/credits/#contributors","title":"Contributors","text":"<p>KumoMTA benefits greatly from community contributions, and we thank our contributors, listed on our GitHub Contributions Graph.</p>"},{"location":"userguide/general/credits/#tools-used-to-create-kumomta","title":"Tools Used to Create KumoMTA","text":"<p>The following is a list of some of the tools and components that we have used to create KumoMTA. We owe our thanks to their creators for providing essential elements in our development and deployment:</p> <ul> <li>The Rust Community<ul> <li>Providers of a solid library of crates that made it much faster and easier to build than it would have been otherwise.</li> </ul> </li> </ul>"},{"location":"userguide/general/credits/#supporters","title":"Supporters","text":"<p>The following companies have helped finance the development of the KumoMTA server, such as by paying for feature development or contributing other resources:</p> <ul> <li>TaguchiMarketing Pty Ltd<ul> <li>Our first sponsor, in support of the initial KumoMTA beta release.</li> </ul> </li> </ul>"},{"location":"userguide/general/get_help/","title":"How to Get Help With KumoMTA","text":"<p>Community support for KumoMTA is available both in the forum and in the community Discord server. Paid support customers should consult their support SLA document for information on how to contact KumoMTA support and their relevant guaranteed response and resolution times.</p> <p>More information about KumoMTA's paid support services can be found at https://kumomta.com/support.</p>"},{"location":"userguide/general/get_help/#how-to-ask-for-help","title":"How To Ask For Help","text":"<p>To get the fastest resolution, start by reading the Troubleshooting Section and following the steps listed there.</p> <p>If the troubleshooting steps do not help you resolve your issue, please make sure to provide the following when asking for help:</p> <ol> <li> <p>The version number of your KumoMTA instance, found using <code>/opt/kumomta/sbin/kumod --version</code></p> </li> <li> <p>The Distro and version of the host Operating System, found using <code>uname -a</code></p> </li> <li> <p>The full text of the init.lua policy script running on the KumoMTA instance.</p> </li> <li> <p>The full text of any and all error messages associated with the issue, with details as to which system generated the error in question (error from injector, error from KumoMTA, error from remote host, etc.)</p> </li> <li> <p>An example of the Swaks call that reproduces the issue. See the Swaks documentation for instructions on how to use Swaks. This allows us to reproduce the issue and removes external factors from the issue at hand.</p> </li> <li> <p>A trace of the communications in question gathered using the <code>kcli trace-smtp-server</code> command.</p> </li> <li> <p>Relevant log lines from the KumoMTA logs.</p> </li> </ol>"},{"location":"userguide/general/get_help/#discord","title":"Discord","text":"<p>The KumoMTA Discord server is intended for real-time communication about KumoMTA and MailOps/Deliverability in general. The Discord server can be found at https://kumomta.com/discord. Please use the #get-help channel to post your questions and be sure to include information on what version of KumoMTA you are using, your configuration, and full error messages.</p>"},{"location":"userguide/general/get_help/#forum","title":"Forum","text":"<p>The KumoMTA forum is best suited to longer-form help requests that benefit from higher visibility in the community (as the help request won't get lost in the chat scroll or otherwise missed), and which would be of benefit to other users thanks to the more permanent nature of forum interactions. The forum can be accessed at https://forum.kumomta.com.</p>"},{"location":"userguide/general/history/","title":"The History of KumoMTA","text":"<p>KumoMTA is an open source Message Transfer Agent (MTA) designed to provide high performance outbound email functionality.</p> <p>The KumoMTA project was founded by a group of email industry veterans with decades of experience building and managing high-performance On-Prem MTAs and is supported by a community of some of the largest senders in the world. While paying attention to the lessons of history, KumoMTA was designed from the ground up with new tech as opposed to modifying something that already existed.  We specifically avoided making a modification of Postfix or Exim or some other existing MTA and instead wrote entirely new code in Rust.</p>"},{"location":"userguide/general/history/#what-is-a-kumo","title":"What is a \"Kumo\"?","text":"<p>So how did we come up with the name KumoMTA?  We set out to build a cloud deployable on-premises MTA that was flexible enough to install both on bare metal and in a public or private cloud.  Kumo means cloud in Japanese, so \"KumoMTA\" is a Cloud MTA.</p>"},{"location":"userguide/general/history/#why-open-source","title":"Why Open Source?","text":"<p>High volume commercial MTAs tend to have closed source code and steep license fees. Neither of these are particularly bad as long as the software is maintained and is flexible enough to modify.  However, the kind of people who typically install very complex high-volume MTAs usually want to modify it or integrate it into other systems.  Providing an open source option allows people to modify the code as needed, and contribute modifications easily to the community.  The email community is full of very smart, creative people who now have an avenue to contribute to a wider community project.</p>"},{"location":"userguide/general/lua/","title":"Lua Fundamentals","text":"<p>Lua is Portuguese for moon.  It is also the name of the scripting language we use in KumoMTA. Because it is a name, Lua is always capitalized.</p> <p>Understanding Lua is not required to deploy and use KumoMTA, but it will help you leverage the full power of this incredibly flexible system. Lua is easy to learn, easy to read, and easy to implement.</p> <p>You can find many resources at the [official Lua site including online documentation and physical reference books.</p> <p>Here is a simplified primer to help you read the KumoMTA script/configs:</p> <pre><code>-- A single line comment in Lua is 2 dashes (--)\n--[[ A multi line comment in Lua\n     is framed in 2 dashes and 2 square brackets\n   ]]\n--\n</code></pre> <pre><code>local myvar\nlocal myvar = 32\n</code></pre> <p>Global variables are implied by excluding the word \"local\".</p> <pre><code>myvar = 32 -- this is a GLOBAL variable\n</code></pre> <p>Danger</p> <p>In KumoMTA, variables should always be declared as \"local\" unless you intend for the value to be constant for the life of the program.</p> <p>The concurrency model used by KumoMTA means that global variables can be shared in unpredictable ways. If you need to share values that change across the life of the program, you should use a data store such as sqlite or redis.</p> <p>Lua supports the following relational operators:</p> Symbol Meaning == equality ~= inequality &lt; less than &gt; greater than &lt;= less than or equal to &gt;= greater than or equal to <p>You can concatenate strings with two dots surrounded by spaces.</p> <pre><code>print('This' .. ' is ' .. 'true.')\n</code></pre> <p>Functions, conditionals, and loops always end with \"end\"</p> <pre><code>if x == 2 then\ny = 6\nend\nfunction dostuff(things)\nprint(things)\nend\n</code></pre>"},{"location":"userguide/general/preface/","title":"Preface and Legal Notices","text":"<p>This is the Documentation for the KumoMTA Message Transfer Agent.</p>"},{"location":"userguide/general/preface/#legal-notices","title":"Legal Notices","text":"<p>KumoMTA and this documentation are Copyright 2023 Kumo Corp. Both are licensed under the Apache License, Version 2.0 (the \"License\");</p> <p>Full Copyright and License information can be found in the KumoMTA repository.</p> <p>Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License.</p>"},{"location":"userguide/general/report/","title":"How to Report Bugs","text":"<p>This section described the process for submitting a bug report and how to get assistance.</p>"},{"location":"userguide/general/report/#before-submitting-a-bug-report","title":"Before Submitting a Bug Report","text":"<p>Before submitting a bug report, please try and verify that what you're encountering is truly a bug and has not been previously reported:</p> <ul> <li>Check the online manual at https://docs.kumomta.com. The manual is updated frequently and contains the latest information on the proper use of KumoMTA. The Changelog helps identify any issues that may be solved by updating to a more recent release of KumoMTA.</li> <li>Check the issues list at https://github.com/KumoCorp/kumomta/issues to see if the bug you've identified has already been reported.</li> </ul> <p>Note</p> <p>The Issue tracker is not a support channel. Any issues submitted that are questions and not bug reports will be summarily closed. See below for information on getting help.</p>"},{"location":"userguide/general/report/#submitting-a-bug-report","title":"Submitting a Bug Report","text":"<p>If you think you have found a previously unreported bug, visit https://github.com/KumoCorp/kumomta/issues/new/choose and follow the instructions on the page.</p> <p>If you submit an issue, please keep the following in mind:</p> <ul> <li>Be sure to include all of the information requested by the form.</li> <li>Remember that the fastest path to resolution is to prevent any   back-and-forth with the developers to gather further information. We can always   act on an issue report with too much detail, but not one with too little.</li> <li>If possible, download and install the latest release of KumoMTA and check   whether it solves your problem. All official KumoMTA releases are thoroughly   tested and should work without issue. We strive to maintain backward   compatibility, allowing you to switch versions of KumoMTA without issue.</li> </ul>"},{"location":"userguide/installation/deployment/","title":"Deployment Architecture","text":""},{"location":"userguide/installation/docker/","title":"Installing KumoMTA in a Docker container","text":"<p>Our CI builds the latest version of our image and publishes it to the GitHub Container registry.</p> <p>You'll need a policy script in order to start kumo.</p> <p>Create a file named <code>init.lua</code> with these contents:</p> <pre><code>local kumo = require 'kumo'\n-- This config acts as a sink that will discard all received mail\nkumo.on('init', function()\n-- Listen on port 25\nkumo.start_esmtp_listener {\nlisten = '0:25',\n-- allow all clients to send mail\nrelay_hosts = { '0.0.0.0/0' },\n}\n-- Define the default \"data\" spool location.\n-- This is unused by this config, but we are required to\n-- define a default spool location.\nkumo.define_spool {\nname = 'data',\npath = '/tmp/kumo-sink/data',\n}\n-- Define the default \"meta\" spool location.\n-- This is unused by this config, but we are required to\n-- define a default spool location.\nkumo.define_spool {\nname = 'meta',\npath = '/tmp/kumo-sink/meta',\n}\nend)\nkumo.on('smtp_server_message_received', function(msg)\n-- Accept and discard all messages\nmsg:set_meta('queue', 'null')\nend)\n</code></pre> <p>When we launch the image, we want to mount our <code>init.lua</code> file into the image and tell it to use it.  The default location for this is <code>/opt/kumomta/etc/policy</code>:</p> <pre><code>$ sudo docker run --rm -p 2025:25 \\\n-v .:/opt/kumomta/etc/policy \\\n--name kumo-sink \\\nghcr.io/kumocorp/kumomta-dev:latest\n</code></pre>"},{"location":"userguide/installation/docker/#building-your-own-kumomta-container-image","title":"Building your own KumoMTA container image","text":"<p>You need <code>git</code> to clone the repo:</p> RPM based systemsAPT based systems <pre><code>$ sudo dnf install -y git\n</code></pre> <pre><code>$ sudo apt install -y git\n</code></pre> <p>Then clone the repo and run the image builder script:</p> <pre><code>$ git clone https://github.com/KumoCorp/kumomta.git\n$ cd kumomta\n$ sudo ./docker/kumod/build-docker-image.sh\n</code></pre> <p>This should result in something roughly like this:</p> <pre><code>$ docker image ls kumomta/kumod\nREPOSITORY      TAG       IMAGE ID       CREATED         SIZE\nkumomta/kumod   latest    bbced15ff4d1   3 minutes ago   116MB\n</code></pre> <p>You can then run that image in the same way as shown in the previous section.</p>"},{"location":"userguide/installation/environment/","title":"Server Environment","text":"<p>KumoMTA can be installed in a physical server, public cloud, or private cloud.  The following environments have all been tested.</p> <ul> <li>AWS</li> <li>Azure</li> <li>GCP</li> <li>VMWare</li> <li>bare metal</li> </ul> <p>Note that most public cloud platforms block port 25 outbound so you will need to ask for specific permission to use that outbound port.</p> <p>In any case, the server or instance should be a dedicated resource with as much CPU, RAM, Network bandwidth, and storage IOPS as possible.</p>"},{"location":"userguide/installation/hardware/","title":"Hardware Considerations","text":""},{"location":"userguide/installation/hardware/#selecting-a-server-or-instance","title":"Selecting a server or Instance","text":"<p>KumoMTA is a performance MTA that will leverage every bit of power you provide. It may be kind of obvious, but 'more is better' so if you plan to send many millions of messages per hour, deploy the largest server you can. You can deploy in bare metal, public or private cloud, with or without Kubernetes.</p>"},{"location":"userguide/installation/hardware/#ram-and-storage","title":"RAM and Storage","text":"<p>At an absolute minimum, you will need 4Gb RAM and 20Gb Storage.  KumoMTA makes heavy use of both resources and response time is going to be a factor.  For high performance systems you will want to select storage with the fastest IOPS and lowest latency, so local disk is going to be much better than NAS or SAN. Likewise, you can benefit from faster RAM if it is available. In AWS, a t2.medium is adequate for a minimal install.  If you are installing a Docker Image, the same guide applies. See the chart below for sample performance reports.</p>"},{"location":"userguide/installation/hardware/#network-interfaces","title":"Network Interfaces","text":"<p>KumoMTA is capable of processing many millions of message per hour, or more relevant to this conversation, many thousands of bytes per second.  Your network interface could be your biggest bottleneck.  Below is a quick calculation:</p> <p>Assuming the average message is 50kB and you plan to send 1 Million of those per hour, your bandwidth requirement will be:</p> <pre><code>50 * 8000 * 1,000,000 / 3600s =~ 111Mbps\n</code></pre> <p>You can see that a 10Mbps Network interface would fail you quickly.  Any performance system should use at least a 10Gb NIC.</p>"},{"location":"userguide/installation/hardware/#ports-and-security","title":"Ports and Security","text":"<p>Note that in order for KumoMTA to bind to port 25 for inbound mail, it must be run as a privileged user.</p> <p>Note also that if you are deploying to any public cloud, outbound port 25 is probably blocked by default. If this node specificially needs to send mail directly on port 25 to the public internet, you should request access to the port from the cloud provider.  Some hints are below.</p> Provider Resource AWS EC2 port 25 throttle Azure Troubleshoot Outbound SMTP Connectivity GCP Sending Mail <p>~</p>"},{"location":"userguide/installation/linux/","title":"Installing on Linux","text":"<p>Pre-built releases are available for CentOS 7, Rocky Linux 8/9, and Ubuntu 20.04/22.04.</p> <p>A repository is provided to ease installation on supported platforms.</p> <p>The install instructions for supported platforms are shown below. If your platform is not listed, you can build from source.</p> CentOS7RockyUbuntu 22.04 LTSUbuntu 20.04 LTSAmazon Linux 2Amazon Linux 2023 <p>Note</p> <p>Note that Red Hat full support for RHEL 7 ended in August 2019 and CentOS 7 full support ended in August 2020. We ended automated builds for RHEL 7 with the 2023.08.22-4d895015 release.</p> <p>We recommend upgrading to a newer OS as soon as possible.</p> <pre><code>$ sudo yum install -y yum-utils\n$ sudo yum-config-manager --add-repo=\\\nhttps://openrepo.kumomta.com/files/kumomta-centos.repo\n$ sudo yum install kumomta\n</code></pre> <pre><code>$ sudo dnf -y install dnf-plugins-core\n$ sudo dnf config-manager --add-repo \\\nhttps://openrepo.kumomta.com/files/kumomta-rocky.repo\n$ sudo yum install kumomta\n</code></pre> <pre><code>$ sudo apt install -y curl gnupg ca-certificates\n$ curl -fsSL https://openrepo.kumomta.com/kumomta-ubuntu-22/public.gpg | sudo gpg --yes --dearmor -o /usr/share/keyrings/kumomta.gpg\n$ curl -fsSL https://openrepo.kumomta.com/files/kumomta-ubuntu22.list | sudo tee /etc/apt/sources.list.d/kumomta.list &gt; /dev/null\n$ sudo apt update\n$ sudo apt install -y kumomta\n</code></pre> <pre><code>$ sudo apt install -y curl gnupg ca-certificates\n$ curl -fsSL https://openrepo.kumomta.com/kumomta-ubuntu-20/public.gpg | sudo gpg --yes --dearmor -o /usr/share/keyrings/kumomta.gpg\n$ curl -fsSL https://openrepo.kumomta.com/files/kumomta-ubuntu20.list | sudo tee /etc/apt/sources.list.d/kumomta.list &gt; /dev/null\n$ sudo apt update\n$ sudo apt install -y kumomta\n</code></pre> <pre><code>$ sudo yum install -y yum-utils\n$ sudo yum-config-manager --add-repo=\\\nhttps://openrepo.kumomta.com/files/kumomta-amazon.repo\n$ sudo yum install kumomta\n</code></pre> <pre><code>$ sudo dnf -y install dnf-plugins-core\n$ sudo dnf config-manager --add-repo \\\nhttps://openrepo.kumomta.com/files/kumomta-amazon2023.repo\n$ sudo yum install kumomta\n</code></pre>"},{"location":"userguide/installation/linux/#installing-from-a-dev-repository","title":"Installing from a Dev Repository","text":"<p>If you want to test the latest additions and improvements to KumoMTA, you can instead install from the dev repository on your platform of choice. The dev repository is rebuilt after each commit to the KumoMTA repository, which means the dev repository will always include the latest changes.</p> <p>Warning</p> <p>While we do our best to test all commits, dev repositories should never be installed in production environments.</p> CentOS7RockyUbuntu 22.04 LTSUbuntu 20.04 LTSAmazon Linux 2Amazon Linux 2023 <p>Note</p> <p>Note that Red Hat full support for RHEL 7 ended in August 2019 and CentOS 7 full support ended in August 2020.</p> <p>We recommend upgrading to a newer OS as soon as possible.</p> <pre><code>$ sudo yum install -y yum-utils\n$ sudo yum-config-manager --add-repo=\\\nhttps://openrepo.kumomta.com/files/kumomta-centos.repo\n$ sudo yum install kumomta-dev\n</code></pre> <pre><code>$ sudo dnf -y install dnf-plugins-core\n$ sudo dnf config-manager --add-repo \\\nhttps://openrepo.kumomta.com/files/kumomta-rocky.repo\n$ sudo yum install kumomta-dev\n</code></pre> <pre><code>$ sudo apt install -y curl gnupg ca-certificates\n$ curl -fsSL https://openrepo.kumomta.com/kumomta-ubuntu-22/public.gpg | sudo gpg --yes --dearmor -o /usr/share/keyrings/kumomta.gpg\n$ curl -fsSL https://openrepo.kumomta.com/files/kumomta-ubuntu22.list | sudo tee /etc/apt/sources.list.d/kumomta.list &gt; /dev/null\n$ sudo apt update\n$ sudo apt install -y kumomta-dev\n</code></pre> <pre><code>$ sudo apt install -y curl gnupg ca-certificates\n$ curl -fsSL https://openrepo.kumomta.com/kumomta-ubuntu-20/public.gpg | sudo gpg --yes --dearmor -o /usr/share/keyrings/kumomta.gpg\n$ curl -fsSL https://openrepo.kumomta.com/files/kumomta-ubuntu20.list | sudo tee /etc/apt/sources.list.d/kumomta.list &gt; /dev/null\n$ sudo apt update\n$ sudo apt install -y kumomta-dev\n</code></pre> <pre><code>$ sudo yum install -y yum-utils\n$ sudo yum-config-manager --add-repo=\\\nhttps://openrepo.kumomta.com/files/kumomta-amazon.repo\n$ sudo yum install kumomta-dev\n</code></pre> <pre><code>$ sudo dnf -y install dnf-plugins-core\n$ sudo dnf config-manager --add-repo \\\nhttps://openrepo.kumomta.com/files/kumomta-amazon2023.repo\n$ sudo yum install kumomta-dev\n</code></pre>"},{"location":"userguide/installation/linux/#the-initial-config-file","title":"The Initial Config File","text":"<p>KumoMTA is now installed, but it requires a configuration policy so it knows how to behave. The installer creates a minimal configuration policy file at <code>/opt/kumomta/etc/policy/init.lua</code> that enables basic localhost relaying and logging.</p> <p>See the configuration chapter for more information on creating your own configuration policy.</p>"},{"location":"userguide/installation/linux/#starting-kumomta","title":"Starting KumoMTA","text":"<p>To start KumoMTA using systemd, execute the following command:</p> <pre><code>$ sudo systemctl start kumomta\n</code></pre> <p>For additional details on starting KumoMTA, including as a persistent service, see the Starting KumoMTA chapter.</p>"},{"location":"userguide/installation/operatingsystem/","title":"Operating System Selection and Configuration","text":"<p>KumoMTA was built from the ground up to be extremely flexible infrastructure. We have built standard package builds (AKA repo install) for the most commonly used Linux Operating Systems, but if you build from source, a wide variety of Operating Systems are possible.</p> <p>So far we've run non-production tests on the following systems:</p> <ul> <li>Rocky (8, 9)</li> <li>Alma (8, 9)</li> <li>Debian (11)</li> <li>Ubuntu (18, 20, 22, 20.04ARM (aarch64) )</li> <li>OpenSuse Leap (15.4)</li> <li>Azure Linux (CBL-Mariner2)</li> <li>Amazon Linux 2</li> <li>Kali (2003.1)</li> <li>CentOS 7</li> <li>RHEL 7,8,9</li> <li>Mariner2</li> </ul> <p>and the following machine types:</p> <ul> <li>AWS</li> <li>Azure</li> <li>GCP</li> <li>VMWare</li> <li>Bare Metal</li> </ul>"},{"location":"userguide/installation/overview/","title":"Installation Overview","text":"<p>This chapter starts with information regarding how to architect your deployment, what environment and hardware to select, as well as descriptions of supported operating systems. We recommend reading this chapter in order before jumping to the chapter for your install environment of choice.</p> <p>KumoMTA can be installed from a repository, as a Docker container, or can be built from source.</p> <p>For instructions on installing from a repository, see the Installing on Linux page.</p> <p>For instructions on installing the Docker container, see the Installing on Docker page.</p> <p>For instructions on building from source, see the Building from Source page.</p> <p>Once installed, Configure and Start your server.</p>"},{"location":"userguide/installation/setting-up-docker/","title":"Setting up docker","text":""},{"location":"userguide/installation/setting-up-docker/#configure-docker","title":"Configure Docker","text":"<p>Ensure docker is actually installed in your server instance.</p> DNF based systemsAPT based systems <p>In Rocky, Alma, and any other DNF package manager system</p> <pre><code>$ sudo dnf config-manager --add-repo=https://download.docker.com/linux/centos/docker-ce.repo\n$ sudo dnf update -y\n$ sudo dnf install -y docker-ce docker-ce-cli containerd.io\n$ sudo systemctl enable docker\n</code></pre> <p>In Ubuntu, Debian, and other Debial APT package management systems:</p> <pre><code>$ sudo apt update\n$ sudo apt install -y apt-utils docker.io\n$ sudo snap install docker\n</code></pre> <p>If you get an error that <code>/etc/rc.d/rc.local is not marked executable</code> then make it executable with <code>sudo chmod +x /etc/rc.d/rc.local</code></p>"},{"location":"userguide/installation/setting-up-docker/#start-docker","title":"Start Docker","text":"<pre><code>$ sudo systemctl start docker\n</code></pre>"},{"location":"userguide/installation/setting-up-docker/#check-if-docker-is-running","title":"Check if Docker is running","text":"<pre><code>$ systemctl status docker\n</code></pre>"},{"location":"userguide/installation/setting-up-docker/#enable-non-root-user-access","title":"Enable Non-Root User Access","text":"<p>After completing Step 3, you can use Docker by prepending each command with sudo. To eliminate the need for administrative access authorization, set up a non-root user access by following the steps below.</p> <ol> <li> <p>Use the usermod command to add the user to the docker system group.   <pre><code>$ sudo usermod -aG docker $USER\n</code></pre></p> </li> <li> <p>Confirm the user is a member of the docker group by typing:   <pre><code>$ id $USER\n</code></pre></p> </li> </ol> <p>It is a good idea to restart to make sure it is all set correctly.</p>"},{"location":"userguide/installation/source/","title":"Building From Source","text":"<p>If pre-built binaries are not provided for your system of choice, of if you'd like try your hand at extending KumoMTA, you'll need to build it from source.</p> <p>If you are on Ubuntu or Rocky Linux and just want to try KumoMTA, rather than build from source we recommend that you follow the instructions in the Installing on Linux section.</p>"},{"location":"userguide/installation/source/#prepare-your-environment","title":"Prepare your environment","text":"<p>Read the Environmental considerations before proceeding.  You will need a suitably sized server with all of the prerequisites in order to be successful.</p> <p>In addition, you will need to install some development packages.</p>"},{"location":"userguide/installation/source/#obtain-the-code","title":"Obtain The Code","text":"<p>You will need <code>git</code>:</p> RPM based systemsAPT based systems <pre><code>$ sudo dnf install -y git\n</code></pre> <pre><code>$ sudo apt install -y git curl\n</code></pre> <p>Then clone the repo:</p> <pre><code>$ git clone https://github.com/KumoCorp/kumomta.git\n$ cd kumomta\n</code></pre>"},{"location":"userguide/installation/source/#install-dependencies","title":"Install Dependencies","text":"<p>The <code>get-deps.sh</code> script in the repo knows how to install dependencies for various systems; you should run it the first time you clone the repo, and may need to run it after running a pull to update the repo in the future:</p> <pre><code>$ ./get-deps.sh\n</code></pre> <p>Note</p> <p><code>get-deps.sh</code> will install the various deps, but will complain that rust is not installed the first time that you run it. You can ignore that error as the very next step is to install rust.</p>"},{"location":"userguide/installation/source/#install-rust","title":"Install Rust","text":"<p>You will need the Rust compiler to build KumoMTA.</p> <p>We strongly recommend using rustup to install and manage your Rust compiler. While some distributions offer a version of the Rust compiler, it is often outdated.</p> <p>If you are using a priviledged user, drop back to your non-priviledged user first:</p> <pre><code>$ curl --proto '=https' --tlsv1.2 -sSf https://sh.rustup.rs | sh -s -- -y\n$ source ~/.cargo/env\n</code></pre>"},{"location":"userguide/installation/source/#building-kumomta","title":"Building KumoMTA","text":"<p>With all the dependencies available, the actual build process is very simple:</p> <pre><code>$ cargo build --release\n</code></pre> <p>This will build everything, leaving the binaries in the <code>target/release</code> directory in the repo.</p>"},{"location":"userguide/installation/source/#building-your-own-package","title":"Building your own package","text":"<p>There are scripts to build out packages in either RPM or DEB format. If you're running on such a system, we recommend building and installing from a package built by our scripts, as those packages will best encapsulate how we intend for KumoMTA to be installed and operated.</p> <p>These scripts will produce a package file that you are then free to install either locally or on a target system elsewhere.</p> RPM based systemsAPT based systems <pre><code>$ assets/build-rpm.sh\n</code></pre> <p>You can find the generated rpm in a directory maintained by rpmbuild; that is usually <code>~/rpmbuild/RPMS/x86_64</code>, but some environments use a different location, so the example below uses <code>rpm --eval</code> to obtain the correct location:</p> <pre><code>$ rpm --eval '%{_rpmdir}/%{_arch}'\n/home/USER/rpmbuild/RPMS/x86_64\n$ ls $(rpm --eval '%{_rpmdir}/%{_arch}')/kumo*.rpm\n/home/USER/rpmbuild/RPMS/x86_64/kumomta-dev-2023.10.24.112314_f8aaa6f1-1.fedora38.x86_64.rpm\n</code></pre> <p>You can install it directly if you wish:</p> <pre><code>$ sudo rpm -Uvh $(ls $(rpm --eval '%{_rpmdir}/%{_arch}')/kumo*.rpm | tail -1)\n</code></pre> <pre><code>$ assets/build-deb.sh\n$ ls *.deb\nkumomta-dev.2023.10.24.112314.f8aaa6f1.Ubuntu22.04.deb\n</code></pre> <p>You can install it directly if you wish:</p> <pre><code>$ sudo apt-get install -y ./kumomta*.deb\n</code></pre>"},{"location":"userguide/installation/source/#installing-from-source","title":"Installing from source","text":"<p>If RPM or DEB is not suitable for your environment for some reason, you can install the various components \"by hand\".  We recommend installing to <code>/opt/kumomta</code> so that various product defaults continue to operate as intended.</p>"},{"location":"userguide/installation/source/#pre-req-service-account","title":"Pre-req: service account","text":"<p>The default service account assumed by the <code>kumod</code> process is the <code>kumod</code> user.</p> <p>You can create the account manually like this:</p> <pre><code>$ sudo useradd --system -g kumod -d /var/spool/kumod -s /sbin/nologin \\\n-c \"Service account for kumomta\" kumod\n</code></pre>"},{"location":"userguide/installation/source/#directory-structure","title":"Directory Structure","text":"<p>Take care with the ownership and permissions on the various directories, in order to avoid deploying with an insecure configuration:</p> <pre><code>$ sudo install -d --mode 755 --owner kumod --group kumod /opt/kumomta/sbin\n$ sudo install -d --mode 755 --owner kumod --group kumod /opt/kumomta/etc\n$ sudo install -d --mode 755 --owner kumod --group kumod /opt/kumomta/etc/policy\n$ sudo install -d --mode 2770 --owner kumod --group kumod /opt/kumomta/etc/dkim\n$ sudo install -d --mode 2770 --owner kumod --group kumod /var/spool/kumomta\n$ sudo install -d --mode 2770 --owner kumod --group kumod /var/log/kumomta\n</code></pre> <p>The executables:</p> <pre><code>$ for bin in validate-shaping tsa-daemon \\\nproxy-server kumod kcli traffic-gen tailer ; do\n  install -Dsm755 target/release/$bin -t /opt/kumomta/sbin\ndone\n</code></pre> <p>The helpers and other assets:</p> <pre><code>$ sudo mkdir -p /opt/kumomta/share/bounce_classifier /opt/kumomta/share/policy-extras\n$ sudo install -Dm644 assets/bounce_classifier/* -t /opt/kumomta/share/bounce_classifier\n$ sudo install -Dm644 assets/policy-extras/*.lua -t /opt/kumomta/share/policy-extras\n$ sudo install -Dm644 assets/policy-extras/*.toml -t /opt/kumomta/share/policy-extras\n</code></pre> <p>The example/starter configuration files can be installed like this; you may wish to skip this set and just deploy your own configuration, as discussed in the section below:</p> <pre><code>$ sudo install -Dm644 assets/init.lua -T /opt/kumomta/etc/policy/init.lua\n$ sudo install -Dm644 assets/tsa_init.lua -T /opt/kumomta/etc/policy/tsa_init.lua\n</code></pre>"},{"location":"userguide/installation/source/#systemd-service","title":"Systemd Service","text":"<p>If you wish to use systemd to manage <code>kumod</code> and/or <code>tsa-daemon</code>, you can find the <code>.service</code> files in the <code>assets</code> directory.  Precisely where these files are deployed varies a little depending on your distribution, so copyable instructions for that are not currently provided here.</p>"},{"location":"userguide/installation/source/#creating-the-initial-config","title":"Creating the initial config","text":"<p>KumoMTA is now installed, but it requires a policy configuration script so it knows how to behave.  The policy config is written in Lua and should live in <code>/opt/kumomta/etc/policy/init.lua</code> in order to work with the systemd service definition.</p> <p>Both the from-package and from-source instructions above will pre-populate that file with the basic configuration that is reproduced below. Alternately, there is a more substantial config sample HERE, but you must save it as <code>/opt/kumomta/etc/policy/init.lua</code>.</p> /opt/kumomta/etc/policy/init.lua<pre><code>--[[\n########################################################\n  KumoMTA minimal Send Policy\n  (Save this as /opt/kumomta/etc/policy/init.lua for systemd automation)\n  This config policy defines KumoMTA with a minimal\n  set of modifications from default.\n  Please read the docs at https://docs.kumomta.com/\n  For detailed configuration instructions.\n########################################################\n]]\n--\nlocal kumo = require 'kumo'\n--[[ Start of INIT section ]]\n--\nkumo.on('init', function()\nkumo.start_esmtp_listener {\nlisten = '0.0.0.0:25',\n}\nkumo.start_http_listener {\nlisten = '127.0.0.1:8000',\n}\nkumo.define_spool {\nname = 'data',\npath = '/var/spool/kumomta/data',\n}\nkumo.define_spool {\nname = 'meta',\npath = '/var/spool/kumomta/meta',\n}\nkumo.configure_local_logs {\nlog_dir = '/var/log/kumomta',\n-- Flush logs every 10 seconds.\n-- You may wish to set a larger value in your production\n-- configuration; this lower value makes it quicker to see\n-- logs while you are first getting set up.\nmax_segment_duration = '10s',\n}\nend)\n--[[ End of INIT Section ]]\n--[[ Start of Non-INIT level config ]]\n--\n-- PLEASE read https://docs.kumomta.com/ for extensive documentation on customizing this config.\n--[[ End of Non-INIT level config ]]\n</code></pre>"},{"location":"userguide/installation/source/#running-kumod","title":"Running kumod","text":"<p>If you are not using systemd to manage the service, then you will need to use some other way to launch kumod.  This section shows how you might launch it manually, so that you understand how to automatate/manage this for yourself in your chosen environment:</p> <pre><code>$ sudo /opt/kumomta/sbin/kumod \\\n--policy /opt/kumomta/etc/policy/init.lua \\\n--user kumod\n</code></pre> <p>Using <code>sudo</code> (or otherwise spawning as root) to launch the process allows binding to privileged ports, such as port 25, so that you can accept incoming mail on the standard port.</p> <p>When launched with root privileges, <code>kumod</code> requires a service account to switch to after it has bound privileged ports, in order to avoid running in a dangerously insecure mode: you do not want public internet traffic connecting directly to a privileged process!</p> <p>The <code>--policy</code> argument specifies the path to your <code>init.lua</code> configuration.</p> <p>The <code>--user</code> argument specifies the name of the service account to use instead of running as root.</p>"},{"location":"userguide/installation/source/#running-from-your-source-directory","title":"Running from your source directory","text":"<p>Note</p> <p>This section is intended for people that are developing kumomta itself, rather than people that just want to install and use kumomta</p> <p>This command will bring <code>kumod</code> up to date (in case you made changes), and then try to launch it:</p> <pre><code>$ cargo run --release -p kumod -- --policy /opt/kumomta/etc/policy/init.lua\n</code></pre> <p>You can run as root using port 25, in the foreground, with this:</p> <pre><code>$ cargo build --release -p kumod &amp;&amp; \\\nsudo target/release/kumod \\\n--policy /opt/kumomta/etc/policy/init.lua \\\n--user kumod\n</code></pre>"},{"location":"userguide/installation/source/#keeping-the-source-up-to-date","title":"Keeping the source up to date","text":"<p>To synchronize your repo with the latest changes in the <code>main</code> branch:</p> <p><pre><code>$ cd kumomta\n$ git pull --rebase\n$ ./get-deps.sh\n$ cargo build --release\n</code></pre> Note that this builds the new files in <code>target/release/</code>.  If you installed binaries to /opt/kumomta/sbin then you will want to follow the instructions above to build your own package and update the files in <code>/opt/kumomta/</code>.</p>"},{"location":"userguide/installation/system_prep/","title":"System Preparation","text":"<p>Regardless of what OS and hardware you select, there are some basic things you should do to prepare your system before installing KumoMTA. While veteran system admins will probably have done much of this already as a standard course of building a server, it is worth noting these to save you some stress later.</p> <ul> <li> <p>In the cloud service network settings or local security appliance, create a security group that includes the ports you require access to.</p> <p>Port 22: SSH will be required to access the host operating system</p> <p>Port 25: SMTP is required for both outbound mail and inbound mail, including injections and bounce messages.</p> <p>Port 80: HTTP is used for the HTTP API, but should be restricted to authorized hosts.</p> <p>Port 443: HTTPS is the secure (TLS) version of Port 80 so the same access rules apply.</p> <p>Port 587: SMTP for Submission is not required, but recommended for inbound messages.</p> <p>Port 2025: Alternate for SMTP Submission, useful in environments that restrict port 25.</p> </li> <li> <p>Update to the latest patches</p> </li> </ul> <p>It is always good to start with a clean and current system.</p> <p>In dnf managed systems (Rocky, Alma, Fedora, etc) use</p> <pre><code>sudo dnf clean all\nsudo dnf update -y\n</code></pre> <p>In apt managed systems (Debain, Ubuntu, etc) use</p> <pre><code>sudo apt-get -y update\nsudo apt-get -y upgrade\n</code></pre> <ul> <li>Install basic testing and support tools like firewalld tree telnet git bind (or bind9) bind-utils (or bind9-utils)</li> </ul> <p>Note that installing a caching name server is absolutely critical when you are using a high performance mail engine.  Please do yourself a favour and install bind (or some other caching name server) and test it now. <pre><code>sudo apt install bind9 -y\nsudo systemctl start named\n</code></pre></p> <ul> <li>Turn off services that can interfere, particularly postfix and qpidd</li> </ul> <pre><code>sudo systemctl disable postfix\nsudo systemctl stop postfix\nsudo systemctl disable qpidd\nsudo systemctl stop qpidd\n</code></pre> <ul> <li> <p>Tune the use of memory and file access for best performance. In the sysctl settings, boosting fs.file-max up to 65535 and also setting tcp_tw_reuse = 1 will help performance.  Make other adjustments as needed to make maximum use of RAM, file, and network resources.</p> </li> <li> <p>Automate updates and startup for resiliency</p> </li> </ul> <pre><code># Make sure it all stays up to date\n# Run a dnf update at 3AM daily\necho \"0 3 * * * root /usr/bin/dnf update -y &gt;/dev/null 2&gt;&amp;1\" | \\\nsudo tee /etc/cron.d/dnf-updates &gt;/dev/null\n</code></pre> <ul> <li>Adding your system certificate, or at least generating a self-signed certificate can be helpful before you start.  If you don't, one will be generated based on the available system parameters and the settings may not be what you want.</li> </ul> <p>Now that you have a nicely prepared system, you can move on to installing the MTA.</p>"},{"location":"userguide/installation/upgrading/","title":"Upgrading KumoMTA","text":"<p>If you have installed from a repository, you can upgrade with the same process used for any package upgrade.</p> <p>In dnf managed systems:</p> <pre><code>$ sudo dnf update kumomta[-dev]\n</code></pre> <p>In apt managed systems:</p> <pre><code>$ sudo apt update\n$ sudo apt upgrade kumomta[-dev]\n</code></pre>"},{"location":"userguide/integrations/","title":"Integrations","text":"<p>This chapter is focused on partner and adjacent systems integrations. Some of the third-party integrations could involve a separate external fee, while others are entirely FOSS (Free and Open Source Software). </p> <p>We are available to provide paid professional services to assist you with any of these integrtions.</p>"},{"location":"userguide/integrations/ongage/","title":"Ongage SMTP integration","text":""},{"location":"userguide/integrations/ongage/#introduction","title":"Introduction","text":"<p>Ongage is an email marketing platform that allows you to create and manage content and campaigns then deliver them through your favourite sending engine. This integration describes how to use KumoMTA as the delivery engine for Ongage.</p>"},{"location":"userguide/integrations/ongage/#instructions","title":"Instructions","text":""},{"location":"userguide/integrations/ongage/#get-kumomta","title":"Get KumoMTA","text":"<p>1) Install KumoMTA as per the installation instructions here https://docs.kumomta.com/userguide/installation/overview/ </p> <p>Before finishing this step, you should ensure that you have correctly set up DNS with a resolving sending domain, MX, PTR, SPF, DKIM, etc.   </p> <p>As part of this process, you will be creating a DNS entry for \u201cbounce.\u201d, as well as similar tracking and image domains so be prepared to edit your DNS.  <p>2) Ensure that you can inject mail using SMTP_Auth (Plain) with TLS. Remember to add the access credentials and test it.   https://docs.kumomta.com/userguide/operation/smtpinjection/?h=smtp_auth </p> <p>NOTE: TLS is crucial to this process, so ensure you have a valid and tested certificate attached to your listener config. https://docs.kumomta.com/reference/kumo/start_esmtp_listener/#tls_certificate </p>"},{"location":"userguide/integrations/ongage/#get-ongage","title":"Get Ongage","text":"<p>3) Go to Ongage.com and create an account https://www.ongage.com/registration </p> <p>4) Create a support ticket to request access to use the \u201cPrivate SMTP\u201d connector and let them know you are using KumoMTA as the sending MTA. </p> <p>Here is some essential reading before you set up the Private SMTP connector:  https://ongage.atlassian.net/wiki/spaces/HELP/pages/657817611/The+Ongage+Private+SMTP+Connector </p> <p>5) Once registered, you can add a vendor by selecting Vendors &gt; My Connections in the left menu  </p> <p>6) Create a new connection and add \u201cPrivate SMTP\u201d as the connection type. NOTE: If you do not see this as an option, jump back up to step 4 and ask Ongage Support to add it for you. </p> <p>7) Fill in all the required fields and test. </p> <ul> <li>You can choose any username and password you like, KumoMTA has no preset or preference.  These credentials should match what you set in step 2. </li> <li>Select PLAIN authentication Type </li> <li>Select YES for \u201cUse TLS\u201d </li> <li>The SMTP Port should match what your listener is listening on.  Remember to update your public firewall too.  </li> </ul> <p>If you have done everything right, you will see a positive notification that credentials were verified. </p> <p>8) Pat yourself on the back then start using Ongage with KumoMTA </p>"},{"location":"userguide/integrations/prometheus/","title":"Observability with Prometheus","text":""},{"location":"userguide/integrations/prometheus/#introduction","title":"Introduction","text":"<p>Prometheus is an open-source systems monitoring and alerting toolkit originally built at SoundCloud. Prometheus collects and stores its metrics as time series data, i.e. metrics information is stored with the timestamp at which it was recorded, alongside optional key-value pairs called labels. </p>"},{"location":"userguide/integrations/prometheus/#instructions","title":"Instructions","text":""},{"location":"userguide/integrations/prometheus/#get-kumomta","title":"Get KumoMTA","text":"<p>Install KumoMTA as per the installation instructions here </p> <p>Before finishing this step, you should ensure that you have correctly set up DNS with a resolving sending domain, MX, PTR, SPF, DKIM, etc.   </p> <p>Ensure that you can inject and deliver mail before proceeding. </p>"},{"location":"userguide/integrations/prometheus/#get-prometheus","title":"Get Prometheus","text":"<p>First, Install Node-Exporter to collect typical system metrics to push to Prometheus. If you are configuring a cluster, node-exporter should be installed on each node.   </p> <p>There is also a very handy step-by-step guide here </p> <pre><code>cd  wget https://github.com/prometheus/node_exporter/releases/download/v1.6.0/node_exporter-1.6.0.linux-amd64.tar.gz tar xvfz node_exporter-*.*-amd64.tar.gz cd node_exporter-*.*-amd64 ./node_exporter &amp; </code></pre> <p>This leaves the process running so press RETURN / Hit ENTER.  You will probably want to add that to your start up processes. </p> <p>You can test this with a simple curl : <code>curl http://localhost:9100/metrics</code> </p> <p>Now, Install Prometheus for system reporting. Get an appropriate version from here. Theoretically this can be set up on a remote server to collect metrics from your whole cluster.  In this document we will install version 2.47.2 on localhost. </p> <pre><code>cd wget https://github.com/prometheus/prometheus/releases/download/v2.47.2/prometheus-2.47.2.linux-amd64.tar.gz tar xvf prometheus-*.*-amd64.tar.gz cd prometheus-2.47.2.linux-amd64/ </code></pre> <p>Create or modify a Prometheus yaml file so it includes this node\u2019s feed.  If you are configuring a cluster, add references to all the nodes here too.  This can be saved almost anywhere.  The command below creates the file in <code>./myprometheus.yml</code>. The job name <code>kumomta</code> will collect email metrics using the metrics API. The job name <code>systemstats</code> will collect OS and machine metrics. </p> <pre><code>echo \" \nglobal: \n   scrape_interval: 15s \nscrape_configs:  \n  - job_name: 'kumomta' \n    static_configs: \n      - targets: ['localhost:8000'] \n  - job_name: 'systemstats' \n    static_configs: \n      - targets: ['localhost:9100'] \n\" &gt; ./myprometheus.yml\n</code></pre> <p>Now start it with the yaml file mentioned above: </p> <p><code>./prometheus --config.file=./myprometheus.yml</code> </p> <p>You should now be able to access and manage data sources in the Prometheus webUI on port 9090. Node metrics will use port 9100 internally to feed data to Prometheus. </p> <p>Remember to update your firewall to securely access port 9090 </p> <p>The UI is wide open by default so take measures to lock down access with usual network tools. </p> <p>If you have done this all correctly, you should be able to access the target status with <code>http://&lt;your_domain&gt;:9090/targets</code> in the Prometheus webUI.  The result should look something like this: </p> <p></p>"},{"location":"userguide/operation/cancel/","title":"Cancelling Queued Messages","text":"<p>Occasionally, you will have a bad send or for some reason need to cancel a send quickly. OOPS! It happens.  KumoMTA offers an API specifically for administratively canceling messages with surgical precision. The Admin Bounce API can target a specific Campaign, Queue, or entire Tenant for cancellation.</p> <p>You easiest way to invoke this API is via the <code>kcli</code> utility, but you can also use <code>curl</code> directly.</p> <p>Warning</p> <p>There is no way to undo the actions carried out by this request!</p> <p>You can set a time period that you want the bounce to last for; default is 5 minutes.  This can be handy if you need to catch all new injections for the next hour and you don't want to keep running the command.</p> <p>This will bounce everything and is not reversible - handle with care: </p> kclicurl <pre><code>$ /opt/kumomta/sbin/kcli bounce --everything \\\n--reason 'PURGING ALL THE QUEUES!'\n</code></pre> <pre><code>$ curl -i 'http://localhost:8000/api/admin/bounce/v1' \\\n-H 'Content-Type: application/json' \\\n-d '{\"reason\":\"PURGING ALL THE QUEUES!\"}'\n</code></pre> <p>This will bounce all mail destined to yahoo.com:</p> kclicurl <pre><code>$ /opt/kumomta/sbin/kcli bounce --domain yahoo.com \\\n--reason 'felt like it'\n</code></pre> <pre><code>$ curl -i 'http://localhost:8000/api/admin/bounce/v1' \\\n-H 'Content-Type: application/json' \\\n-d '{\"domain\": \"yahoo.com\", \"reason\":\"felt like it\"}'\n</code></pre> <p>This will bounce all mail to any domain in the campaign \u201cBack to school\u201d </p> kclicurl <pre><code>$ /opt/kumomta/sbin/kcli bounce --campaign 'Back to school' \\\n--reason 'felt like it'\n</code></pre> <pre><code>$ curl -i 'http://localhost:8000/api/admin/bounce/v1' \\\n-H 'Content-Type: application/json' \\\n-d '{\"campaign\": \"Back to school\", \"reason\":\"felt like it\"}'\n</code></pre> <p>NOTE: All fields are case-sensitive. However, domain names are normalized to lowercase when a message is queued, so our internal queue names are always built from the lower cased domain name.</p>"},{"location":"userguide/operation/httpinjection/","title":"Injecting Using HTTP","text":"<p>KumoMTA will listen for message injection in any listener defined in configuration. You have complete control over the IPs and Ports available for message injection.</p> <p>The HTTP Listener will accept any properly formatted HTTP connection request allowed by its configuration.  For instance, based on this:</p> <pre><code>kumo.start_http_listener {\nuse_tls = true,\nlisten = '0.0.0.0:8005',\n-- allowed to access any http endpoint without additional auth\ntrusted_hosts = { '127.0.0.1', '::1' },\n}\n</code></pre> <p>KumoMTA will accept any HTTPS injection on port 8005 from the local host ONLY. (This also enables the full HTTP API from localhost).</p> <p>The simplest test of HTTP injection can be done using cURL right from localhost console.</p> <pre><code>$ curl -i 'http://localhost:8005/api/inject/v1' \\\n-H 'Content-Type: application/json' -d '\n{\"envelope_sender\": \"noreply@example.com\",\n \"content\": \"Subject: hello\\n\\nHello there\",\n \"recipients\": [{\"email\": \"recipient@example.com\"}]\n}'\n</code></pre> <p>That should return something like this:</p> <pre><code>{\"success_count\":1,\"fail_count\":0,\"failed_recipients\":[],\"errors\":[]}\n</code></pre> <p>Any system that can use an HTTP API to pass JSON should work as an injection system if you follow the JSON payload formatting rules posted here</p>"},{"location":"userguide/operation/kcli/","title":"Using the kcli Command-Line Client","text":"<p>KumoMTA comes with several API endpoints to make administration of the server easier for common tasks, and additionally comes with the <code>kcli</code> command-line client which provides access to the APIs for local administrative tasks.</p> <p>The <code>kcli</code> client is located at <code>/opt/kumomta/sbin/kcli</code> and requires a configured HTTP Listener to function.</p> <p>At minimum, the <code>kcli</code> client must be passed an endpoint and a command:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 bounce-list\n</code></pre> <p>The <code>--endpoint</code> parameter indicates the HTTP API endpoint you have configured for your KumoMTA instance.  This documentation uses <code>http://127.0.0.1:8000</code> because that endpoint is shown as a suggested default for that http listener.  You need to adjust it to match whatever you have configured for your HTTP listener in your environment.</p> <p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>The <code>--endpoint</code> defaults to <code>http://127.0.0.1:8000</code> and can be omitted. If <code>KUMO_KCLI_ENDPOINT</code> is set in the environment, its value will be used if <code>--endpoint</code> is not specified.</p> <p>In earlier versions, you need to explicitly pass <code>--endpoint</code>.</p>"},{"location":"userguide/operation/kcli/#bouncing-messages","title":"Bouncing Messages","text":"<p>The <code>kcli</code> client can be used to administratively bounce messages currently queued in the server with the following format:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 bounce --everything --reason purge\n{\n  \"id\": \"0234c7c9-afd3-49f9-9a4c-a1cc37fcc53b\",\n  \"bounced\": {},\n  \"total_bounced\": 0\n}\n</code></pre> <p>Allowed arguments for the bounce command include:</p>"},{"location":"userguide/operation/kcli/#domain","title":"domain","text":"<p>Optional string. The domain name to match. If omitted, any domain will match.</p>"},{"location":"userguide/operation/kcli/#campaign","title":"campaign","text":"<p>Optional string. The campaign name to match. If omitted, any campaign will match.</p>"},{"location":"userguide/operation/kcli/#tenant","title":"tenant","text":"<p>Optional string. The tenant to match. If omitted, any tenant will match.</p> <p>Danger</p> <p>If you specify none of <code>domain</code>, <code>campaign</code> or <code>tenant</code>, then ALL queues will be bounced.</p> <p>With great power, comes great responsibility!</p>"},{"location":"userguide/operation/kcli/#reason","title":"reason","text":"<p>Required. Reason to log in the delivery log.</p>"},{"location":"userguide/operation/kcli/#duration","title":"duration","text":"<p>Optional duration string. Defaults to <code>\"5m\"</code>. Specifies how long this bounce directive remains active.</p> <p>While active, newly injected messages that match the bounce criteria will also be bounced.</p> <p>See the Bounce API page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/kcli/#listing-current-bounces","title":"Listing Current Bounces","text":"<p>You can list the currently active bounce commands with the following command:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 bounce-list\n[\n  {\n    \"id\": \"169c3dc0-6518-41ef-bfbb-1f0ae426cb32\",\n    \"campaign\": null,\n    \"tenant\": null,\n    \"domain\": null,\n    \"reason\": \"purge\",\n    \"duration\": \"4m 50s 207ms 320us 231ns\",\n    \"bounced\": {\n      \"wezfurlong.org\": 1\n    },\n    \"total_bounced\": 1\n  }\n]\n</code></pre> <p>See the Admin Bounce List API page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/kcli/#removing-a-bounce","title":"Removing a Bounce","text":"<p>Because bounce commands default to a five-minute duration, messages will continue to bounce after the command has been issued. This helps with scenarios such as when a campaign needs to be aborted, but the entire campaign may not have been injected at the time the command was issued.</p> <p>Sometimes after a bounce has been issued there is a need to cancel the bounce before the time window has expired. Once a bounce command's ID is determined with the <code>bounce-list</code> command, the bounce can be canceled with the <code>bounce-cancel</code> command:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 bounce-cancel --id 169c3dc0-6518-41ef-bfbb-1f0ae426cb32\nremoved 0234c7c9-afd3-49f9-9a4c-a1cc37fcc53b\n</code></pre> <p>See the Bounce Cancel API page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/kcli/#setting-the-diagnostic-log-level","title":"Setting The Diagnostic Log Level","text":"<p>While the log level is typically set in your configuration, it can also be set on an ad-hoc basis using the set-log-filter command in <code>kcli</code>:</p> <pre><code>$ kcli --endpoint http://127.0.0.1:8000 set-log-filter 'kumod=trace'\nOK\n</code></pre> <p>See the Set Diagnostic Log Filter page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/kcli/#monitoring-inbound-smtp-handshaking","title":"Monitoring inbound SMTP handshaking","text":"<p>When debugging, it is often helpful to monitor the full SMTP handshaking process in real-time.  The kcli client enables that for inbound connections with the <code>trace-smtp-server</code> function:</p> <pre><code>$ kcli trace-smtp-server\n</code></pre>"},{"location":"userguide/operation/logs/","title":"Viewing Logs","text":"<p>An important part of routine opperations is checking logs. KumoMTA compressed logs are found in <code>/var/log/kumomta/</code> and are named by date stamp. Logs are segmented by a combination of size/time and stored in compressed files named after the time that the segment was started. To read these, you need to unpack them first. You have many options for configuring logging.</p> <pre><code>/var/log/kumomta\n\u251c\u2500\u2500 20230311-033705\n\u251c\u2500\u2500 20230311-033844\n\u251c\u2500\u2500 20230312-182542\n\u2514\u2500\u2500 20230314-181435\n</code></pre>"},{"location":"userguide/operation/logs/#using-tailer","title":"Using <code>tailer</code>","text":"<p>The <code>tailer</code> utility, found at <code>/opt/kumomta/sbin/tailer</code>, is the easiest way to quickly review logs.  The <code>--tail</code> flag will follow the log files in real time:</p> <pre><code>$ sudo /opt/kumomta/sbin/tailer --tail /var/log/kumomta\n/var/log/kumomta/20230809-153944\n{\"type\":\"Reception\",\"id\":\"f68462cf36ca11ee99f450ebf67f93bd\",\"sender\":\"wez@exa\nmple.com\",\"recipient\":\"wez@example.com.org\",\"queue\":\"example.com.org\",\"site\":\n\"\",\"size\":518,\"response\":{\"code\":250,\"enhanced_code\":null,\"content\":\"\",\"comma\nnd\":null},\"peer_address\":{\"name\":\"foo.lan\",\"addr\":\"127.0.0.1\"},\"timestamp\":16\n91595584,\"created\":1691595584,\"num_attempts\":0,\"bounce_classification\":\"Uncat\negorized\",\"egress_pool\":null,\"egress_source\":null,\"feedback_report\":null,\"met\na\":{},\"headers\":{},\"delivery_protocol\":null,\"reception_protocol\":\"ESMTP\",\"nod\neid\":\"4eb22880-dc03-44dc-a4d1-4d0e68ac7845\"}\nwaiting for more files\n</code></pre> <p>The above example is shown artificially wrapped for the purposes of displaying nicely in this documentation. The actual log records are not output with wrapping.</p>"},{"location":"userguide/operation/logs/#manually","title":"Manually","text":"<p>We can take a look at a specific log by decompressing it and since these are zstd compressed, you can view all but the current one with zstdcat. ZSTD is a streaming compression utility so the current file cannot be accessed until it is flushed and closed. You can force the current log to close by stopping KumoMTA.</p> <p>The default for log segments is to flush them after 1GB of data is written, but you can adjust them to flush after a certain amount of time if you find that you are regularly wanting to inspect the logs on a live system.</p> <p>kumo.configure_local_logs has all of the available logging configuration options.</p> <p>Using the example above, we can see the content of the newest file after stopping KumoMTA with a <code>zstdcat /var/log/kumomta/20230314-181435</code>.</p> <p>If you have not done so already, you will want to install <code>zstd</code> with a (<code>dnf</code> or) <code>apt install zstd</code>.  Below there is a sample of a decompressed received log:</p> <pre><code>$ zstdcat /var/log/kumomta/20230428-201424_recv`\n{\"type\":\"Reception\",\"id\":\"44d70f50e60111ed8162000d3afc4acf\",\"sender\":\"noreply@example.com\",\n\"recipient\":\"recipient@example.com\",\"queue\":\"example.com\",\"site\":\"\",\"size\":27,\n\"response\":{\"code\":250,\"enhanced_code\":null,\"content\":\"\",\"command\":null},\n\"peer_address\":{\"name\":\"\",\"addr\":\"127.0.0.1\"},\"timestamp\":1682712864,\"created\":1682712864,\n\"num_attempts\":0,\"bounce_classification\":\"Uncategorized\",\"egress_pool\":null,\"egress_source\":null,\n\"feedback_report\":null,\"meta\":{},\"headers\":{\"Subject\":\"hello\"}}\n</code></pre> <p>These JSON formatted logs can be programatically consumed or read manually as shown above for debugging and maintenance.</p> <p>Formatting can also be applied using the Mini Jinja tempating engine.</p>"},{"location":"userguide/operation/outbound_auth/","title":"Delivering Messages Using SMTP AUTH","text":"<p>While not used when delivering messages to remote hosts under normal circumstances, there are scenarios where the KumoMTA server must authenticate when relaying mail. Some examples include:</p> <ul> <li>Relaying incoming mail to internal hosts that require authentication.</li> <li>Relaying outgoing mail through a third-party relay provider via SMTP.</li> <li>Delivering mail to a peer system as part of a processing chain.</li> </ul>"},{"location":"userguide/operation/outbound_auth/#configuring-an-egress_path-to-use-auth","title":"Configuring an egress_path to Use AUTH","text":"<p>The following example shows how SMTP AUTH information can be added to an egress_path config:</p> <pre><code>kumo.on('get_egress_path_config', function(domain, site_name)\nreturn kumo.make_egress_path {\nenable_tls = 'Required',\nsmtp_auth_plain_username = 'scott',\n-- The password can be any keysource value\nsmtp_auth_plain_password = {\nkey_data = 'tiger',\n},\n}\nend)\n</code></pre> <p>Warning</p> <p>The above example would add AUTH credentials to every outbound connection. In production, this should be selectively applied based on the destination host or domain.</p> <p>See the make_egress_path section of the Reference Manual for more information.</p>"},{"location":"userguide/operation/outbound_auth/#using-a-keysource-with-smtp-auth","title":"Using a Keysource with SMTP AUTH","text":"<p>Storing credentials in a static policy file is not recommended. KumoMTA supports multiple options for secure key storage, and we highly recommend that all authentication and signing keys be stored in a keysource.</p> <p>When using a keysource, the value of `smtp_auth_plain_password is any keysource, which allows for specifying the password via a credential manager such as HashiCorp Vault.</p> <pre><code>kumo.on('get_egress_path_config', function(domain, site_name)\nreturn kumo.make_egress_path {\nenable_tls = 'Required',\nsmtp_auth_plain_username = 'scott',\n-- The password can be any keysource value.\n-- Here we are loading the credential for the domain\n-- from HashiCorp vault\nsmtp_auth_plain_password = {\nvault_mount = 'secret',\nvault_path = 'smtp-auth/' .. domain,\n},\n}\nend)\n</code></pre> <p>See the keysource section of the Reference Manual for more information.</p>"},{"location":"userguide/operation/outbound_auth/#using-the-traffic-shaping-helper-with-auth-parameters","title":"Using The Traffic Shaping Helper with AUTH Parameters","text":"<p>As mentioned earlier, SMTP AUTH must be selectively applied. One way to facilitate the configuration of SMTP AUTH is to use the <code>shaping.lua</code> traffic shaping helper.</p> <p>When using shaping.lua, the hostname or IP of the target host can be used as a domain, with mx_rollup disabled, and the AUTH options listed.</p> <p>For example, to use a keysource with a local host, the following could be added to a custom TOML file:</p> <pre><code>[\"192.168.1.10\"]\nmx_rollup = false\nsmtp_auth_plain_username = \"scott\"\nsmtp_auth_plain_password = { vault_mount = \"secret\", vault_path = \"smtp-auth/local\" }\n</code></pre> <p>See the traffic shaping section of the User Guide for additional information.</p>"},{"location":"userguide/operation/performance/","title":"Performance Tuning","text":"<p>KumoMTA performance can be optimized by fine tuning system parameters. The settings below are examples only but have helped optimize test and development servers. This example represents a starting off point, you should research these and tune as needed for your own system.</p> <p>KumoMTA makes heavy use of files, RAM, CPU and network resources. Setting these can be helpful as a default Linux install assumes the need to share resources with many applications, but we need to allow KumoMTA to use as much of the resource pool as possible.</p>"},{"location":"userguide/operation/performance/#tuning-sysctlconf","title":"Tuning sysctl.conf","text":"<p>The following tuning parameters can help KumoMTA fully leverage its host server resources.</p> <p>These parameters should be added or updated in /etc/sysctl.conf:</p> <pre><code>vm.max_map_count = 768000\nnet.core.rmem_default = 32768\nnet.core.wmem_default = 32768\nnet.core.rmem_max = 262144\nnet.core.wmem_max = 262144\nfs.file-max = 250000\nnet.ipv4.ip_local_port_range = 5000 63000\nnet.ipv4.tcp_tw_reuse = 1\nkernel.shmmax = 68719476736\nnet.core.somaxconn = 1024\nvm.nr_hugepages = 20\nkernel.shmmni = 4096\n</code></pre> <p>After editing, the changes can be implemented without a restart with the sysctl -p command.</p>"},{"location":"userguide/operation/performance/#performance-testing","title":"Performance Testing","text":"<p>Performance testing must not be performed against the public internet, as large volumes of test message can be catastrophic for sending reputation. Instead, a second instance of KumoMTA should be installed that uses the sink.lua policy script found at https://github.com/KumoCorp/kumomta/blob/main/sink.lua.</p> <p>Write the script to /opt/kumomta/etc/policy/sink.lua and start the sink server using the following command:</p> <pre><code>sudo KUMOD_LOG=kumod=info /opt/kumomta/sbin/kumod \\\n--policy /opt/kumomta/etc/policy/sink.lua --user kumod\n</code></pre> <p>With the sink server configured and running, you can send test messages to the sink, knowing that they will be discarded and not relayed to the public Internet. You may want to block outbound traffic on port 25 from your testing servers to help ensure no messages are relayed externally.</p> <p>Included with the packaged KumoMTA builds is a \"Traffic Generator\" that can be use to send volume test mail for this purpose. The <code>traffic-gen</code> appends a known domain to all outbound mail that resolves to your own loopback address so that mail can be delivered, but will never deliver to real addresses:</p> <pre><code>sudo /opt/kumomta/sbin/traffic-gen --target &lt;your.sink.server&gt;:25 --concurrency 20000 --message-count 100000 --body-size 100000\n</code></pre> <p>For additional parameters for the <code>traffic-gen</code> utility see: <pre><code>sudo /opt/kumomta/sbin/traffic-gen --help\n</code></pre></p> <p>The <code>traffic-gen</code> script is used internally by the KumoMTA team to test performance before each release.</p> <p>It is helpful to use custom routing to configure the test server to route all messages to the sink server, with the sink configured to dev/null all messages. Modify the <code>init.lua</code> on the test server with the following:</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\nmsg:set_meta('queue', 'my.sink.server')\nend)\n</code></pre>"},{"location":"userguide/operation/performance/#sample-test-results","title":"Sample Test Results","text":"<p>The hardware configuration used in this example is one \"sending\" configured KumoMTA instance hosted on AWS (variable CPU and RAM) and one \"sink\" KumoMTA instance hosted on Azure (8 CPU/16GB RAM) using a payload of 100KB messages sent in a loop 100,000 times.</p> <p>The test utilized the included traffic-gen utility as described above.</p> CPU RAM RATE 2 4 2.7 MMH 4 16 4.4 MMH 8 30 4.9 MMH 16 64 5.1 MMH <p>NOTE that these numbers are NOT guaranteed and are for informational purposes only. Your results may vary considerably.</p> <p>In July 2023 another round of testing was done with more detailed results.  those results are shown in the table below and were documented in the blog post How we built the most performant Message Transfer Agent on the planet:</p> <p></p>"},{"location":"userguide/operation/proxy/","title":"Routing Messages Via Proxy Servers","text":"<p>KumoMTA support SOCK5 and HAProxy for use as forward proxies as part of message delivery.</p> <p>The most common use cases for a forward proxy are:</p> <ul> <li>Sharing IP addresses between multiple KumoMTA instances for high availability.</li> <li>Leveraging more IP addresses than permitted per instance by a hosting provider.</li> <li>Utilizing IP addresses in remote environments without additional MTA instances.</li> </ul> <p>Due to the limitations inherent in the HAProxy protocol when used as a forward proxy, it is strongly recommended that SOCKS5 be utilized when possible, but HAProxy support is provided for existing installations migrating to KumoMTA.</p>"},{"location":"userguide/operation/proxy/#using-socks5-for-delivery","title":"Using SOCKS5 for Delivery","text":""},{"location":"userguide/operation/proxy/#using-the-kumoproxy-socks5-proxy-server","title":"Using The KumoProxy SOCKS5 Proxy Server","text":"<p>While KumoMTA will work with any compliant SOCKS5 proxy server, we have built KumoProxy to serve as an integrated and supported proxy server specifically for use with KumoMTA.</p> <p>TODO* Install instructions are pending for the Beta 3 release.</p>"},{"location":"userguide/operation/proxy/#configuring-an-egress_source-for-socks5-proxy-use","title":"Configuring an egress_source for SOCKS5 Proxy Use","text":"<p>Configuring an egress_source to use a SOCKS5 proxy server is done as part of the make_egress_source function call:</p> <pre><code>kumo.on('kumo.get_egress_source', function(source_name)\nif source_name == 'ip-1' then\n-- Make a source that will emit from 10.0.0.1, via a proxy server\nreturn kumo.make_egress_source {\nname = 'ip-1',\n-- The SOCKS5 proxy server address and port\nsocks5_proxy_server = '10.0.5.10:5000',\n-- Used by the SOCKS5 proxy server to connect to the destination address\nsocks5_proxy_source_address = '10.0.0.1',\nehlo_domain = 'mta1.examplecorp.com',\n}\nend\nend)\n</code></pre> <p>The SOCKS5 proxy server will forward communications via the <code>socks5_proxy_source_address</code> IP address to reach the remote destination host.</p> <p>Each IP address hosted by a SOCKS5 proxy server should be defined as its own <code>egress_source</code>, IPv4 and IPv6 should be configured as separate sources, but can be hosted by the same HAProxy instance(s).</p> <p>See the make_egress_source page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/proxy/#using-haproxy-for-delivery","title":"Using HAProxy for Delivery","text":"<p>KumoMTA supports V2 of the HAProxy PROXY protocol, enabling the use of HAProxy as a forward SMTP proxy for the delivery of messages via IP addresses on the HAProxy host.</p>"},{"location":"userguide/operation/proxy/#configuring-an-egress_source-for-haproxy-use","title":"Configuring an egress_source for HAProxy Use","text":"<p>Configuring an egress_source to use an HAProxy server is done as part of the make_egress_source function call:</p> <pre><code>kumo.on('kumo.get_egress_source', function(source_name)\nif source_name == 'ip-1' then\n-- Make a source that will emit from 10.0.0.1, via a proxy server\nkumo.define_egress_source {\nname = 'ip-1',\n-- The HAProxy server address and port\nha_proxy_server = '10.0.5.10:5000',\n-- Used by HAProxy to connect to the destination address\nha_proxy_source_address = '10.0.0.1',\nehlo_domain = 'mta1.examplecorp.com',\n}\nend\nend)\n</code></pre> <p>The HAProxy server will forward communications via the <code>ha_proxy_source_address</code> IP address to reach the remote destination host.</p> <p>Each IP address hosted by an HAProxy instance should be defined as its own <code>egress_source</code>, IPv4 and IPv6 should be configured as separate sources, but can be hosted by the same HAProxy instance(s).</p> <p>See the make_egress_source page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/proxy/#haproxy-server-configuration","title":"HAProxy Server Configuration","text":"<p>An example HAProxy server config is as follows:</p> <pre><code>global\n    log stdout  format raw  local0  debug\n\ndefaults\n    timeout connect 10s\n    timeout client 30s\n    timeout server 30s\n    log global\n\nlisten outboundsmtp\n    log global\n    bind 0:2526 accept-proxy\n    mode tcp\n    use-server v4 if { src 0.0.0.0/0 }\n    use-server v6 if { src ::/0 }\n    server v4 0.0.0.0 source 0.0.0.0 usesrc clientip\n    server v6 ::: source ::: usesrc clientip\n</code></pre> <p>The HAProxy instance would be launched with the following command:</p> <pre><code>$ sudo haproxy -f haproxy.conf -V\n</code></pre> <p>For further information on HAProxy, see the HAProxy Documentation.</p>"},{"location":"userguide/operation/smtpinjection/","title":"Injecting Using SMTP","text":"<p>KumoMTA will listen for message injection in any listener defined in configuration. You have complete control over the IPs and Ports available for message injection.</p> <p>The ESMTP Listener will accept any properly formatted SMTP connection request allowed by its configuration.  For instance, based on this:</p> <pre><code>kumo.start_esmtp_listener {\nlisten = '0.0.0.0:25',\nhostname = 'mail.example.com',\nrelay_hosts = { '127.0.0.1', '10.5.1.0/24' },\n}\n</code></pre> <p>KumoMTA will accept any SMTP injection from the local host as well as any hosts in the 10.5.1.0/24 CIDR block on port 25.  The most basic form of \"injection\" is to test from localhost using nc or telnet.</p> <pre><code>ehlo moto\nmail from:youremail@address.com\nrcpt to:youremail@address.com\nDATA\nfrom:youremail@address.com\nto:youremail@address.com\nsubject: My First Email\n\nHey, this is my first email!\n.\n</code></pre> <p>If that returns a <code>250 OK</code>, then any more complex injection should work as well.</p> <p>In most campaign systems that connect with third-party MTA's, you will need to enter the configuration settings, and find something like \"SMTP\" or \"OutBound Email\" and set the SMTP Port, Hostname or IP ddress and If you have configured SMTP_Auth, your injection username and password as well.</p> <p>Below is a configuration screen for Ongage</p> <p></p> <p>And this is a sample of the configuration page for Mautic marketing automation.</p> <p></p>"},{"location":"userguide/operation/starting/","title":"Starting KumoMTA","text":"<p>Once KumoMTA has been installed and an initial policy script is in place, the server can be started with the following command:</p> <pre><code>$ sudo systemctl start kumomta\n</code></pre> <p>It can be enabled as a service with:</p> <pre><code>$ sudo systemctl enable kumomta\n</code></pre> <p>You can check the status with:</p> <pre><code>$ sudo systemctl status kumomta\n</code></pre> <p>It can also be started manually with:</p> <pre><code>$ sudo /opt/kumomta/sbin/kumod \\\n--policy /opt/kumomta/etc/policy/init.lua \\\n--user kumod\n</code></pre> <ul> <li>Using sudo allows it to run as a privileged user so it can access port 25 which is needed to send and receive from most MTAs.</li> <li>The daemon <code>kumod</code> is the MTA</li> <li>The directive --policy makes kumod load the 'init.lua' file as configuration policy.</li> <li>The --user directive allows the server to drop privileges after attaching to port 25 so that it does not continue to run as root.</li> </ul> <p>For more detailed output, prepend <code>KUMOD_LOG=kumod=info</code> (or debug for even more detail):</p> <pre><code>$ sudo KUMOD_LOG=kumod=info /opt/kumomta/sbin/kumod \\\n--policy /opt/kumomta/etc/policy/init.lua --user kumod\n</code></pre> <p>If all goes well, it should return a PID and drop you back to a Linux prompt.</p> <p>If KumoMTA does not start, refer to the Troubleshooting Page of the User Guide.</p>"},{"location":"userguide/operation/status/","title":"Getting Server Status","text":"<p>Once KumoMTA is installed, you can check on the server status with systemctl.</p> <pre><code>$ sudo systemctl status kumomta\n</code></pre> <p>The result should look something like this:</p> <pre><code> kumomta.service - KumoMTA SMTP service\n     Loaded: loaded (/lib/systemd/system/kumomta.service; enabled; vendor preset: enabled)\n     Active: active (running) since Thu 2023-04-27 22:59:06 MST; 10h ago\n   Main PID: 17912 (kumod)\n      Tasks: 28 (limit: 19190)\n     Memory: 257.1M\n     CGroup: /system.slice/kumomta.service\n             \u2514\u250017912 /opt/kumomta/sbin/kumod --policy /opt/kumomta/etc/policy/init.lua --user kumod\n\nApr 27 22:59:06 kdev2.kumomta.com systemd[1]: Started KumoMTA SMTP service.\nApr 27 22:59:06 kdev2.kumomta.com kumod[17912]: 2023-04-28T05:59:06.444479Z  INFO main kumod::memory: using limits: soft=Some(\"12.58 GB\"), hard=So&gt;\nApr 27 22:59:06 kdev2.kumomta.com kumod[17912]: 2023-04-28T05:59:06.450824Z  INFO localset-2 kumod::http_server: http listener on 0.0.0.0:8000\nApr 27 22:59:06 kdev2.kumomta.com kumod[17912]: 2023-04-28T05:59:06.471926Z  INFO localset-2 kumod::spool: starting enumeration for meta\nApr 27 22:59:06 kdev2.kumomta.com kumod[17912]: 2023-04-28T05:59:06.471995Z  INFO localset-2 kumod::smtp_server: smtp listener on 0.0.0.0:25\nApr 27 22:59:06 kdev2.kumomta.com kumod[17912]: 2023-04-28T05:59:06.472008Z  INFO localset-2 kumod::smtp_server: smtp listener on 0.0.0.0:2026\nApr 27 22:59:06 kdev2.kumomta.com kumod[17912]: 2023-04-28T05:59:06.475882Z  INFO localset-2 kumod: initialization complete\n</code></pre> <p>The above is from a newer installation, but the log will grow.  If you are debugging an older install, <code>journalctl -r -n 10 -u kumomta.service</code> will show the last 10 lines (<code>-n 10</code>) in reverse order (<code>-r</code>).  <code>man journalctl</code> is your friend.</p> <p>If you need to find the installed version, you can run:</p> <pre><code>$ /opt/kumomta/sbin/kumod --version\n</code></pre> <p>This will be important if you ever need to reach out for support.</p> <p>If you have configured an HTTP listener, you can access server metrics with:</p> <pre><code>$ curl -i 'http://localhost:8000/metrics'\n</code></pre> <p>That will show a long form of the server metrics with detailed comments.</p> <p>If you want just the data in a nice JSON format, use:</p> <pre><code>$ curl -i 'http://localhost:8000/metrics.json'\n</code></pre> <p>Metrics available include the following at the time of writing, and will increase as we build out the product:</p> <ul> <li><code>connection_count</code>: number of active connections</li> <li><code>lua_count</code>: the number of lua contexts currently alive</li> <li><code>lua_load_count</code>: how many times the policy lua script has been loaded into a new context</li> <li><code>lua_spare_count</code>: the number of lua contexts available for reuse in the pool</li> <li><code>memory_limit</code>: soft memory limit measured in bytes</li> <li><code>memory_usage</code>: number of bytes of used memory</li> </ul>"},{"location":"userguide/operation/troubleshooting/","title":"Troubleshooting KumoMTA","text":"<p>There are several things that can go wrong, especially when first installing KumoMTA. This page is intended to help with troubleshooting common issues.</p> <p>Note<p>There are multiple ways to get help with KumoMTA, see the How To Get Help page for more information.</p> </p>"},{"location":"userguide/operation/troubleshooting/#using-swaks","title":"Using Swaks","text":"<p>When troubleshooting, it helps to eliminate external factors, including the injecting email infrastructure. We recommend using Swaks to perform test injections as it is known to act in an RFC compliant way when injecting messages. See the Swaks Documentation for more information.</p>"},{"location":"userguide/operation/troubleshooting/#tracing-server-communications","title":"Tracing Server Communications","text":"<p>When having issues with injecting messages, use the <code>kcli trace-smtp-server</code> command to receive an output of all communications between KumoMTA and the incoming client.</p> <pre><code>[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]   0ns === Connected 2023-11-24 15:54:55.532224578 UTC\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]   0ns === conn_meta received_from=\"2xx.xxx.xx.xx:40422\"\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]   0ns === conn_meta received_via=\"1xx.x.xxx.xx:587\"\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]   0ns === conn_meta reception_protocol=\"ESMTP\"\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]  17\u00b5s &lt;-  220 kumomta.abcdef.com KumoMTA\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 182ms  -&gt; EHLO kumomta.abcdef.com\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 183ms === smtp_server_ehlo: Ok\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 183ms &lt;-  250-kumomta.abcdef.com Aloha kumomta.abcdef.com\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 183ms &lt;-  250-PIPELINING\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 183ms &lt;-  250-ENHANCEDSTATUSCODES\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 183ms &lt;-  250 STARTTLS\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 588ms  -&gt; STARTTLS\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587] 588ms &lt;-  220 Ready to Start TLS\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]    1s  -&gt; QUIT\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]    1s &lt;-  221 So long, and thanks for all the fish!\n[2xx.xxx.xx.xx:40422-&gt;1xx.x.xxx.xx:587]    1s === Closed\n</code></pre>"},{"location":"userguide/operation/troubleshooting/#reviewing-the-system-journal","title":"Reviewing the System Journal","text":"<p>KumoMTA logs to the system journal for all error and status messages during operation, to view the log entries use journalctl:</p> <pre><code>[root@localhost ~]# journalctl -f -n 50 -u kumomta.service\nOct 19 21:52:59 localhost systemd[1]: Started KumoMTA SMTP service.\nOct 19 21:53:00 localhost.localdomain kumod[902]: 2023-10-20T01:53:00.328546Z  INFO localset-0 kumod: NodeId is 2a32fb9b-7353-48bd-a06e-cc97e224c924\nOct 19 21:53:00 localhost.localdomain kumod[902]: 2023-10-20T01:53:00.337267Z  INFO localset-0 kumo_server_common::http_server: http listener on 127.0.0.1:8000\nOct 19 21:53:00 localhost.localdomain kumod[902]: 2023-10-20T01:53:00.348273Z  INFO localset-0 kumod::smtp_server: smtp listener on 0.0.0.0:25\nOct 19 21:53:01 localhost.localdomain kumod[902]: 2023-10-20T01:53:01.221127Z  INFO localset-0 kumod::spool: start_spool: enumeration done, spooled in 2 msgs over 117.40671ms\nOct 19 21:53:01 localhost.localdomain kumod[902]: 2023-10-20T01:53:01.221509Z  INFO localset-0 kumo_server_common::start: initialization complete\n</code></pre> <p>In this example the -f option tells journalctl to follow the log, in other words to tail or continuously read the file, the -n 50 option tells journalctl to start by reading the previous 50 lines, and the -u option tells journalctl to filter by a specific unit, in this case the kumomta.service unit.</p> <p>A common issue with new installs is ownership of the spool directory. When the spool is provisioned as a separate volume, it will not be owned by the kumod user. In this example we change ownership of the /var/spool/kumomta directory, then attempt to start the kumomta service, then read the system journal to identify the issue:</p> <pre><code>[root@localhost spool]# systemctl stop kumomta\n[root@localhost spool]# chown -R root /var/spool/kumomta/\n[root@localhost spool]# systemctl start kumomta\n[root@localhost spool]# journalctl -f -n 50 -u kumomta.service\nOct 19 22:09:06 localhost.localdomain systemd[1]: Started KumoMTA SMTP service.\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.752782Z  INFO localset-0 kumod: NodeId is 2a32fb9b-7353-48bd-a06e-cc97e224c924\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.755699Z  INFO localset-0 kumo_server_common::http_server: http listener on 127.0.0.1:8000\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.756982Z  INFO localset-0 kumod::smtp_server: smtp listener on 0.0.0.0:25\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.757415Z ERROR localset-0 kumod::spool: Error in spool: Opening spool data: opening pid file /var/spool/kumomta/data/lock: Permission denied (os error 13)\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.758039Z ERROR localset-0 kumod::spool: Error in spool: Opening spool meta: opening pid file /var/spool/kumomta/meta/lock: Permission denied (os error 13)\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.758363Z  INFO localset-0 kumod::smtp_server: smtp listener on 0.0.0.0:25 -&gt; stopping\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.758051Z  INFO       main kumo_server_common::start: Shutdown completed OK!\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.772671Z ERROR localset-0 kumo_server_common::start: problem initializing: No spools have been defined\nOct 19 22:09:06 localhost.localdomain kumod[5356]: 2023-10-20T02:09:06.772827Z  INFO localset-0 kumo_server_common::start: initialization complete\nOct 19 22:09:06 localhost.localdomain kumod[5356]: Error: Initialization raised an error\nOct 19 22:09:06 localhost.localdomain systemd[1]: kumomta.service: Main process exited, code=exited, status=1/FAILURE\nOct 19 22:09:06 localhost.localdomain systemd[1]: kumomta.service: Failed with result 'exit-code'.\nOct 19 22:09:07 localhost.localdomain systemd[1]: Failed to start KumoMTA SMTP service.\n</code></pre> <p>This error message makes it clear that there was an issue with permissions on the spool folder that prevented the kumomta service from starting.</p>"},{"location":"userguide/operation/troubleshooting/#changing-the-log-level","title":"Changing the Log Level","text":"<p>Sometimes the default logging level will not expose sufficient information to troubleshoot certain issues.</p> <p>To increase the verbosity of the logs written to the system journal, use the kumo.set_diagnostic_log_filter function in your `init.lua`` policy's init event handler:</p> <pre><code>kumo.on('init', function()\nkumo.set_diagnostic_log_filter 'kumod=debug'\nend)\n</code></pre> <p>In addition, you can adjust the log filter level dynamically using the HTTP API:</p> <pre><code>curl -i 'http://localhost:8000/api/admin/set_diagnostic_log_filter/v1' \\\n    -H 'Content-Type: application/json' \\\n    -d '{\"filter\":\"kumod=debug\"}'\n</code></pre> <p>This will produce output similar to the following:</p> <pre><code>Oct 20 09:26:43 localhost.localdomain systemd[1]: Started KumoMTA SMTP service.\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.030934Z  INFO localset-2 kumod: NodeId is 2a32fb9b-7353-48bd-a06e-cc97e224c924\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.032892Z  INFO localset-2 kumod::smtp_server: smtp listener on 0.0.0.0:25\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.033051Z DEBUG localset-2 kumod::spool: Defining local disk spool 'data' on /var/spool/kumomta/data\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.033179Z ERROR localset-2 kumod::spool: Error in spool: Opening spool data: opening pid file /var/spool/kumomta/data/lock: Permission denied (os error 13)\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.033404Z DEBUG localset-2 kumod::spool: Defining local disk spool 'meta' on /var/spool/kumomta/meta\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.033490Z ERROR localset-2 kumod::spool: Error in spool: Opening spool meta: opening pid file /var/spool/kumomta/meta/lock: Permission denied (os error 13)\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.048202Z  INFO localset-2 kumod::smtp_server: smtp listener on 0.0.0.0:25 -&gt; stopping\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.050200Z DEBUG     logger kumod::logging: started logger thread\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.051984Z DEBUG     logger kumod::logging: calling state.logger_thread()\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.052337Z DEBUG     logger kumod::logging: LogFileParams: LogFileParams {\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     log_dir: \"/var/log/kumomta\",\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     max_file_size: 1000000000,\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     back_pressure: 128000,\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     compression_level: 0,\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     max_segment_duration: None,\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     meta: [],\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     headers: [],\nOct 20 09:26:44 localhost.localdomain kumod[6061]:     per_record: {},\nOct 20 09:26:44 localhost.localdomain kumod[6061]: }\nOct 20 09:26:44 localhost.localdomain kumod[6061]: Error: Initialization raised an error\nOct 20 09:26:44 localhost.localdomain kumod[6061]: 2023-10-20T13:26:44.053482Z DEBUG     logger kumod::logging: waiting until deadline=None for a log record\nOct 20 09:26:44 localhost.localdomain systemd[1]: kumomta.service: Main process exited, code=exited, status=1/FAILURE\nOct 20 09:26:44 localhost.localdomain systemd[1]: kumomta.service: Failed with result 'exit-code'.\n</code></pre> <p>Note the additional DEBUG level log entries compared to the previous example.</p> <p>The log levels available, in order from least to most verbose are: * Error * Warn * Info * Debug * Trace</p> <p>Warning</p> <p>The lower, more verbose levels of log levels can be very verbose, especially the  trace level. These levels should not be enabled permanently as they can lead to a full disk in a short period of time.</p>"},{"location":"userguide/operation/webhooks/","title":"Publishing Log Events Via Webhooks","text":"<p>While logs are an invaluable resource for monitoring and troubleshooting mail flows, log rotating and parsing adds complexity and latency when the goal is loading the email event data into an existing platform.</p> <p>Webhooks are ideal for near real-time integration into existing platforms, providing the ability to send message events to a user-defined HTTP endpoint, with queuing out of the box to ensure durability in the event of an error on the part of the HTTP receiving service.</p> <p>Webhooks are implemented in KumoMTA by triggering a Lua hook on log events that allows for a policy script to load the log events into their own message queue within the KumoMTA queueing structure like any other message, ensuring durability and performance for queued log events.</p> <p>Webhook events are moved through the queues like SMTP messages, and when they enter the Ready Queue they are set to deliver via an arbitrary Lua event rather than SMTP, with the Lua script configured to issue an HTTP request to the destination server.</p>"},{"location":"userguide/operation/webhooks/#using-the-log_hookslua-helper","title":"Using the log_hooks.lua Helper","text":"<p>While the methods documented below can be used to implement advanced webhook delivery scenarios, most users will benefit from using the log_hooks.lua helper.</p> <p>To implement the helper, add the following to your init.lua:</p> <pre><code>local log_hooks = require 'policy-extras.log_hooks'\nlog_hooks:new_json {\nname = 'webhook',\n-- log_parameters are combined with the name and\n-- passed through to kumo.configure_log_hook\nlog_parameters = {\nheaders = { 'Subject', 'X-Customer-ID' },\n},\n-- queue config are passed to kumo.make_queue_config.\n-- You can use these to override the retry parameters\n-- if you wish.\n-- The defaults are shown below.\nqueue_config = {\nretry_interval = '1m',\nmax_retry_interval = '20m',\n},\n-- The URL to POST the JSON to\nurl = 'http://10.0.0.1:4242/log',\n}\n</code></pre> <p>More advanced usage is possible by implementing the full call to the log_hooks.lua helper, in the following format:</p> <pre><code>local log_hooks = require 'policy-extras.log_hooks'\nlog_hooks:new {\nname = 'webhook',\n-- log_parameters are combined with the name and\n-- passed through to kumo.configure_log_hook\nlog_parameters = {\nheaders = { 'Subject', 'X-Customer-ID' },\n},\n-- queue config are passed to kumo.make_queue_config.\n-- You can use these to override the retry parameters\n-- if you wish.\n-- The defaults are shown below.\nqueue_config = {\nretry_interval = '1m',\nmax_retry_interval = '20m',\n},\nconstructor = function(domain, tenant, campaign)\nlocal connection = {}\nlocal client = kumo.http.build_client {}\nfunction connection:send(message)\nlocal response = client\n:post('http://10.0.0.1:4242/log')\n:header('Content-Type', 'application/json')\n:body(message:get_data())\n:send()\nlocal disposition = string.format(\n'%d %s: %s',\nresponse:status_code(),\nresponse:status_reason(),\nresponse:text()\n)\nif response:status_is_success() then\nreturn disposition\nend\n-- Signal that the webhook request failed.\n-- In this case the 500 status prevents us from retrying\n-- the webhook call again, but you could be more sophisticated\n-- and analyze the disposition to determine if retrying it\n-- would be useful and generate a 400 status instead.\n-- In that case, the message we be retryed later, until\n-- it reached it expiration.\nkumo.reject(500, disposition)\nend\nreturn connection\nend,\n}\n</code></pre>"},{"location":"userguide/operation/webhooks/#configuring-a-log-hook","title":"Configuring a Log Hook","text":"<p>The first step in setting up Webhooks is to turn on the log hook. This adds a Lua event for every log entry so that a script can be implemented to selectively queue the event data:</p> <p>The call to <code>configure_log_hook</code> is placed in the init event handler:</p> <pre><code>kumo.on('init', function()\nkumo.configure_log_hook {\nname = 'webhook',\nheaders = { 'Subject', 'X-Customer-ID' },\n}\nend)\n</code></pre> <p>The <code>configure_log_hook</code> function can take similar parameters to the <code>configure_local_logs</code> function with regards to additional data and formatting, see the configure_log_hook page of the Reference manual for more information.</p>"},{"location":"userguide/operation/webhooks/#handling-log-hook-messages","title":"Handling Log Hook Messages","text":"<p>With the <code>configure_log_hook</code> call added to the init event, the KumoMTA server creates a new message object for each log entry, specially formatted to contain the log record as the message body.</p> <p>The message will be passed to the should_enqueue_log_record event, which is where we can add logic to process the message and queue it for later delivery.</p> <p>The following example shows how to handle the event, and how to avoid a loop that can occur if the webhook log events are in turn processed as webhooks:</p> <pre><code>kumo.on('should_enqueue_log_record', function(msg)\nlocal log_record = msg:get_meta 'log_record'\n-- avoid an infinite loop caused by logging that we logged that we logged...\n-- Check the log record: if the record was destined for the webhook queue\n-- then it was a record of the webhook delivery attempt and we must not\n-- log its outcome via the webhook.\nif log_record.queue ~= 'webhook' then\n-- was some other event that we want to log via the webhook\nmsg:set_meta('queue', 'webhook')\nreturn true\nend\nreturn false\nend)\n</code></pre> <p>The preceding example assigns the messages to a queue named <code>webhook</code> if the message is not already associated with that queue (a record of a webhook delivery event), and otherwise returns false, indicating that the record should not be queued. See the should_enqueue_log_record page of the Reference Manual for more information.</p>"},{"location":"userguide/operation/webhooks/#configuring-a-queue-handler-for-webhooks","title":"Configuring A Queue Handler for Webhooks","text":"<p>When a message is ready to be queued, the get_queue_config event is fired, at which point we can specify the protocol of the queue, in this case <code>custom_lua</code>. In the example below, we check whether the message is queued to the <code>webhook</code> queue and act accordingly:</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nif domain == 'webhook' then\n-- Use the `make.webhook` event to handle delivery\n-- of webhook log records\nreturn kumo.make_queue_config {\nprotocol = {\ncustom_lua = {\n-- this will cause an event called `make.webhook` to trigger.\n-- You can pick any name for this event, so long as it doesn't\n-- collide with a pre-defined event, and so long as you bind\n-- to it with a kumo.on call\nconstructor = 'make.webhook',\n},\n},\n}\nend\nreturn kumo.make_queue_config {}\nend)\n</code></pre> <p>For more information on configuring protocols, see the get_queue_config section of the Reference Manual.</p>"},{"location":"userguide/operation/webhooks/#sending-messages-via-http","title":"Sending Messages via HTTP","text":"<p>With the <code>custom_lua</code> protocol defined and a custom event trigger declared, the next step is to catch the <code>make.webhook</code> event with code that sends the message contents over HTTP.</p> <p>The following example sends the content of the webhook queued message over HTTP to a configured host as a POST:</p> <pre><code>-- This is a user-defined event that matches up to the custom_lua\n-- constructor used in `get_queue_config` below.\n-- It returns a lua connection object that can be used to \"send\"\n-- messages to their destination.\nkumo.on('make.webhook', function(domain, tenant, campaign)\nlocal connection = {}\nlocal client = kumo.http.build_client {}\nfunction connection:send(message)\nlocal response = client\n:post(string.format('http://127.0.0.1:%d/log', WEBHOOK_PORT))\n:header('Content-Type', 'application/json')\n:body(message:get_data())\n:send()\nlocal disposition = string.format(\n'%d %s: %s',\nresponse:status_code(),\nresponse:status_reason(),\nresponse:text()\n)\nif response:status_is_success() then\nreturn disposition\nend\n-- Signal that the webhook request failed.\n-- In this case the 500 status prevents us from retrying\n-- the webhook call again, but you could be more sophisticated\n-- and analyze the disposition to determine if retrying it\n-- would be useful and generate a 400 status instead.\n-- In that case, the message we be retryed later, until\n-- it reached it expiration.\nkumo.reject(500, disposition)\nend\nreturn connection\nend)\n</code></pre> <p>Warning</p> <p>Storing credentials as hardcoded values in a policy script such as this is not recommended, instead, use the built-in Secrets Load function. See kumo.secrets/load/.</p> <p>This same methodology could also be used to deliver queued SMTP messages to a third-party API, see the Routing Messages via HTTP Request page of the Policy chapter for more information.</p> <p>This same methodology could also be used to deliver log events and queued messages via AMQP, see the Routing Messages via AMQP page of the Policy chapter for more information.</p>"},{"location":"userguide/policy/","title":"Policy","text":"<p>While the entirety of configuring a KumoMTA instance is done with policy, this chapter is focused specifically on what could be considered advanced use cases involving Lua policy scripts.</p> <p>The examples in this chapter are for advanced users.</p>"},{"location":"userguide/policy/amqp/","title":"Routing Messages via AMQP","text":"<p>In addition to local logging and Webhooks, KumoMTA can relay log events (or other queued messages) via AMQP.</p> <p>KumoMTA supports publishing via AMQP, using Lua.</p> <p>The process to queue log events and make them available for sending via <code>custom_lua</code> as a protocol is covered in the Publishing Log Events Via Webhooks section of the Operations chapter of the User Guide.</p>"},{"location":"userguide/policy/amqp/#configuring-a-queue-handler-for-amqp","title":"Configuring A Queue Handler for AMQP","text":"<p>When a message is ready to be queued, the <code>get_queue_config</code> event is fired, at which point we can specify the protocol of the queue, in this case <code>custom_lua</code>. In the example below, we check whether the message is queued to the <code>amqp</code> queue and act accordingly:</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nif domain == 'amqp' then\n-- Use the `make.webhook` event to handle delivery\n-- of webhook log records\nreturn kumo.make_queue_config {\nprotocol = {\ncustom_lua = {\n-- this will cause an event called `make.webhook` to trigger.\n-- You can pick any name for this event, so long as it doesn't\n-- collide with a pre-defined event, and so long as you bind\n-- to it with a kumo.on call\nconstructor = 'make.amqp',\n},\n},\n}\nend\nreturn kumo.make_queue_config {}\nend)\n</code></pre>"},{"location":"userguide/policy/amqp/#sending-messages-via-amqp","title":"Sending Messages via AMQP","text":"<p>With the custom_lua protocol defined and a custom event trigger declared, the next step is to catch the <code>make.amqp</code> event with code that sends the message contents over HTTP.</p> <p>The following example sends the content of the log message via AMQP:</p> <pre><code>-- This is a user-defined event that matches up to the custom_lua\n-- constructor used in `get_queue_config` below.\n-- It returns a lua connection object that can be used to \"send\"\n-- messages to their destination.\nkumo.on('make.amqp', function(domain, tenant, campaign)\nlocal client = kumo.amqp.build_client 'amqp://localhost'\nlocal confirm = client:publish {\nrouting_key = 'logging',\npayload = message:get_data(),\n}\nlocal result = confirm:wait()\nif result.status == 'Ack' or result.status == 'NotRequested' then\nreturn\nend\n-- result.status must be `Nack`; log the full result\nkumo.reject(500, kumo.json_encode(result))\nend)\n</code></pre> <p>See the AMQP section of the Reference Manual for more information.</p>"},{"location":"userguide/policy/hashicorp_vault/","title":"Using HashiCorp Vault","text":""},{"location":"userguide/policy/hashicorp_vault/#introduction","title":"Introduction","text":"<p>HashCorp Vault is a secure storage tool for maintaining a centralized and secure store of passwords, certificates and other secrets. Vault is only one of the ways you can store secrets outside of your running code, but it is very popular and KumoMTA has native integration.</p> <p>Vault helps you keep password and other secrets separated from running code to help reduce the possibility of security leaks such as accidentally saving your API key in a GitHub repo.</p>"},{"location":"userguide/policy/hashicorp_vault/#configuring-kumomta-to-use-hashicorp-vault","title":"Configuring KumoMTA to use Hashicorp Vault","text":"<p>The documentation in the reference manual is straightforward, but does have some nuance.</p> <p>In the example shown there and below,we are storing the DKIM signing key as a file in vault so it can be called dynamically, but including the vault token in the script is not a particularly secure way of doing things. It is recommended to place the vault address and token in environment variables that are accessible to KumoMTA. In most cases, that will mean modifying the systemd unit service file.</p> <pre><code>local vault_signer = kumo.dkim.rsa_sha256_signer {\nkey = {\nvault_mount = 'secret',\nvault_path = 'dkim/' .. msg:from_header().domain,\n-- vault_address = \"http://127.0.0.1:8200\"\n-- vault_token = \"hvs.TOKENTOKENTOKEN\"\n},\n}\n</code></pre> <p>To modify the systemd service file, use the built in edit command in systemctl. The man page is here, but Digital Ocean has an excellent tutorial that explains it in plain english.</p> <p>The short version is that you can use <code>systemctl edit</code> to edit the file and add \"Environment\" values under the <code>[Service]</code> section so that those values will be available when the system service daemon starts KumoMTA. The example below modified the FULL service config. The --full option can be remove to modify a snippet instead of the full config.</p> <pre><code>sudo systemctl edit --full kumomta.service\n</code></pre> <p>You should disregard everything except the <code>[Service]</code> section. At the bottom of that section, add 2 lines:</p> <pre><code>Environment=VAULT_ADDR='http://&lt;YOUR_SERVER_LOCATION&gt;:8200'\nEnvironment=VAULT_TOKEN='&lt;YOUR_ACCESS_TOKEN&gt;'\n</code></pre> <p>When done, it should look something like this:</p> <pre><code>[Unit]\nDescription=KumoMTA SMTP service\nAfter=syslog.target network.target\nConflicts=sendmail.service exim.service postfix.service\n[Service]\nType=simple\nRestart=always\nExecStart=/opt/kumomta/sbin/kumod --policy /opt/kumomta/etc/policy/init.lua --user kumod\n# Allow sufficient time to wrap up in-flight tasks and safely\n# write out pending data\nTimeoutStopSec=300\nEnvironment=VAULT_ADDR='http://127.0.0.1:8200'\nEnvironment=VAULT_TOKEN='SAMPLE-TOKEN'\n[Install]\nWantedBy=multi-user.target\n</code></pre> <p>Save the file, then reload with the <code>sudo systemctl daemon-reload</code> command.</p>"},{"location":"userguide/policy/hashicorp_vault/#storing-secrets-for-later-use","title":"Storing secrets for later use","text":"<p>There are a number of ways to store secrets, and the method depends on how the vault was created. If configured via the Vault CLI, then aa V2 password can be stored as follows:</p> <pre><code>vault kv put -mount=secret dkim/example.org key=@example-private-dkim-key.pem\n</code></pre> <p>It is important to ensure you are storing Version-2 secrets with a \"key=\" format. In the preceding example, the <code>key</code> points to a filename <code>example-private-dkim-key.pem</code>."},{"location":"userguide/policy/hashicorp_vault/#ways-to-use-vault-with-kumomta","title":"Ways to Use Vault With KumoMTA","text":"<p>Vault has a number of advantages over statically storing secrets. Aside from the obvious security benefits of not exposing your passwords and security keys in your code, it also allows you to physically separate the information. One key use case is storing the vault server in a private network while the KumoMTA instances are deployed around the world or in public colocation or cloud services. If a remote server is compromised, the local vault server can be secured to prevent data leakage.</p> <p>Another advantage is being able to dynamically load keys on demand. This can be very helpful with DKIM key rotation. With the keys stored within the vault, they can be loaded as-needed when messages pass through the server that need a particular key:</p> <pre><code>local vault_signer = kumo.dkim.rsa_sha256_signer {\nkey = {\nvault_mount = 'secret',\nvault_path = 'dkim/' .. msg:from_header().domain,\n},\n}\n</code></pre>"},{"location":"userguide/policy/http/","title":"Routing Messages via HTTP Request","text":"<p>Some sending environments use a mixture of different services to send messages, and while it's possible to relay messages through many services using SMTP, some services are only/better served via an HTTP API.</p> <p>The following example shows how to send a queued message via custom lua, in this case assembling an API call and sending it to a third-party SMTP API relay provider.</p> <p>Warning</p> <p>Storing credentials as hardcoded values in a policy script such as this is not recommended, instead, use the built-in Secrets Load function. See https://docs.kumomta.com/reference/kumo.secrets/load/.</p> <pre><code>kumo.on('make.mailgun', function(domain, tenant, campaign)\nlocal client = kumo.http.build_client {}\nlocal sender = {}\nfunction sender:send(message)\nlocal request =\nclient:post 'https://api.mailgun.net/v3/YOUR_DOMAIN_NAME/messages.mime'\nrequest:basic_auth('api', 'YOUR_API_KEY')\nrequest:form_multipart_data {\nto = message:recipient().email,\nmessage = {\ndata = message:get_data(),\nfile_name = 'mime.msg',\n},\n}\n-- Make the request\nlocal response = request:send()\n-- and handle the result\nlocal disposition = string.format(\n'%d %s %s',\nresponse:status_code(),\nresponse:status_reason(),\nresponse:text()\n)\nif response:status_is_success() then\n-- Success!\nreturn disposition\nend\n-- Failed!\nkumo.reject(400, disposition)\nend\nreturn sender\nend)\nkumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nif tenant == 'mailgun-user' then\nreturn kumo.make_queue_config {\nprotocol = {\ncustom_lua = {\nconstructor = 'make.mailgun',\n},\n},\n}\nend\nreturn kumo.make_queue_config {}\nend)\n</code></pre>"},{"location":"userguide/policy/inbound_auth/","title":"Checking Inbound SMTP Authentication","text":"<p>When hosting relay users it is important to protect your infrastructure from malicious senders, often without the ability to whitelist the IP addresses of legitimate users. In such environments, it is critical to setup SMTP Authentication to validate injecting hosts before relaying their mail.</p> <p>Note</p> <p>Authentication in KumoMTA can only occur on a TLS protected connection after <code>STARTTLS</code> has successfully been processed. This is because AUTH PLAIN credentials can be decoded and should not be sent over an open connection.</p>"},{"location":"userguide/policy/inbound_auth/#checking-authentication-against-a-static-user-table","title":"Checking Authentication Against a Static User Table","text":"<p>The simplest implementation of AUTH checking could be implemented by checking against a static value or table:</p> <pre><code>-- Use this to lookup and confirm a user/password credential\nkumo.on('smtp_server_auth_plain', function(authz, authc, password, conn_meta)\nlocal password_database = {\n['scott'] = 'tiger',\n}\nif password == '' then\nreturn false\nend\nreturn password_database[authc] == password\nend)\n</code></pre> <p>The preceding example, also seen on the smtp_server_auth_plain page of the Reference Manual, simply checks against a table of usernames and passwords, looking for a match. If the password is blank the function returns false, otherwise the function returns true if the password in the table for the named user matches the password provided in the AUTH request.</p>"},{"location":"userguide/policy/inbound_auth/#querying-a-datasource-for-authentication","title":"Querying a Datasource for Authentication","text":"<p>A common use case for relay hosts is validating AUTH credentials against a datasource for more dynamic management of sending users.</p> <p>In the following example, the provided credentials are checked against a SQLite database:</p> <pre><code>local sqlite = require 'sqlite'\n-- Consult a hypothetical sqlite database that has an auth table\n-- with user and pass fields\nfunction sqlite_auth_check(user, password)\nlocal db = sqlite.open '/path/to/auth.db'\nlocal result = db:execute(\n'select user from auth where user=? and pass=?',\nuser,\npassword\n)\n-- if we return the username, it is because the password matched\nreturn result[1] == user\nend\nkumo.on('smtp_server_auth_plain', function(authz, authc, password)\nreturn sqlite_auth_check(authc, password)\nend)\n</code></pre> <p>Warning</p> <p>To prevent blocking when checking data like AUTH credentials we recommend using the Memoize function to cache query results for future connections.</p>"},{"location":"userguide/policy/inbound_auth/#querying-a-keystore-for-authentication","title":"Querying a Keystore for Authentication","text":"<p>A more secure option for storing authentication credentials for checking is Hashicorp Vault. See the Storing Secrets in Hashicorp Vault page for more information on how to populate the credentials in the Vault as well as how to secure the connection credentials.</p> <pre><code>function vault_auth_check(user, password)\nreturn password\n== kumo.secrets.load {\nvault_mount = 'secret',\nvault_path = 'smtp-auth/' .. user,\n}\nend\nkumo.on('smtp_server_auth_plain', function(authz, authc, password)\nreturn vault_auth_check(authc, password)\nend)\n</code></pre>"},{"location":"userguide/policy/inbound_auth/#enhancing-tenant-security-through-smtp-authentication","title":"Enhancing Tenant Security Through SMTP Authentication","text":"<p>When using SMTP authentication a certain amount of trust is put in the injecting client, and there are ways this can be abused.</p> <p>One example of this is using headers for identifying which tenant a message is associated with when using the Queues Helper to manage queues; you can designate a custom header that contains the tenant name, trusting the user to provide their own tenant name, but if a malicious user discovers the tenant name of another user on the server, they can spoof the other tenant.</p> <p>To prevent this, you can use the <code>require_authz</code> option in the helper:</p> <pre><code>[tenant.'mytenant']\n# Which pool should be used for this tenant\negress_pool = 'pool-1'\n# Only the authorized identities are allowed to use this tenant via the tenant_header\n#require_authz = [\"scott\"]\n</code></pre> <p>This prevents users other than scott (multiple users can be specified) from using the tenant for sending.</p>"},{"location":"userguide/policy/routing/","title":"Configuring Message Routing","text":"<p>If you need to \"smarthost\" or route messages through another server, you have several options.</p>"},{"location":"userguide/policy/routing/#changing-the-routing-domain-at-reception-time-per-message","title":"Changing the routing domain at reception time (per-message)","text":"<p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>At reception time, you can specify an alternate routing domain for a message.  Messages with the same destination domain (based on their recipients) and routing domain will be queued into a separate scheduled queue from their normal destination domain.</p> <p>This is conceptually similar to the <code>queue</code> rewriting approach mentioned below, but the original destination domain, tenant and campaign information is preserved, and multiple separate scheduled queues are created to manage them.</p> <p>The example below will unconditionally smarthost all incoming messages to <code>my.smarthost.com</code>.  Mail originally destined for <code>example.com</code> will be queued into a scheduled queue named <code>example.com!my.smarthost.com</code> so that it can be managed independently of other domains.</p> <p>When delivering these messages, the regular MX resolution process will be performed but using <code>my.smarthost.com</code> instead of the recipient domain.</p> <p>This must be carried out in your smtp_server_message_received or http_message_generated event handler.</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\nmsg:set_meta('routing_domain', 'my.smarthost.com')\nend)\n</code></pre>"},{"location":"userguide/policy/routing/#explicitly-overriding-the-mx-resolution-for-a-scheduled-queue-domain-based","title":"Explicitly overriding the MX resolution for a scheduled queue (domain-based)","text":"<p>Since: Version 2023.08.22-4d895015</p> <p>The functionality described in this outlined box requires version 2023.08.22-4d895015 of KumoMTA, or a more recent version.</p> <p>If you are re-routing a domain to internal infrastructure that doesn't have MX records, then this technique may be suitable.  It works by overriding the MX resolution that would normally be used for a scheduled queue.</p> <p>The override is performed by setting the configuration for the scheduled queue using the get_queue_config event:</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nif domain == 'domain.to.be.smart.hosted' then\n-- Relay via some other internal infrastructure.\n-- Enclose IP (or IPv6) addresses in `[]`.\n-- Otherwise the name will be resolved for A and AAAA records\nreturn kumo.make_queue_config {\nprotocol = {\nsmtp = {\nmx_list = { 'smart.host.local', { name = 'mx.example.com', addr = '10.0.0.1' }}\n},\n},\n}\nend\n-- Otherwise, just use the defaults\nreturn kumo.make_queue_config {}\nend)\n</code></pre> <p>This approach will resolve <code>A</code>/<code>AAAA</code> records but not <code>MX</code> records for the list of hosts in <code>mx_list</code>.  <code>mx_list</code> is used as the ordered list of hosts to which the message should be delivered.  It is used in place of the normal MX resolution that would have been carried out for the domain.</p> <p>With this approach, the original scheduled queue name remains as it was.</p>"},{"location":"userguide/policy/routing/#rewriting-the-queue-at-reception-time-per-message","title":"Rewriting the queue at reception time (per-message)","text":"<p>Note</p> <p>Using the <code>routing_domain</code> approach mentioned above is generally preferred to this approach, as it preserves tenant and campaign information with no additional work required on your part.</p> <p>At reception time, you can override the default scheduled queue that a message will be placed into.  The original recipient domain, campaign and tenant information are effectively ignored when using this technique.</p> <p>The example below will unconditionally assign all incoming messages to the scheduled queue for <code>my.smarthost.com</code>.</p> <p>When delivering these messages, the regular MX resolution process will be performed but using <code>my.smarthost.com</code> instead of the recipient domain.</p> <p>This must be carried out in your smtp_server_message_received or http_message_generated event handler.</p> <pre><code>kumo.on('smtp_server_message_received', function(msg)\nmsg:set_meta('queue', 'my.smarthost.com')\nend)\n</code></pre>"},{"location":"userguide/policy/routing/#a-note-on-ipv4-and-ipv6-literal-addresses","title":"A note on IPv4 and IPv6 literal Addresses","text":"<p>When rewriting the routing domain or queue, it is possible to specify literal addresses instead of DNS names, but those must still be compliant with the SMTP specification which requires that literal address domains be enclosed in square brackets.</p> <p>For example:</p> <ul> <li><code>[10.0.0.1]</code> is a valid IPv4 domain literal</li> <li><code>[IPv6:::1]</code> is a valid IPv6 domain literal representing the <code>::1</code> address.</li> <li><code>[::1]</code> is an invalid, non-conforming IPv6 domain literal, because it is     missing the <code>IPv6:</code> address tag prefix, but is accepted by KumoMTA and treated     as an IPv6 address. In the context of smart-hosting, this is no problem, but     in general we do not recommend using this non-conforming syntax in the envelope     or body of your messages as it may not be supported by downstream MTAs.</li> </ul> <pre><code>kumo.on('smtp_server_message_received', function(msg)\nmsg:set_meta('queue', '[20.83.209.56]')\nend)\n</code></pre>"},{"location":"userguide/policy/tenantpool/","title":"Advanced Tenant to Pool Mapping","text":"<p>if you want to verify that the tenant is a known-good tenant then I'd recommend handling that in the smtp_server_message_received event:</p> <pre><code>local tenant = msg:get_first_named_header_value 'X-tenant'\nif not tenant then\nkumo.reject(500, 'missing x-tenant header')\nend\nlocal TENANT_TO_POOL = {\n['tenant-id-0'] = 'pool-0',\n['tenant-id-1'] = 'pool-0',\n['tenant-id-2'] = 'pool-1',\n}\nif not TENANT_TO_POOL[tenant] then\nkumo.reject(500, 'invalid/unknown tenant ' .. tenant)\nend\nmsg:set_meta('tenant', tenant)\n</code></pre> <p>You could then reference that same TENANT_TO_POOL mapping later on:</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nlocal params = {\nmax_age = '5 minutes',\nretry_interval = '10 minutes',\nmax_retry_interval = '100 minutes',\negress_pool = TENANT_TO_POOL[tenant], -- here\n}\nmerge_into(TENANT_PARAMS[tenant] or {}, params)\nreturn kumo.make_queue_config(params)\nend)\n</code></pre> <p>TENANT_TO_POOL could also be a json file, sqlite db and so on</p> <p>more robust tenant validation should probably consider the sending domain as well.  Maybe the data looks</p> <pre><code>local TENANTS = {\n['tenant-id-0'] = {\ndomain_to_pool = {\n['tenant-0.com'] = 'pool-0',\n},\n},\n}\n</code></pre> <p>and the policy should check the msg:sender().domain as well as the tenant before accepting the message</p> <p>if you want to allow leaving the pool unspecified then:</p> <pre><code>kumo.on('get_queue_config', function(domain, tenant, campaign, routing_domain)\nlocal params = {\nmax_age = '5 minutes',\nretry_interval = '10 minutes',\nmax_retry_interval = '100 minutes',\negress_pool = TENANT_TO_POOL[tenant], -- HERE\n}\nmerge_into(TENANT_PARAMS[tenant] or {}, params)\nreturn kumo.make_queue_config(params)\nend)\n</code></pre> <p>the HERE bit will evaluate to nil if there is no valid mapping, which is equivalent to leaving the pool unspecified, which is valid: not special source configuration will be used in that case, and we'll use whatever IP the kernel chooses when we try to connect</p> <p>if you want to use an explicitly configured pool instead of the default unspecified behavior, then you can do:</p> <pre><code>egress_pool = TENANT_TO_POOL[tenant] or 'my-fallback-pool-name'\n</code></pre>"}]}